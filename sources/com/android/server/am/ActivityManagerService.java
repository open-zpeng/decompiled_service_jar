package com.android.server.am;

import android.annotation.SuppressLint;
import android.app.ActivityManager;
import android.app.ActivityManagerInternal;
import android.app.ActivityOptions;
import android.app.ActivityThread;
import android.app.AlertDialog;
import android.app.AppGlobals;
import android.app.AppOpsManager;
import android.app.ApplicationErrorReport;
import android.app.ContentProviderHolder;
import android.app.Dialog;
import android.app.GrantedUriPermission;
import android.app.IActivityController;
import android.app.IActivityManager;
import android.app.IApplicationThread;
import android.app.IAssistDataReceiver;
import android.app.IInstrumentationWatcher;
import android.app.IProcessObserver;
import android.app.IServiceConnection;
import android.app.IStopUserCallback;
import android.app.ITaskStackListener;
import android.app.IUiAutomationConnection;
import android.app.IUidObserver;
import android.app.IUserSwitchObserver;
import android.app.Notification;
import android.app.PendingIntent;
import android.app.PictureInPictureParams;
import android.app.ProcessMemoryState;
import android.app.ProfilerInfo;
import android.app.RemoteAction;
import android.app.WaitResult;
import android.app.WindowConfiguration;
import android.app.admin.DevicePolicyCache;
import android.app.assist.AssistContent;
import android.app.assist.AssistStructure;
import android.app.backup.IBackupManager;
import android.app.usage.UsageStatsManagerInternal;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.ContentProvider;
import android.content.ContentResolver;
import android.content.Context;
import android.content.IContentProvider;
import android.content.IIntentReceiver;
import android.content.IIntentSender;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.ConfigurationInfo;
import android.content.pm.IPackageManager;
import android.content.pm.InstrumentationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PackageManagerInternal;
import android.content.pm.ParceledListSlice;
import android.content.pm.PathPermission;
import android.content.pm.PermissionInfo;
import android.content.pm.ProviderInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.UserInfo;
import android.content.res.CompatibilityInfo;
import android.content.res.Configuration;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.graphics.Point;
import android.graphics.Rect;
import android.hardware.display.DisplayManagerInternal;
import android.metrics.LogMaker;
import android.net.NetworkPolicyManager;
import android.net.Uri;
import android.net.util.NetworkConstants;
import android.os.Binder;
import android.os.Build;
import android.os.Bundle;
import android.os.Debug;
import android.os.DropBoxManager;
import android.os.Environment;
import android.os.FactoryTest;
import android.os.FileObserver;
import android.os.FileUtils;
import android.os.Handler;
import android.os.IBinder;
import android.os.ICancellationSignal;
import android.os.IPermissionController;
import android.os.IProcessInfoService;
import android.os.IProgressListener;
import android.os.LocaleList;
import android.os.Looper;
import android.os.Message;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.PersistableBundle;
import android.os.PowerManager;
import android.os.PowerManagerInternal;
import android.os.Process;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.os.ResultReceiver;
import android.os.ServiceManager;
import android.os.ShellCallback;
import android.os.StrictMode;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.os.Trace;
import android.os.TransactionTooLargeException;
import android.os.UpdateLock;
import android.os.UserHandle;
import android.os.UserManager;
import android.os.WorkSource;
import android.provider.Settings;
import android.service.voice.IVoiceInteractionSession;
import android.service.voice.VoiceInteractionManagerInternal;
import android.telecom.TelecomManager;
import android.text.TextUtils;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.AtomicFile;
import android.util.BoostFramework;
import android.util.DebugUtils;
import android.util.EventLog;
import android.util.Log;
import android.util.LongSparseArray;
import android.util.Pair;
import android.util.PrintWriterPrinter;
import android.util.Slog;
import android.util.SparseArray;
import android.util.SparseIntArray;
import android.util.StatsLog;
import android.util.TimeUtils;
import android.util.Xml;
import android.util.proto.ProtoOutputStream;
import android.util.proto.ProtoUtils;
import android.view.IRecentsAnimationRunner;
import android.view.LayoutInflater;
import android.view.RemoteAnimationAdapter;
import android.view.RemoteAnimationDefinition;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import com.android.internal.annotations.GuardedBy;
import com.android.internal.annotations.VisibleForTesting;
import com.android.internal.app.AssistUtils;
import com.android.internal.app.DumpHeapActivity;
import com.android.internal.app.IAppOpsCallback;
import com.android.internal.app.IAppOpsService;
import com.android.internal.app.IVoiceInteractionSessionShowCallback;
import com.android.internal.app.IVoiceInteractor;
import com.android.internal.app.ProcessMap;
import com.android.internal.logging.MetricsLogger;
import com.android.internal.os.BackgroundThread;
import com.android.internal.os.BatteryStatsImpl;
import com.android.internal.os.IResultReceiver;
import com.android.internal.os.ProcessCpuTracker;
import com.android.internal.os.TransferPipe;
import com.android.internal.os.logging.MetricsLoggerWrapper;
import com.android.internal.policy.IKeyguardDismissCallback;
import com.android.internal.policy.KeyguardDismissCallback;
import com.android.internal.util.DumpUtils;
import com.android.internal.util.FastPrintWriter;
import com.android.internal.util.FastXmlSerializer;
import com.android.internal.util.MemInfoReader;
import com.android.internal.util.Preconditions;
import com.android.internal.util.XmlUtils;
import com.android.server.AppOpsService;
import com.android.server.BatteryService;
import com.android.server.BinderCallsStatsService;
import com.android.server.DeviceIdleController;
import com.android.server.GraphicsStatsService;
import com.android.server.IntentResolver;
import com.android.server.IoThread;
import com.android.server.LocalServices;
import com.android.server.LockGuard;
import com.android.server.NetworkManagementInternal;
import com.android.server.RescueParty;
import com.android.server.ServiceThread;
import com.android.server.SystemConfig;
import com.android.server.SystemService;
import com.android.server.SystemServiceManager;
import com.android.server.ThreadPriorityBooster;
import com.android.server.UiModeManagerService;
import com.android.server.UiThread;
import com.android.server.Watchdog;
import com.android.server.am.ActivityManagerService;
import com.android.server.am.ActivityStack;
import com.android.server.am.MemoryStatUtil;
import com.android.server.am.PendingIntentRecord;
import com.android.server.am.UidRecord;
import com.android.server.am.UriPermission;
import com.android.server.backup.BackupAgentTimeoutParameters;
import com.android.server.backup.BackupManagerConstants;
import com.android.server.connectivity.NetworkAgentInfo;
import com.android.server.firewall.IntentFirewall;
import com.android.server.hdmi.HdmiCecKeycode;
import com.android.server.job.JobSchedulerInternal;
import com.android.server.job.JobSchedulerShellCommand;
import com.android.server.job.controllers.JobStatus;
import com.android.server.pm.DumpState;
import com.android.server.pm.Installer;
import com.android.server.pm.PackageManagerService;
import com.android.server.policy.PhoneWindowManager;
import com.android.server.policy.WindowManagerPolicy;
import com.android.server.slice.SliceClientPermissions;
import com.android.server.utils.PriorityDump;
import com.android.server.vr.VrManagerInternal;
import com.android.server.wm.PinnedStackWindowController;
import com.android.server.wm.WindowManagerService;
import com.google.android.collect.Lists;
import com.google.android.collect.Maps;
import com.xiaopeng.app.ActivityInfoManager;
import com.xiaopeng.app.xpActivityInfo;
import com.xiaopeng.app.xpActivityManager;
import com.xiaopeng.app.xpDialogInfo;
import com.xiaopeng.server.app.xpActivityManagerService;
import com.xiaopeng.server.policy.xpBootManagerPolicy;
import com.xiaopeng.server.xpSystemServer;
import com.xiaopeng.util.FeatureFactory;
import com.xiaopeng.util.xpLogger;
import com.xpeng.server.am.BootEvent;
import dalvik.system.VMRuntime;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.lang.ref.WeakReference;
import java.nio.charset.StandardCharsets;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import libcore.io.IoUtils;
import org.json.JSONObject;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;
@SuppressLint({"all"})
/* loaded from: classes.dex */
public class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback {
    public static final String ACTION_TRIGGER_IDLE = "com.android.server.ACTION_TRIGGER_IDLE";
    static final int ALLOW_FULL_ONLY = 2;
    static final int ALLOW_NON_FULL = 0;
    static final int ALLOW_NON_FULL_IN_PROFILE = 1;
    static final boolean ANIMATE = true;
    static final long APP_SWITCH_DELAY_TIME = 5000;
    private static final String ATTR_CREATED_TIME = "createdTime";
    private static final String ATTR_MODE_FLAGS = "modeFlags";
    private static final String ATTR_PREFIX = "prefix";
    private static final String ATTR_SOURCE_PKG = "sourcePkg";
    private static final String ATTR_SOURCE_USER_ID = "sourceUserId";
    private static final String ATTR_TARGET_PKG = "targetPkg";
    private static final String ATTR_TARGET_USER_ID = "targetUserId";
    private static final String ATTR_URI = "uri";
    private static final String ATTR_USER_HANDLE = "userHandle";
    static final long BATTERY_STATS_TIME = 1800000;
    static final int BROADCAST_BG_TIMEOUT = 60000;
    static final int BROADCAST_FG_TIMEOUT = 10000;
    static final int CANCEL_HEAVY_NOTIFICATION_MSG = 25;
    static final int CHECK_EXCESSIVE_POWER_USE_MSG = 27;
    static final int CLEAR_DNS_CACHE_MSG = 28;
    static final int COLLECT_PSS_BG_MSG = 1;
    static final int CONTENT_PROVIDER_PUBLISH_TIMEOUT = 10000;
    static final int CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG = 57;
    static final int CONTENT_PROVIDER_WAIT_TIMEOUT = 20000;
    static final int DELETE_DUMPHEAP_MSG = 51;
    static final int DISMISS_DIALOG_UI_MSG = 48;
    static final int DISPATCH_OOM_ADJ_OBSERVER_MSG = 70;
    static final int DISPATCH_PENDING_INTENT_CANCEL_MSG = 67;
    static final int DISPATCH_PROCESSES_CHANGED_UI_MSG = 31;
    static final int DISPATCH_PROCESS_DIED_UI_MSG = 32;
    static final int DISPATCH_SCREEN_AWAKE_MSG = 64;
    static final int DISPATCH_SCREEN_KEYGUARD_MSG = 65;
    static final int DISPATCH_UIDS_CHANGED_UI_MSG = 53;
    static final int DROPBOX_MAX_SIZE = 196608;
    static final int ENTER_ANIMATION_COMPLETE_MSG = 44;
    static final int FINALIZE_PENDING_INTENT_MSG = 23;
    static final int FINISH_BOOTING_MSG = 45;
    static final int FIRST_ACTIVITY_STACK_MSG = 100;
    static final int FIRST_BROADCAST_QUEUE_MSG = 200;
    static final int FIRST_COMPAT_MODE_MSG = 300;
    static final int FIRST_SUPERVISOR_STACK_MSG = 100;
    static final int GC_BACKGROUND_PROCESSES_MSG = 5;
    static final int HANDLE_TRUST_STORAGE_UPDATE_MSG = 63;
    static final int IDLE_UIDS_MSG = 58;
    static final int IMMERSIVE_MODE_LOCK_MSG = 37;
    private static final int INSTRUMENTATION_FLAG_DISABLE_HIDDEN_API_CHECKS = 1;
    static final int INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT = 60000;
    private static final String INTENT_REMOTE_BUGREPORT_FINISHED = "com.android.internal.intent.action.REMOTE_BUGREPORT_FINISHED";
    static final int KEY_DISPATCHING_TIMEOUT = 5000;
    static final int KILL_APPLICATION_MSG = 22;
    private static final int KSM_SHARED = 0;
    private static final int KSM_SHARING = 1;
    private static final int KSM_UNSHARED = 2;
    private static final int KSM_VOLATILE = 3;
    static final int LOG_STACK_STATE = 60;
    private static final int MAX_BUGREPORT_TITLE_SIZE = 50;
    private static final int MAX_DUP_SUPPRESSED_STACKS = 5000;
    static final int MAX_PERSISTED_URI_GRANTS = 128;
    private static final int MAX_RECEIVERS_ALLOWED_PER_APP = 1000;
    private static final int MEMINFO_COMPACT_VERSION = 1;
    static final long MONITOR_CPU_MAX_TIME = 268435455;
    static final long MONITOR_CPU_MIN_TIME = 5000;
    static final boolean MONITOR_CPU_USAGE = true;
    static final boolean MONITOR_THREAD_CPU_USAGE = false;
    private static final int NATIVE_DUMP_TIMEOUT_MS = 2000;
    private static final long NETWORK_ACCESS_TIMEOUT_DEFAULT_MS = 200;
    @VisibleForTesting
    static final int NETWORK_STATE_BLOCK = 1;
    @VisibleForTesting
    static final int NETWORK_STATE_NO_CHANGE = 0;
    @VisibleForTesting
    static final int NETWORK_STATE_UNBLOCK = 2;
    static final int NOTIFY_CLEARTEXT_NETWORK_MSG = 49;
    static final int PENDING_ASSIST_EXTRAS_LONG_TIMEOUT = 2000;
    static final int PENDING_ASSIST_EXTRAS_TIMEOUT = 500;
    static final int PENDING_AUTOFILL_ASSIST_STRUCTURE_TIMEOUT = 2000;
    private static final int PERSISTENT_MASK = 9;
    static final int PERSIST_URI_GRANTS_MSG = 38;
    static final int POST_DUMP_HEAP_NOTIFICATION_MSG = 50;
    static final int POST_HEAVY_NOTIFICATION_MSG = 24;
    static final int POST_PACKAGES_NOTIFICATION_MSG = 71;
    static final int PROC_START_TIMEOUT = 10000;
    static final int PROC_START_TIMEOUT_MSG = 20;
    static final int PROC_START_TIMEOUT_WITH_WRAPPER = 1200000;
    static final int PUSH_TEMP_WHITELIST_UI_MSG = 68;
    static final int REPORT_MEM_USAGE_MSG = 33;
    static final int REPORT_TIME_TRACKER_MSG = 54;
    static final int RESERVED_BYTES_PER_LOGCAT_LINE = 100;
    static final int SEND_LOCALE_TO_MOUNT_DAEMON_MSG = 47;
    static final int SERVICE_FOREGROUND_CRASH_MSG = 69;
    static final int SERVICE_FOREGROUND_TIMEOUT_MSG = 66;
    static final String SERVICE_RECORD_KEY = "servicerecord";
    static final int SERVICE_TIMEOUT_MSG = 12;
    static final int SHOW_COMPAT_MODE_DIALOG_UI_MSG = 30;
    static final int SHOW_ERROR_UI_MSG = 1;
    static final int SHOW_FACTORY_ERROR_UI_MSG = 3;
    static final int SHOW_FINGERPRINT_ERROR_UI_MSG = 15;
    static final int SHOW_NOT_RESPONDING_UI_MSG = 2;
    static final int SHOW_STRICT_MODE_VIOLATION_UI_MSG = 26;
    static final int SHOW_UID_ERROR_UI_MSG = 14;
    static final int SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG = 56;
    private static final int SLOW_UID_OBSERVER_THRESHOLD_MS = 20;
    static final int STOCK_PM_FLAGS = 1024;
    static final String SYSTEM_DEBUGGABLE = "ro.debuggable";
    private static final String SYSUI_COMPONENT_NAME = "com.android.systemui/.SystemUIService";
    private static final String TAG = "ActivityManager";
    private static final String TAG_BACKUP = "ActivityManager";
    private static final String TAG_BROADCAST = "ActivityManager";
    private static final String TAG_CLEANUP = "ActivityManager";
    private static final String TAG_CONFIGURATION = "ActivityManager";
    private static final String TAG_FOCUS = "ActivityManager";
    private static final String TAG_IMMERSIVE = "ActivityManager";
    private static final String TAG_LOCKTASK = "ActivityManager";
    private static final String TAG_LRU = "ActivityManager";
    private static final String TAG_MU = "ActivityManager_MU";
    private static final String TAG_NETWORK = "ActivityManager_Network";
    private static final String TAG_OOM_ADJ = "ActivityManager";
    private static final String TAG_POWER = "ActivityManager";
    private static final String TAG_PROCESSES = "ActivityManager";
    private static final String TAG_PROCESS_OBSERVERS = "ActivityManager";
    private static final String TAG_PROVIDER = "ActivityManager";
    private static final String TAG_PSS = "ActivityManager";
    private static final String TAG_RECENTS = "ActivityManager";
    private static final String TAG_SERVICE = "ActivityManager";
    private static final String TAG_STACK = "ActivityManager";
    private static final String TAG_SWITCH = "ActivityManager";
    private static final String TAG_UID_OBSERVERS = "ActivityManager";
    private static final String TAG_URI_GRANT = "uri-grant";
    private static final String TAG_URI_GRANTS = "uri-grants";
    private static final String TAG_URI_PERMISSION = "ActivityManager";
    private static final String TAG_VISIBILITY = "ActivityManager";
    static final boolean TAKE_FULLSCREEN_SCREENSHOTS = true;
    public static final int TOP_APP_PRIORITY_BOOST = -10;
    static final int UPDATE_CONFIGURATION_MSG = 4;
    static final int UPDATE_HTTP_PROXY_MSG = 29;
    static final int UPDATE_TIME_PREFERENCE_MSG = 41;
    static final int UPDATE_TIME_ZONE = 13;
    static final boolean VALIDATE_UID_STATES = true;
    static final int VR_MODE_CHANGE_MSG = 61;
    static final int WAIT_FOR_DEBUGGER_UI_MSG = 6;
    @GuardedBy("ActivityManagerService.class")
    private static SimpleDateFormat sAnrFileDateFormat;
    final int GL_ES_VERSION;
    final ArrayList<ActiveInstrumentation> mActiveInstrumentation;
    ProcessChangeItem[] mActiveProcessChanges;
    UidRecord.ChangeItem[] mActiveUidChanges;
    final SparseArray<UidRecord> mActiveUids;
    ComponentName mActiveVoiceInteractionServiceComponent;
    private final ActivityStartController mActivityStartController;
    int mAdjSeq;
    final SparseArray<ArrayMap<String, Integer>> mAllowAppSwitchUids;
    boolean mAllowLowerMemLevel;
    private final HashSet<Integer> mAlreadyLoggedViolatedStacks;
    boolean mAlwaysFinishActivities;
    private Map<String, String> mAppAgentMap;
    ArrayMap<String, IBinder> mAppBindArgs;
    final AppErrors mAppErrors;
    final AppOpsService mAppOpsService;
    long mAppSwitchesAllowedTime;
    final AppWarnings mAppWarnings;
    private AssistUtils mAssistUtils;
    final SparseArray<ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>>> mAssociations;
    final ArrayList<ProcessChangeItem> mAvailProcessChanges;
    final ArrayList<UidRecord.ChangeItem> mAvailUidChanges;
    int[] mBackgroundAppIdWhitelist;
    ArraySet<String> mBackgroundLaunchBroadcasts;
    String mBackupAppName;
    BackupRecord mBackupTarget;
    final BatteryStatsService mBatteryStatsService;
    BroadcastQueue mBgBroadcastQueue;
    final Handler mBgHandler;
    private boolean mBinderTransactionTrackingEnabled;
    @GuardedBy("this")
    boolean mBootAnimationComplete;
    int mBootPhase;
    boolean mBooted;
    @GuardedBy("this")
    boolean mBooting;
    final BroadcastQueue[] mBroadcastQueues;
    @GuardedBy("this")
    boolean mCallFinishBooting;
    @GuardedBy("this")
    private boolean mCheckedForSetup;
    CompatModeDialog mCompatModeDialog;
    final CompatModePackages mCompatModePackages;
    private int mConfigurationSeq;
    final ActivityManagerConstants mConstants;
    final Context mContext;
    IActivityController mController;
    boolean mControllerIsAMonkey;
    CoreSettingsObserver mCoreSettingsObserver;
    private AppTimeTracker mCurAppTimeTracker;
    BroadcastStats mCurBroadcastStats;
    OomAdjObserver mCurOomAdjObserver;
    int mCurOomAdjUid;
    private String mCurResumedPackage;
    private int mCurResumedUid;
    String mDebugApp;
    boolean mDebugTransient;
    DevelopmentSettingsObserver mDevelopmentSettingsObserver;
    int[] mDeviceIdleExceptIdleWhitelist;
    int[] mDeviceIdleTempWhitelist;
    int[] mDeviceIdleWhitelist;
    String mDeviceOwnerName;
    boolean mDidAppSwitch;
    volatile int mFactoryTest;
    BroadcastQueue mFgBroadcastQueue;
    FontScaleSettingObserver mFontScaleSettingObserver;
    boolean mForceBackgroundCheck;
    boolean mForceResizableActivities;
    final ProcessMap<ArrayList<ProcessRecord>> mForegroundPackages;
    boolean mFullPssPending;
    float mFullscreenThumbnailScale;
    private final AtomicFile mGrantFile;
    @GuardedBy("this")
    private final SparseArray<ArrayMap<GrantUri, UriPermission>> mGrantedUriPermissions;
    final MainHandler mHandler;
    final ServiceThread mHandlerThread;
    boolean mHasHeavyWeightFeature;
    ProcessRecord mHeavyWeightProcess;
    final HiddenApiSettings mHiddenApiBlacklist;
    ProcessRecord mHomeProcess;
    final SparseArray<ImportanceToken> mImportantProcesses;
    private final Injector mInjector;
    private Installer mInstaller;
    final InstrumentationReporter mInstrumentationReporter;
    public final IntentFirewall mIntentFirewall;
    final HashMap<PendingIntentRecord.Key, WeakReference<PendingIntentRecord>> mIntentSenderRecords;
    ArrayMap<String, IBinder> mIsolatedAppBindArgs;
    final SparseArray<ProcessRecord> mIsolatedProcesses;
    private final KeyguardController mKeyguardController;
    private boolean mKeyguardShown;
    String mLastANRState;
    private ActivityRecord mLastActivityRecord;
    BroadcastStats mLastBroadcastStats;
    final AtomicLong mLastCpuTime;
    long mLastFullPssTime;
    long mLastIdleTime;
    long mLastMemUsageReportTime;
    int mLastMemoryLevel;
    int mLastNumProcesses;
    long mLastPowerCheckUptime;
    private ActivityRecord mLastResumedActivity;
    long mLastWriteTime;
    @GuardedBy("this")
    boolean mLaunchWarningShown;
    final ArrayList<ContentProviderRecord> mLaunchingProviders;
    private final ClientLifecycleManager mLifecycleManager;
    DeviceIdleController.LocalService mLocalDeviceIdleController;
    PowerManagerInternal mLocalPowerManager;
    private final LockTaskController mLockTaskController;
    long mLowRamStartTime;
    long mLowRamTimeSinceLastIdle;
    int mLruProcessActivityStart;
    int mLruProcessServiceStart;
    final ArrayList<ProcessRecord> mLruProcesses;
    int mLruSeq;
    String mMemWatchDumpFile;
    int mMemWatchDumpPid;
    String mMemWatchDumpProcName;
    int mMemWatchDumpUid;
    final ProcessMap<Pair<Long, String>> mMemWatchProcesses;
    String mNativeDebuggingApp;
    int mNewNumAServiceProcs;
    int mNewNumServiceProcs;
    int mNextIsolatedProcessUid;
    private boolean mNotifyRecentActivity;
    int mNumCachedHiddenProcs;
    int mNumNonCachedProcs;
    int mNumServiceProcs;
    volatile boolean mOnBattery;
    String mOrigDebugApp;
    boolean mOrigWaitForDebugger;
    PackageManagerInternal mPackageManagerInt;
    final ArrayList<PendingAssistExtras> mPendingAssistExtras;
    final ArrayList<ProcessChangeItem> mPendingProcessChanges;
    final ArrayList<ProcessRecord> mPendingPssProcesses;
    @GuardedBy("this")
    private final LongSparseArray<ProcessRecord> mPendingStarts;
    final SparseArray<PendingTempWhitelist> mPendingTempWhitelist;
    final ArrayList<UidRecord.ChangeItem> mPendingUidChanges;
    final boolean mPermissionReviewRequired;
    final ArrayList<ProcessRecord> mPersistentStartingProcesses;
    final SparseArray<ProcessRecord> mPidsSelfLocked;
    private ActivityRecord mPostActivityRecord;
    ProcessRecord mPreviousProcess;
    long mPreviousProcessVisibleTime;
    private final PriorityDump.PriorityDumper mPriorityDumper;
    final Handler mProcStartHandler;
    final ServiceThread mProcStartHandlerThread;
    @GuardedBy("this")
    private long mProcStartSeqCounter;
    @GuardedBy("this")
    @VisibleForTesting
    long mProcStateSeqCounter;
    final CountDownLatch mProcessCpuInitLatch;
    final AtomicBoolean mProcessCpuMutexFree;
    final Thread mProcessCpuThread;
    final ProcessCpuTracker mProcessCpuTracker;
    final ProcessList mProcessList;
    final ProcessMap<ProcessRecord> mProcessNames;
    final RemoteCallbackList<IProcessObserver> mProcessObservers;
    private final long[] mProcessStateStatsLongs;
    final ProcessStatsService mProcessStats;
    final ArrayList<ProcessRecord> mProcessesOnHold;
    volatile boolean mProcessesReady;
    final ArrayList<ProcessRecord> mProcessesToGc;
    String mProfileApp;
    ProcessRecord mProfileProc;
    int mProfileType;
    ProfilerInfo mProfilerInfo;
    final ProviderMap mProviderMap;
    final IntentResolver<BroadcastFilter, BroadcastFilter> mReceiverResolver;
    private final RecentTasks mRecentTasks;
    final HashMap<IBinder, ReceiverList> mRegisteredReceivers;
    final ArrayList<ProcessRecord> mRemovedProcesses;
    IVoiceInteractionSession mRunningVoice;
    boolean mSafeMode;
    final List<ActivityManagerInternal.ScreenObserver> mScreenObservers;
    final ActiveServices mServices;
    private boolean mShowDialogs;
    boolean mShuttingDown;
    private boolean mSleeping;
    final ActivityStackSupervisor mStackSupervisor;
    final SparseArray<ArrayMap<String, ArrayList<Intent>>> mStickyBroadcasts;
    final StringBuilder mStringBuilder;
    private String[] mSupportedSystemLocales;
    boolean mSupportsFreeformWindowManagement;
    boolean mSupportsLeanbackOnly;
    boolean mSupportsMultiDisplay;
    boolean mSupportsMultiWindow;
    boolean mSupportsPictureInPicture;
    boolean mSupportsSplitScreenMultiWindow;
    boolean mSuppressResizeConfigChanges;
    boolean mSystemProvidersInstalled;
    volatile boolean mSystemReady;
    SystemServiceManager mSystemServiceManager;
    final ActivityThread mSystemThread;
    final TaskChangeNotificationController mTaskChangeNotificationController;
    private Configuration mTempConfig;
    boolean mTestPssMode;
    int mThumbnailHeight;
    int mThumbnailWidth;
    private final ArraySet<BroadcastQueue> mTmpBroadcastQueue;
    final long[] mTmpLong;
    private final UpdateConfigurationResult mTmpUpdateConfigurationResult;
    String mTopAction;
    ComponentName mTopComponent;
    String mTopData;
    int mTopProcessState;
    private ActivityRecord mTracedResumedActivity;
    String mTrackAllocationApp;
    boolean mTrackingAssociations;
    final Context mUiContext;
    final Handler mUiHandler;
    int mUidChangeDispatchCount;
    final RemoteCallbackList<IUidObserver> mUidObservers;
    final UpdateLock mUpdateLock;
    UsageStatsManagerInternal mUsageStatsService;
    private boolean mUseFifoUiScheduling;
    final UserController mUserController;
    private boolean mUserIsMonkey;
    final SparseArray<UidRecord> mValidateUids;
    private int mViSessionId;
    PowerManager.WakeLock mVoiceWakeLock;
    int mVr2dDisplayId;
    private final VrController mVrController;
    boolean mWaitForDebugger;
    @VisibleForTesting
    long mWaitForNetworkTimeoutMs;
    private int mWakefulness;
    WindowManagerService mWindowManager;
    private volatile int mWtfClusterCount;
    private volatile long mWtfClusterStart;
    static final int MY_PID = Process.myPid();
    static final String[] EMPTY_STRING_ARRAY = new String[0];
    public static BoostFramework mSpecificAppPerfHint = new BoostFramework();
    private static ThreadPriorityBooster sThreadPriorityBooster = new ThreadPriorityBooster(-2, 6);
    private static final ThreadLocal<Identity> sCallerIdentity = new ThreadLocal<>();
    static ServiceThread sKillThread = null;
    static KillHandler sKillHandler = null;
    private static String sTheRealBuildSerial = UiModeManagerService.Shell.NIGHT_MODE_STR_UNKNOWN;
    private static final int[] PROCESS_STATE_STATS_FORMAT = {32, 544, 10272};
    static final long[] DUMP_MEM_BUCKETS = {5120, 7168, 10240, 15360, 20480, 30720, 40960, 81920, 122880, 163840, 204800, 256000, 307200, 358400, 409600, 512000, 614400, 819200, 1048576, 2097152, 5242880, 10485760, 20971520};
    static final int[] DUMP_MEM_OOM_ADJ = {JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -900, -800, -700, 0, 100, 200, 300, 400, 500, 600, 700, 800, 900};
    static final String[] DUMP_MEM_OOM_LABEL = {"Native", "System", "Persistent", "Persistent Service", "Foreground", "Visible", "Perceptible", "Heavy Weight", "Backup", "A Services", "Home", "Previous", "B Services", "Cached"};
    static final String[] DUMP_MEM_OOM_COMPACT_LABEL = {"native", "sys", "pers", "persvc", "fore", "vis", "percept", "heavy", BatteryService.HealthServiceWrapper.INSTANCE_HEALTHD, "servicea", "home", "prev", "serviceb", "cached"};

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public interface OomAdjObserver {
        void onOomAdjMessage(String str);
    }

    static /* synthetic */ void access$1000(ActivityManagerService x0) {
        x0.writeGrantedUriPermissions();
    }

    static /* synthetic */ boolean access$1102(ActivityManagerService x0, boolean x1) {
        x0.mUserIsMonkey = x1;
        return x1;
    }

    static /* synthetic */ VrController access$1200(ActivityManagerService x0) {
        return x0.mVrController;
    }

    static /* synthetic */ ActivityRecord access$1300(ActivityManagerService x0) {
        return x0.mLastActivityRecord;
    }

    static /* synthetic */ ActivityRecord access$1302(ActivityManagerService x0, ActivityRecord x1) {
        x0.mLastActivityRecord = x1;
        return x1;
    }

    static /* synthetic */ String access$1400(ActivityManagerService x0, ComponentName x1, ComponentName x2) {
        return x0.createPackageNotificationExtra(x1, x2);
    }

    static /* synthetic */ ActivityRecord access$1502(ActivityManagerService x0, ActivityRecord x1) {
        x0.mPostActivityRecord = x1;
        return x1;
    }

    static /* synthetic */ void access$800(ActivityManagerService x0, ProcessRecord x1) {
        x0.processStartTimedOutLocked(x1);
    }

    static /* synthetic */ void access$900(ActivityManagerService x0, ProcessRecord x1) {
        x0.processContentProviderPublishTimedOutLocked(x1);
    }

    BroadcastQueue broadcastQueueForIntent(Intent intent) {
        boolean isFg = (intent.getFlags() & 268435456) != 0;
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST_BACKGROUND) {
            StringBuilder sb = new StringBuilder();
            sb.append("Broadcast intent ");
            sb.append(intent);
            sb.append(" on ");
            sb.append(isFg ? "foreground" : "background");
            sb.append(" queue");
            Slog.i("ActivityManager", sb.toString());
        }
        return isFg ? this.mFgBroadcastQueue : this.mBgBroadcastQueue;
    }

    public boolean canShowErrorDialogs() {
        if (!this.mShowDialogs || this.mSleeping || this.mShuttingDown || this.mKeyguardController.isKeyguardOrAodShowing(0) || this.mUserController.hasUserRestriction("no_system_error_dialogs", this.mUserController.getCurrentUserId())) {
            return false;
        }
        return (UserManager.isDeviceInDemoMode(this.mContext) && this.mUserController.getCurrentUser().isDemo()) ? false : true;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public static void boostPriorityForLockedSection() {
        sThreadPriorityBooster.boost();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public static void resetPriorityAfterLockedSection() {
        sThreadPriorityBooster.reset();
    }

    /* loaded from: classes.dex */
    public class PendingAssistExtras extends Binder implements Runnable {
        public final ActivityRecord activity;
        public final Bundle extras;
        public final String hint;
        public final Intent intent;
        public boolean isHome;
        public final IAssistDataReceiver receiver;
        public Bundle receiverExtras;
        public final int userHandle;
        public boolean haveResult = false;
        public Bundle result = null;
        public AssistStructure structure = null;
        public AssistContent content = null;

        public PendingAssistExtras(ActivityRecord _activity, Bundle _extras, Intent _intent, String _hint, IAssistDataReceiver _receiver, Bundle _receiverExtras, int _userHandle) {
            this.activity = _activity;
            this.extras = _extras;
            this.intent = _intent;
            this.hint = _hint;
            this.receiver = _receiver;
            this.receiverExtras = _receiverExtras;
            this.userHandle = _userHandle;
        }

        @Override // java.lang.Runnable
        public void run() {
            Slog.w("ActivityManager", "getAssistContextExtras failed: timeout retrieving from " + this.activity);
            synchronized (this) {
                this.haveResult = true;
                notifyAll();
            }
            ActivityManagerService.this.pendingAssistExtrasTimedOut(this);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public abstract class ImportanceToken implements IBinder.DeathRecipient {
        final int pid;
        final String reason;
        final IBinder token;

        ImportanceToken(int _pid, IBinder _token, String _reason) {
            this.pid = _pid;
            this.token = _token;
            this.reason = _reason;
        }

        public String toString() {
            return "ImportanceToken { " + Integer.toHexString(System.identityHashCode(this)) + " " + this.reason + " " + this.pid + " " + this.token + " }";
        }

        void writeToProto(ProtoOutputStream proto, long fieldId) {
            long pToken = proto.start(fieldId);
            proto.write(1120986464257L, this.pid);
            if (this.token != null) {
                proto.write(1138166333442L, this.token.toString());
            }
            proto.write(1138166333443L, this.reason);
            proto.end(pToken);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public static final class Association {
        int mCount;
        long mLastStateUptime;
        int mNesting;
        final String mSourceProcess;
        final int mSourceUid;
        long mStartTime;
        final ComponentName mTargetComponent;
        final String mTargetProcess;
        final int mTargetUid;
        long mTime;
        int mLastState = 20;
        long[] mStateTimes = new long[20];

        Association(int sourceUid, String sourceProcess, int targetUid, ComponentName targetComponent, String targetProcess) {
            this.mSourceUid = sourceUid;
            this.mSourceProcess = sourceProcess;
            this.mTargetUid = targetUid;
            this.mTargetComponent = targetComponent;
            this.mTargetProcess = targetProcess;
        }
    }

    /* loaded from: classes.dex */
    public static class GrantUri {
        public boolean prefix;
        public final int sourceUserId;
        public final Uri uri;

        public GrantUri(int sourceUserId, Uri uri, boolean prefix) {
            this.sourceUserId = sourceUserId;
            this.uri = uri;
            this.prefix = prefix;
        }

        public int hashCode() {
            int hashCode = (31 * 1) + this.sourceUserId;
            return (31 * ((31 * hashCode) + this.uri.hashCode())) + (this.prefix ? 1231 : 1237);
        }

        public boolean equals(Object o) {
            if (o instanceof GrantUri) {
                GrantUri other = (GrantUri) o;
                return this.uri.equals(other.uri) && this.sourceUserId == other.sourceUserId && this.prefix == other.prefix;
            }
            return false;
        }

        public String toString() {
            String result = this.uri.toString() + " [user " + this.sourceUserId + "]";
            if (this.prefix) {
                return result + " [prefix]";
            }
            return result;
        }

        public String toSafeString() {
            String result = this.uri.toSafeString() + " [user " + this.sourceUserId + "]";
            if (this.prefix) {
                return result + " [prefix]";
            }
            return result;
        }

        public void writeToProto(ProtoOutputStream proto, long fieldId) {
            long token = proto.start(fieldId);
            proto.write(1138166333442L, this.uri.toString());
            proto.write(1120986464257L, this.sourceUserId);
            proto.end(token);
        }

        public static GrantUri resolve(int defaultSourceUserHandle, Uri uri) {
            if ("content".equals(uri.getScheme())) {
                return new GrantUri(ContentProvider.getUserIdFromUri(uri, defaultSourceUserHandle), ContentProvider.getUriWithoutUserId(uri), false);
            }
            return new GrantUri(defaultSourceUserHandle, uri, false);
        }
    }

    /* loaded from: classes.dex */
    private final class FontScaleSettingObserver extends ContentObserver {
        private final Uri mFontScaleUri;
        private final Uri mHideErrorDialogsUri;

        public FontScaleSettingObserver() {
            super(ActivityManagerService.this.mHandler);
            this.mFontScaleUri = Settings.System.getUriFor("font_scale");
            this.mHideErrorDialogsUri = Settings.Global.getUriFor("hide_error_dialogs");
            ContentResolver resolver = ActivityManagerService.this.mContext.getContentResolver();
            resolver.registerContentObserver(this.mFontScaleUri, false, this, -1);
            resolver.registerContentObserver(this.mHideErrorDialogsUri, false, this, -1);
        }

        @Override // android.database.ContentObserver
        public void onChange(boolean selfChange, Uri uri, int userId) {
            if (this.mFontScaleUri.equals(uri)) {
                ActivityManagerService.this.updateFontScaleIfNeeded(userId);
            } else if (this.mHideErrorDialogsUri.equals(uri)) {
                synchronized (ActivityManagerService.this) {
                    try {
                        ActivityManagerService.boostPriorityForLockedSection();
                        ActivityManagerService.this.updateShouldShowDialogsLocked(ActivityManagerService.this.getGlobalConfiguration());
                    } catch (Throwable th) {
                        ActivityManagerService.resetPriorityAfterLockedSection();
                        throw th;
                    }
                }
                ActivityManagerService.resetPriorityAfterLockedSection();
            }
        }
    }

    /* loaded from: classes.dex */
    private final class DevelopmentSettingsObserver extends ContentObserver {
        private final ComponentName mBugreportStorageProvider;
        private final Uri mUri;

        public DevelopmentSettingsObserver() {
            super(ActivityManagerService.this.mHandler);
            this.mUri = Settings.Global.getUriFor("development_settings_enabled");
            this.mBugreportStorageProvider = new ComponentName("com.android.shell", "com.android.shell.BugreportStorageProvider");
            ActivityManagerService.this.mContext.getContentResolver().registerContentObserver(this.mUri, false, this, -1);
            onChange();
        }

        @Override // android.database.ContentObserver
        public void onChange(boolean selfChange, Uri uri, int userId) {
            if (this.mUri.equals(uri)) {
                onChange();
            }
        }

        public void onChange() {
            boolean enabled = Settings.Global.getInt(ActivityManagerService.this.mContext.getContentResolver(), "development_settings_enabled", Build.IS_ENG ? 1 : 0) != 0;
            ActivityManagerService.this.mContext.getPackageManager().setComponentEnabledSetting(this.mBugreportStorageProvider, enabled ? 1 : 0, 0);
        }
    }

    /* loaded from: classes.dex */
    private class Identity {
        public final int pid;
        public final IBinder token;
        public final int uid;

        Identity(IBinder _token, int _pid, int _uid) {
            this.token = _token;
            this.pid = _pid;
            this.uid = _uid;
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public static final class PendingTempWhitelist {
        final long duration;
        final String tag;
        final int targetUid;

        PendingTempWhitelist(int _targetUid, long _duration, String _tag) {
            this.targetUid = _targetUid;
            this.duration = _duration;
            this.tag = _tag;
        }

        void writeToProto(ProtoOutputStream proto, long fieldId) {
            long token = proto.start(fieldId);
            proto.write(1120986464257L, this.targetUid);
            proto.write(1112396529666L, this.duration);
            proto.write(1138166333443L, this.tag);
            proto.end(token);
        }
    }

    /* JADX INFO: Access modifiers changed from: private */
    /* loaded from: classes.dex */
    public static final class UpdateConfigurationResult {
        boolean activityRelaunched;
        int changes;

        private UpdateConfigurationResult() {
        }

        void reset() {
            this.changes = 0;
            this.activityRelaunched = false;
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public static final class ProcessChangeItem {
        static final int CHANGE_ACTIVITIES = 1;
        int changes;
        boolean foregroundActivities;
        int pid;
        int processState;
        int uid;

        ProcessChangeItem() {
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public static final class UidObserverRegistration {
        private static int[] ORIG_ENUMS = {4, 8, 2, 1};
        private static int[] PROTO_ENUMS = {3, 4, 2, 1};
        final int cutpoint;
        final SparseIntArray lastProcStates;
        int mMaxDispatchTime;
        int mSlowDispatchCount;
        final String pkg;
        final int uid;
        final int which;

        UidObserverRegistration(int _uid, String _pkg, int _which, int _cutpoint) {
            this.uid = _uid;
            this.pkg = _pkg;
            this.which = _which;
            this.cutpoint = _cutpoint;
            if (this.cutpoint >= 0) {
                this.lastProcStates = new SparseIntArray();
            } else {
                this.lastProcStates = null;
            }
        }

        void writeToProto(ProtoOutputStream proto, long fieldId) {
            long token = proto.start(fieldId);
            proto.write(1120986464257L, this.uid);
            proto.write(1138166333442L, this.pkg);
            ProtoUtils.writeBitWiseFlagsToProtoEnum(proto, 2259152797699L, this.which, ORIG_ENUMS, PROTO_ENUMS);
            proto.write(1120986464260L, this.cutpoint);
            if (this.lastProcStates != null) {
                int NI = this.lastProcStates.size();
                for (int i = 0; i < NI; i++) {
                    long pToken = proto.start(2246267895813L);
                    proto.write(1120986464257L, this.lastProcStates.keyAt(i));
                    proto.write(1120986464258L, this.lastProcStates.valueAt(i));
                    proto.end(pToken);
                }
            }
            proto.end(token);
        }
    }

    /* JADX INFO: Access modifiers changed from: private */
    /* loaded from: classes.dex */
    public final class AppDeathRecipient implements IBinder.DeathRecipient {
        final ProcessRecord mApp;
        final IApplicationThread mAppThread;
        final int mPid;

        AppDeathRecipient(ProcessRecord app, int pid, IApplicationThread thread) {
            if (ActivityManagerDebugConfig.DEBUG_ALL) {
                Slog.v("ActivityManager", "New death recipient " + this + " for thread " + thread.asBinder());
            }
            this.mApp = app;
            this.mPid = pid;
            this.mAppThread = thread;
        }

        @Override // android.os.IBinder.DeathRecipient
        public void binderDied() {
            if (ActivityManagerDebugConfig.DEBUG_ALL) {
                Slog.v("ActivityManager", "Death received in " + this + " for thread " + this.mAppThread.asBinder());
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.appDiedLocked(this.mApp, this.mPid, this.mAppThread, true);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public Configuration getGlobalConfiguration() {
        return this.mStackSupervisor.getConfiguration();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public final class KillHandler extends Handler {
        static final int KILL_PROCESS_GROUP_MSG = 4000;

        public KillHandler(Looper looper) {
            super(looper, null, true);
        }

        @Override // android.os.Handler
        public void handleMessage(Message msg) {
            if (msg.what == KILL_PROCESS_GROUP_MSG) {
                Trace.traceBegin(64L, "killProcessGroup");
                Process.killProcessGroup(msg.arg1, msg.arg2);
                Trace.traceEnd(64L);
                return;
            }
            super.handleMessage(msg);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public final class UiHandler extends Handler {
        public UiHandler() {
            super(UiThread.get().getLooper(), null, true);
        }

        @Override // android.os.Handler
        public void handleMessage(Message msg) {
            int i = msg.what;
            if (i == 6) {
                synchronized (ActivityManagerService.this) {
                    try {
                        ActivityManagerService.boostPriorityForLockedSection();
                        ProcessRecord app = (ProcessRecord) msg.obj;
                        if (msg.arg1 != 0) {
                            if (!app.waitedForDebugger) {
                                Dialog d = new AppWaitingForDebuggerDialog(ActivityManagerService.this, ActivityManagerService.this.mUiContext, app);
                                app.waitDialog = d;
                                app.waitedForDebugger = true;
                                d.show();
                            }
                        } else if (app.waitDialog != null) {
                            app.waitDialog.dismiss();
                            app.waitDialog = null;
                        }
                    } finally {
                        ActivityManagerService.resetPriorityAfterLockedSection();
                    }
                }
                ActivityManagerService.resetPriorityAfterLockedSection();
            } else if (i == 26) {
                HashMap<String, Object> data = (HashMap) msg.obj;
                synchronized (ActivityManagerService.this) {
                    try {
                        ActivityManagerService.boostPriorityForLockedSection();
                        ProcessRecord proc = (ProcessRecord) data.get("app");
                        if (proc == null) {
                            Slog.e("ActivityManager", "App not found when showing strict mode dialog.");
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        } else if (proc.crashDialog != null) {
                            Slog.e("ActivityManager", "App already has strict mode dialog: " + proc);
                        } else {
                            AppErrorResult res = (AppErrorResult) data.get("result");
                            if (ActivityManagerService.this.mShowDialogs && !ActivityManagerService.this.mSleeping && !ActivityManagerService.this.mShuttingDown) {
                                Dialog d2 = new StrictModeViolationDialog(ActivityManagerService.this.mUiContext, ActivityManagerService.this, res, proc);
                                d2.show();
                                proc.crashDialog = d2;
                            } else {
                                res.set(0);
                            }
                            ActivityManagerService.resetPriorityAfterLockedSection();
                            ActivityManagerService.this.ensureBootCompleted();
                        }
                    } finally {
                        ActivityManagerService.resetPriorityAfterLockedSection();
                    }
                }
            } else if (i == 48) {
                ((Dialog) msg.obj).dismiss();
            } else if (i == 53) {
                ActivityManagerService.this.dispatchUidsChanged();
            } else if (i == 68) {
                ActivityManagerService.this.pushTempWhitelist();
            } else if (i != 70) {
                switch (i) {
                    case 1:
                        ActivityManagerService.this.mAppErrors.handleShowAppErrorUi(msg);
                        ActivityManagerService.this.ensureBootCompleted();
                        return;
                    case 2:
                        ActivityManagerService.this.mAppErrors.handleShowAnrUi(msg);
                        ActivityManagerService.this.ensureBootCompleted();
                        return;
                    case 3:
                        new FactoryErrorDialog(ActivityManagerService.this.mUiContext, msg.getData().getCharSequence("msg")).show();
                        ActivityManagerService.this.ensureBootCompleted();
                        return;
                    default:
                        switch (i) {
                            case 14:
                                if (ActivityManagerService.this.mShowDialogs) {
                                    AlertDialog d3 = new BaseErrorDialog(ActivityManagerService.this.mUiContext);
                                    d3.getWindow().setType(2010);
                                    d3.setCancelable(false);
                                    d3.setTitle(ActivityManagerService.this.mUiContext.getText(17039473));
                                    d3.setMessage(ActivityManagerService.this.mUiContext.getText(17040974));
                                    d3.setButton(-1, ActivityManagerService.this.mUiContext.getText(17039370), obtainMessage(48, d3));
                                    d3.show();
                                    return;
                                }
                                return;
                            case 15:
                                if (ActivityManagerService.this.mShowDialogs) {
                                    AlertDialog d4 = new BaseErrorDialog(ActivityManagerService.this.mUiContext);
                                    d4.getWindow().setType(2010);
                                    d4.setCancelable(false);
                                    d4.setTitle(ActivityManagerService.this.mUiContext.getText(17039473));
                                    d4.setMessage(ActivityManagerService.this.mUiContext.getText(17040973));
                                    d4.setButton(-1, ActivityManagerService.this.mUiContext.getText(17039370), obtainMessage(48, d4));
                                    d4.show();
                                    return;
                                }
                                return;
                            default:
                                switch (i) {
                                    case 30:
                                        synchronized (ActivityManagerService.this) {
                                            try {
                                                ActivityManagerService.boostPriorityForLockedSection();
                                                ActivityRecord ar = (ActivityRecord) msg.obj;
                                                if (ActivityManagerService.this.mCompatModeDialog != null) {
                                                    if (ActivityManagerService.this.mCompatModeDialog.mAppInfo.packageName.equals(ar.info.applicationInfo.packageName)) {
                                                        return;
                                                    }
                                                    ActivityManagerService.this.mCompatModeDialog.dismiss();
                                                    ActivityManagerService.this.mCompatModeDialog = null;
                                                }
                                                ActivityManagerService.resetPriorityAfterLockedSection();
                                                return;
                                            } finally {
                                                ActivityManagerService.resetPriorityAfterLockedSection();
                                            }
                                        }
                                    case 31:
                                        ActivityManagerService.this.dispatchProcessesChanged();
                                        return;
                                    case 32:
                                        int pid = msg.arg1;
                                        int uid = msg.arg2;
                                        ActivityManagerService.this.dispatchProcessDied(pid, uid);
                                        return;
                                    default:
                                        return;
                                }
                        }
                }
            } else {
                ActivityManagerService.this.dispatchOomAdjObserver((String) msg.obj);
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public final class MainHandler extends Handler {
        public MainHandler(Looper looper) {
            super(looper, null, true);
        }

        /*  JADX ERROR: JadxRuntimeException in pass: BlockProcessor
            jadx.core.utils.exceptions.JadxRuntimeException: Unreachable block: B:184:0x04ca
            	at jadx.core.dex.visitors.blocks.BlockProcessor.checkForUnreachableBlocks(BlockProcessor.java:81)
            	at jadx.core.dex.visitors.blocks.BlockProcessor.processBlocksTree(BlockProcessor.java:47)
            	at jadx.core.dex.visitors.blocks.BlockProcessor.visit(BlockProcessor.java:39)
            */
        @Override // android.os.Handler
        public void handleMessage(android.os.Message r26) {
            /*
                Method dump skipped, instructions count: 2460
                To view this dump add '--comments-level debug' option
            */
            throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.MainHandler.handleMessage(android.os.Message):void");
        }
    }

    /* renamed from: com.android.server.am.ActivityManagerService$3  reason: invalid class name */
    /* loaded from: classes.dex */
    class AnonymousClass3 extends Handler {
        AnonymousClass3(Looper x0) {
            super(x0);
        }

        @Override // android.os.Handler
        public void handleMessage(Message msg) {
            int i;
            ProcessRecord proc;
            int procState;
            int statType;
            long lastPssTime;
            int pid;
            boolean z;
            List<ProcessCpuTracker.Stats> stats;
            if (msg.what != 1) {
                return;
            }
            long start = SystemClock.uptimeMillis();
            MemInfoReader memInfo = null;
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    i = 0;
                    if (ActivityManagerService.this.mFullPssPending) {
                        ActivityManagerService.this.mFullPssPending = false;
                        MemInfoReader memInfo2 = new MemInfoReader();
                        memInfo = memInfo2;
                    }
                } finally {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
            if (memInfo != null) {
                ActivityManagerService.this.updateCpuStatsNow();
                synchronized (ActivityManagerService.this.mProcessCpuTracker) {
                    stats = ActivityManagerService.this.mProcessCpuTracker.getStats(new ProcessCpuTracker.FilterStats() { // from class: com.android.server.am.-$$Lambda$ActivityManagerService$3$poTyYzHinA8s8lAJ-y6Bb3JsBNo
                        public final boolean needed(ProcessCpuTracker.Stats stats2) {
                            return ActivityManagerService.AnonymousClass3.lambda$handleMessage$0(stats2);
                        }
                    });
                }
                int N = stats.size();
                long nativeTotalPss = 0;
                for (int j = 0; j < N; j++) {
                    synchronized (ActivityManagerService.this.mPidsSelfLocked) {
                        if (ActivityManagerService.this.mPidsSelfLocked.indexOfKey(stats.get(j).pid) < 0) {
                            nativeTotalPss += Debug.getPss(stats.get(j).pid, null, null);
                        }
                    }
                }
                memInfo.readMemInfo();
                synchronized (ActivityManagerService.this) {
                    try {
                        ActivityManagerService.boostPriorityForLockedSection();
                        if (ActivityManagerDebugConfig.DEBUG_PSS) {
                            Slog.d("ActivityManager", "Collected native and kernel memory in " + (SystemClock.uptimeMillis() - start) + "ms");
                        }
                        long cachedKb = memInfo.getCachedSizeKb();
                        long freeKb = memInfo.getFreeSizeKb();
                        long zramKb = memInfo.getZramTotalSizeKb();
                        long kernelKb = memInfo.getKernelUsedSizeKb();
                        EventLogTags.writeAmMeminfo(cachedKb * 1024, freeKb * 1024, zramKb * 1024, kernelKb * 1024, nativeTotalPss * 1024);
                        ActivityManagerService.this.mProcessStats.addSysMemUsageLocked(cachedKb, freeKb, zramKb, kernelKb, nativeTotalPss);
                    } finally {
                    }
                }
                ActivityManagerService.resetPriorityAfterLockedSection();
            }
            long[] tmp = new long[3];
            int num = 0;
            while (true) {
                synchronized (ActivityManagerService.this) {
                    try {
                        ActivityManagerService.boostPriorityForLockedSection();
                        if (ActivityManagerService.this.mPendingPssProcesses.size() <= 0) {
                            break;
                        }
                        proc = ActivityManagerService.this.mPendingPssProcesses.remove(i);
                        procState = proc.pssProcState;
                        statType = proc.pssStatType;
                        lastPssTime = proc.lastPssTime;
                        long now = SystemClock.uptimeMillis();
                        if (proc.thread == null || procState != proc.setProcState || lastPssTime + 1000 >= now) {
                            ProcessList.abortNextPssTime(proc.procStateMemTracker);
                            if (ActivityManagerDebugConfig.DEBUG_PSS) {
                                StringBuilder sb = new StringBuilder();
                                sb.append("Skipped pss collection of ");
                                sb.append(0);
                                sb.append(": still need ");
                                pid = 0;
                                sb.append((lastPssTime + 1000) - now);
                                sb.append("ms until safe");
                                Slog.d("ActivityManager", sb.toString());
                            } else {
                                pid = 0;
                            }
                            proc = null;
                        } else {
                            int pid2 = proc.pid;
                            pid = pid2;
                        }
                    } finally {
                        ActivityManagerService.resetPriorityAfterLockedSection();
                    }
                }
                ActivityManagerService.resetPriorityAfterLockedSection();
                ProcessRecord proc2 = proc;
                int pid3 = pid;
                if (proc2 != null) {
                    long startTime = SystemClock.currentThreadTimeMillis();
                    long pss = Debug.getPss(pid3, tmp, null);
                    long endTime = SystemClock.currentThreadTimeMillis();
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            if (pss != 0 && proc2.thread != null && proc2.setProcState == procState && proc2.pid == pid3 && proc2.lastPssTime == lastPssTime) {
                                num++;
                                ProcessList.commitNextPssTime(proc2.procStateMemTracker);
                                z = true;
                                ActivityManagerService.this.recordPssSampleLocked(proc2, procState, pss, tmp[0], tmp[1], tmp[2], statType, endTime - startTime, SystemClock.uptimeMillis());
                            } else {
                                z = true;
                                ProcessList.abortNextPssTime(proc2.procStateMemTracker);
                                if (ActivityManagerDebugConfig.DEBUG_PSS) {
                                    StringBuilder sb2 = new StringBuilder();
                                    sb2.append("Skipped pss collection of ");
                                    sb2.append(pid3);
                                    sb2.append(": ");
                                    sb2.append(proc2.thread == null ? "NO_THREAD " : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
                                    sb2.append(proc2.pid != pid3 ? "PID_CHANGED " : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
                                    sb2.append(" initState=");
                                    sb2.append(procState);
                                    sb2.append(" curState=");
                                    sb2.append(proc2.setProcState);
                                    sb2.append(" ");
                                    sb2.append(proc2.lastPssTime != lastPssTime ? "TIME_CHANGED" : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
                                    Slog.d("ActivityManager", sb2.toString());
                                }
                            }
                        } finally {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                } else {
                    z = true;
                }
                i = 0;
            }
            if (ActivityManagerService.this.mTestPssMode || ActivityManagerDebugConfig.DEBUG_PSS) {
                Slog.d("ActivityManager", "Collected pss of " + num + " processes in " + (SystemClock.uptimeMillis() - start) + "ms");
            }
            ActivityManagerService.this.mPendingPssProcesses.clear();
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        /* JADX INFO: Access modifiers changed from: package-private */
        public static /* synthetic */ boolean lambda$handleMessage$0(ProcessCpuTracker.Stats st) {
            return st != null && st.vsize > 0 && st.uid < 10000;
        }
    }

    /* JADX WARN: Multi-variable type inference failed */
    public void setSystemProcess() {
        try {
            ServiceManager.addService("activity", this, true, 21);
            ServiceManager.addService("procstats", this.mProcessStats);
            ServiceManager.addService("meminfo", new MemBinder(this), false, 2);
            ServiceManager.addService("gfxinfo", new GraphicsBinder(this));
            ServiceManager.addService("dbinfo", new DbBinder(this));
            ServiceManager.addService("cpuinfo", new CpuBinder(this), false, 1);
            ServiceManager.addService("permission", new PermissionController(this));
            ServiceManager.addService("processinfo", new ProcessInfoService(this));
            ApplicationInfo info = this.mContext.getPackageManager().getApplicationInfo(PackageManagerService.PLATFORM_PACKAGE_NAME, 1049600);
            this.mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());
            synchronized (this) {
                boostPriorityForLockedSection();
                ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);
                app.persistent = true;
                app.pid = MY_PID;
                app.maxAdj = -900;
                app.makeActive(this.mSystemThread.getApplicationThread(), this.mProcessStats);
                synchronized (this.mPidsSelfLocked) {
                    this.mPidsSelfLocked.put(app.pid, app);
                }
                updateLruProcessLocked(app, false, null);
                updateOomAdjLocked();
            }
            resetPriorityAfterLockedSection();
            this.mAppOpsService.startWatchingMode(HANDLE_TRUST_STORAGE_UPDATE_MSG, null, new IAppOpsCallback.Stub() { // from class: com.android.server.am.ActivityManagerService.4
                public void opChanged(int op, int uid, String packageName) {
                    if (op == ActivityManagerService.HANDLE_TRUST_STORAGE_UPDATE_MSG && packageName != null && ActivityManagerService.this.mAppOpsService.checkOperation(op, uid, packageName) != 0) {
                        ActivityManagerService.this.runInBackgroundDisabled(uid);
                    }
                }
            });
        } catch (PackageManager.NameNotFoundException e) {
            throw new RuntimeException("Unable to find android system package", e);
        }
    }

    public void setWindowManager(WindowManagerService wm) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mWindowManager = wm;
                this.mStackSupervisor.setWindowManager(wm);
                this.mLockTaskController.setWindowManager(wm);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void setUsageStatsManager(UsageStatsManagerInternal usageStatsManager) {
        this.mUsageStatsService = usageStatsManager;
    }

    public void startObservingNativeCrashes() {
        NativeCrashListener ncl = new NativeCrashListener(this);
        ncl.start();
    }

    public IAppOpsService getAppOpsService() {
        return this.mAppOpsService;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public static class MemBinder extends Binder {
        ActivityManagerService mActivityManagerService;
        private final PriorityDump.PriorityDumper mPriorityDumper = new PriorityDump.PriorityDumper() { // from class: com.android.server.am.ActivityManagerService.MemBinder.1
            @Override // com.android.server.utils.PriorityDump.PriorityDumper
            public void dumpHigh(FileDescriptor fd, PrintWriter pw, String[] args, boolean asProto) {
                dump(fd, pw, new String[]{"-a"}, asProto);
            }

            @Override // com.android.server.utils.PriorityDump.PriorityDumper
            public void dump(FileDescriptor fd, PrintWriter pw, String[] args, boolean asProto) {
                MemBinder.this.mActivityManagerService.dumpApplicationMemoryUsage(fd, pw, "  ", args, false, null, asProto);
            }
        };

        MemBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        @Override // android.os.Binder
        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (!DumpUtils.checkDumpAndUsageStatsPermission(this.mActivityManagerService.mContext, "meminfo", pw)) {
                return;
            }
            PriorityDump.dump(this.mPriorityDumper, fd, pw, args);
        }
    }

    /* loaded from: classes.dex */
    static class GraphicsBinder extends Binder {
        ActivityManagerService mActivityManagerService;

        GraphicsBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        @Override // android.os.Binder
        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (!DumpUtils.checkDumpAndUsageStatsPermission(this.mActivityManagerService.mContext, "gfxinfo", pw)) {
                return;
            }
            this.mActivityManagerService.dumpGraphicsHardwareUsage(fd, pw, args);
        }
    }

    /* loaded from: classes.dex */
    static class DbBinder extends Binder {
        ActivityManagerService mActivityManagerService;

        DbBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        @Override // android.os.Binder
        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            if (!DumpUtils.checkDumpAndUsageStatsPermission(this.mActivityManagerService.mContext, "dbinfo", pw)) {
                return;
            }
            this.mActivityManagerService.dumpDbInfo(fd, pw, args);
        }
    }

    /* loaded from: classes.dex */
    static class CpuBinder extends Binder {
        ActivityManagerService mActivityManagerService;
        private final PriorityDump.PriorityDumper mPriorityDumper = new PriorityDump.PriorityDumper() { // from class: com.android.server.am.ActivityManagerService.CpuBinder.1
            @Override // com.android.server.utils.PriorityDump.PriorityDumper
            public void dumpCritical(FileDescriptor fd, PrintWriter pw, String[] args, boolean asProto) {
                if (asProto || !DumpUtils.checkDumpAndUsageStatsPermission(CpuBinder.this.mActivityManagerService.mContext, "cpuinfo", pw)) {
                    return;
                }
                synchronized (CpuBinder.this.mActivityManagerService.mProcessCpuTracker) {
                    pw.print(CpuBinder.this.mActivityManagerService.mProcessCpuTracker.printCurrentLoad());
                    pw.print(CpuBinder.this.mActivityManagerService.mProcessCpuTracker.printCurrentState(SystemClock.uptimeMillis()));
                }
            }
        };

        CpuBinder(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        @Override // android.os.Binder
        protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
            PriorityDump.dump(this.mPriorityDumper, fd, pw, args);
        }
    }

    /* loaded from: classes.dex */
    public static final class Lifecycle extends SystemService {
        private final ActivityManagerService mService;

        public Lifecycle(Context context) {
            super(context);
            BootEvent.setEnabled(true);
            this.mService = new ActivityManagerService(context);
        }

        @Override // com.android.server.SystemService
        public void onStart() {
            this.mService.start();
        }

        @Override // com.android.server.SystemService
        public void onBootPhase(int phase) {
            this.mService.mBootPhase = phase;
            if (phase == 500) {
                this.mService.mBatteryStatsService.systemServicesReady();
                this.mService.mServices.systemServicesReady();
            }
        }

        @Override // com.android.server.SystemService
        public void onCleanupUser(int userId) {
            this.mService.mBatteryStatsService.onCleanupUser(userId);
        }

        public ActivityManagerService getService() {
            return this.mService;
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public static class HiddenApiSettings extends ContentObserver {
        private boolean mBlacklistDisabled;
        private final Context mContext;
        private List<String> mExemptions;
        private String mExemptionsStr;
        private int mLogSampleRate;
        private int mPolicyP;
        private int mPolicyPreP;

        public HiddenApiSettings(Handler handler, Context context) {
            super(handler);
            this.mExemptions = Collections.emptyList();
            this.mLogSampleRate = -1;
            this.mPolicyPreP = -1;
            this.mPolicyP = -1;
            this.mContext = context;
        }

        public void registerObserver() {
            this.mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor("hidden_api_blacklist_exemptions"), false, this);
            this.mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor("hidden_api_access_log_sampling_rate"), false, this);
            this.mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor("hidden_api_policy_pre_p_apps"), false, this);
            this.mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor("hidden_api_policy_p_apps"), false, this);
            update();
        }

        private void update() {
            List<String> asList;
            String exemptions = Settings.Global.getString(this.mContext.getContentResolver(), "hidden_api_blacklist_exemptions");
            if (!TextUtils.equals(exemptions, this.mExemptionsStr)) {
                this.mExemptionsStr = exemptions;
                if ("*".equals(exemptions)) {
                    this.mBlacklistDisabled = true;
                    this.mExemptions = Collections.emptyList();
                } else {
                    this.mBlacklistDisabled = false;
                    if (TextUtils.isEmpty(exemptions)) {
                        asList = Collections.emptyList();
                    } else {
                        asList = Arrays.asList(exemptions.split(","));
                    }
                    this.mExemptions = asList;
                }
                if (!Process.zygoteProcess.setApiBlacklistExemptions(this.mExemptions)) {
                    Slog.e("ActivityManager", "Failed to set API blacklist exemptions!");
                    this.mExemptions = Collections.emptyList();
                }
            }
            int logSampleRate = Settings.Global.getInt(this.mContext.getContentResolver(), "hidden_api_access_log_sampling_rate", -1);
            logSampleRate = (logSampleRate < 0 || logSampleRate > 65536) ? -1 : -1;
            if (logSampleRate != -1 && logSampleRate != this.mLogSampleRate) {
                this.mLogSampleRate = logSampleRate;
                Process.zygoteProcess.setHiddenApiAccessLogSampleRate(this.mLogSampleRate);
            }
            this.mPolicyPreP = getValidEnforcementPolicy("hidden_api_policy_pre_p_apps");
            this.mPolicyP = getValidEnforcementPolicy("hidden_api_policy_p_apps");
        }

        private int getValidEnforcementPolicy(String settingsKey) {
            int policy = Settings.Global.getInt(this.mContext.getContentResolver(), settingsKey, -1);
            if (ApplicationInfo.isValidHiddenApiEnforcementPolicy(policy)) {
                return policy;
            }
            return -1;
        }

        boolean isDisabled() {
            return this.mBlacklistDisabled;
        }

        int getPolicyForPrePApps() {
            return this.mPolicyPreP;
        }

        int getPolicyForPApps() {
            return this.mPolicyP;
        }

        @Override // android.database.ContentObserver
        public void onChange(boolean selfChange) {
            update();
        }
    }

    @VisibleForTesting
    public ActivityManagerService(Injector injector) {
        this.mInstrumentationReporter = new InstrumentationReporter();
        this.mActiveInstrumentation = new ArrayList<>();
        this.mShowDialogs = true;
        this.mVr2dDisplayId = -1;
        this.mUseFifoUiScheduling = false;
        this.mBroadcastQueues = new BroadcastQueue[2];
        this.mAllowAppSwitchUids = new SparseArray<>();
        this.mPriorityDumper = new PriorityDump.PriorityDumper() { // from class: com.android.server.am.ActivityManagerService.1
            @Override // com.android.server.utils.PriorityDump.PriorityDumper
            public void dumpCritical(FileDescriptor fd, PrintWriter pw, String[] args, boolean asProto) {
                if (asProto) {
                    return;
                }
                ActivityManagerService.this.doDump(fd, pw, new String[]{"activities"}, asProto);
                ActivityManagerService.this.doDump(fd, pw, new String[]{"service", ActivityManagerService.SYSUI_COMPONENT_NAME}, asProto);
            }

            @Override // com.android.server.utils.PriorityDump.PriorityDumper
            public void dumpNormal(FileDescriptor fd, PrintWriter pw, String[] args, boolean asProto) {
                ActivityManagerService.this.doDump(fd, pw, new String[]{"-a", "--normal-priority"}, asProto);
            }

            @Override // com.android.server.utils.PriorityDump.PriorityDumper
            public void dump(FileDescriptor fd, PrintWriter pw, String[] args, boolean asProto) {
                ActivityManagerService.this.doDump(fd, pw, args, asProto);
            }
        };
        this.mPendingAssistExtras = new ArrayList<>();
        this.mProcessList = new ProcessList();
        this.mProcessNames = new ProcessMap<>();
        this.mIsolatedProcesses = new SparseArray<>();
        this.mNextIsolatedProcessUid = 0;
        this.mHeavyWeightProcess = null;
        this.mBackgroundAppIdWhitelist = new int[]{1002};
        this.mPidsSelfLocked = new SparseArray<>();
        this.mImportantProcesses = new SparseArray<>();
        this.mProcessesOnHold = new ArrayList<>();
        this.mPersistentStartingProcesses = new ArrayList<>();
        this.mRemovedProcesses = new ArrayList<>();
        this.mLruProcesses = new ArrayList<>();
        this.mLruProcessActivityStart = 0;
        this.mLruProcessServiceStart = 0;
        this.mProcessesToGc = new ArrayList<>();
        this.mPendingPssProcesses = new ArrayList<>();
        this.mBinderTransactionTrackingEnabled = false;
        this.mLastFullPssTime = SystemClock.uptimeMillis();
        this.mFullPssPending = false;
        this.mActiveUids = new SparseArray<>();
        this.mValidateUids = new SparseArray<>();
        this.mIntentSenderRecords = new HashMap<>();
        this.mAlreadyLoggedViolatedStacks = new HashSet<>();
        this.mRegisteredReceivers = new HashMap<>();
        this.mReceiverResolver = new IntentResolver<BroadcastFilter, BroadcastFilter>() { // from class: com.android.server.am.ActivityManagerService.2
            /* JADX INFO: Access modifiers changed from: protected */
            @Override // com.android.server.IntentResolver
            public boolean allowFilterResult(BroadcastFilter filter, List<BroadcastFilter> dest) {
                IBinder target = filter.receiverList.receiver.asBinder();
                for (int i = dest.size() - 1; i >= 0; i--) {
                    if (dest.get(i).receiverList.receiver.asBinder() == target) {
                        return false;
                    }
                }
                return true;
            }

            /* JADX INFO: Access modifiers changed from: protected */
            @Override // com.android.server.IntentResolver
            public BroadcastFilter newResult(BroadcastFilter filter, int match, int userId) {
                if (userId == -1 || filter.owningUserId == -1 || userId == filter.owningUserId) {
                    return (BroadcastFilter) super.newResult((AnonymousClass2) filter, match, userId);
                }
                return null;
            }

            /* JADX INFO: Access modifiers changed from: protected */
            @Override // com.android.server.IntentResolver
            public BroadcastFilter[] newArray(int size) {
                return new BroadcastFilter[size];
            }

            /* JADX INFO: Access modifiers changed from: protected */
            @Override // com.android.server.IntentResolver
            public boolean isPackageForFilter(String packageName, BroadcastFilter filter) {
                return packageName.equals(filter.packageName);
            }
        };
        this.mStickyBroadcasts = new SparseArray<>();
        this.mAssociations = new SparseArray<>();
        this.mBackupAppName = null;
        this.mBackupTarget = null;
        this.mLaunchingProviders = new ArrayList<>();
        this.mGrantedUriPermissions = new SparseArray<>();
        this.mDeviceIdleWhitelist = new int[0];
        this.mDeviceIdleExceptIdleWhitelist = new int[0];
        this.mDeviceIdleTempWhitelist = new int[0];
        this.mPendingTempWhitelist = new SparseArray<>();
        this.mTempConfig = new Configuration();
        this.mTmpUpdateConfigurationResult = new UpdateConfigurationResult();
        this.mStringBuilder = new StringBuilder(256);
        this.mTopAction = "android.intent.action.MAIN";
        this.mProcessesReady = false;
        this.mSystemReady = false;
        this.mOnBattery = false;
        this.mBooting = false;
        this.mCallFinishBooting = false;
        this.mBootAnimationComplete = false;
        this.mLaunchWarningShown = false;
        this.mCheckedForSetup = false;
        this.mSleeping = false;
        this.mTopProcessState = 2;
        this.mWakefulness = 1;
        this.mKeyguardShown = false;
        this.mShuttingDown = false;
        this.mAdjSeq = 0;
        this.mLruSeq = 0;
        this.mNumNonCachedProcs = 0;
        this.mNumCachedHiddenProcs = 0;
        this.mNumServiceProcs = 0;
        this.mNewNumAServiceProcs = 0;
        this.mNewNumServiceProcs = 0;
        this.mAllowLowerMemLevel = false;
        this.mLastMemoryLevel = 0;
        this.mLastIdleTime = SystemClock.uptimeMillis();
        this.mLowRamTimeSinceLastIdle = 0L;
        this.mLowRamStartTime = 0L;
        this.mCurResumedPackage = null;
        this.mCurResumedUid = -1;
        this.mForegroundPackages = new ProcessMap<>();
        this.mTestPssMode = false;
        this.mDebugApp = null;
        this.mWaitForDebugger = false;
        this.mDebugTransient = false;
        this.mOrigDebugApp = null;
        this.mOrigWaitForDebugger = false;
        this.mAlwaysFinishActivities = false;
        this.mController = null;
        this.mControllerIsAMonkey = false;
        this.mProfileApp = null;
        this.mProfileProc = null;
        this.mProfilerInfo = null;
        this.mAppAgentMap = null;
        this.mProfileType = 0;
        this.mMemWatchProcesses = new ProcessMap<>();
        this.mTrackAllocationApp = null;
        this.mNativeDebuggingApp = null;
        this.mTmpLong = new long[3];
        this.mTmpBroadcastQueue = new ArraySet<>();
        this.mProcStateSeqCounter = 0L;
        this.mProcStartSeqCounter = 0L;
        this.mPendingStarts = new LongSparseArray<>();
        this.mScreenObservers = new ArrayList();
        this.mProcessObservers = new RemoteCallbackList<>();
        this.mActiveProcessChanges = new ProcessChangeItem[5];
        this.mPendingProcessChanges = new ArrayList<>();
        this.mAvailProcessChanges = new ArrayList<>();
        this.mUidObservers = new RemoteCallbackList<>();
        this.mActiveUidChanges = new UidRecord.ChangeItem[5];
        this.mPendingUidChanges = new ArrayList<>();
        this.mAvailUidChanges = new ArrayList<>();
        this.mProcessCpuTracker = new ProcessCpuTracker(false);
        this.mLastCpuTime = new AtomicLong(0L);
        this.mProcessCpuMutexFree = new AtomicBoolean(true);
        this.mProcessCpuInitLatch = new CountDownLatch(1);
        this.mLastWriteTime = 0L;
        this.mUpdateLock = new UpdateLock("immersive");
        this.mBooted = false;
        this.mPostActivityRecord = null;
        this.mLastActivityRecord = null;
        this.mNotifyRecentActivity = "true".equals(SystemProperties.get("persist.infoflow.recentapp"));
        this.mLastMemUsageReportTime = 0L;
        this.mViSessionId = 1000;
        this.mBgHandler = new AnonymousClass3(BackgroundThread.getHandler().getLooper());
        this.mProcessStateStatsLongs = new long[1];
        this.mSupportedSystemLocales = null;
        this.mInjector = injector;
        this.mContext = this.mInjector.getContext();
        this.mUiContext = null;
        this.GL_ES_VERSION = 0;
        this.mActivityStartController = null;
        this.mAppErrors = null;
        this.mAppWarnings = null;
        this.mAppOpsService = this.mInjector.getAppOpsService(null, null);
        this.mBatteryStatsService = null;
        this.mCompatModePackages = null;
        this.mConstants = null;
        this.mGrantFile = null;
        this.mHandler = null;
        this.mHandlerThread = null;
        this.mIntentFirewall = null;
        this.mKeyguardController = null;
        this.mPermissionReviewRequired = false;
        this.mProcessCpuThread = null;
        this.mProcessStats = null;
        this.mProviderMap = null;
        this.mRecentTasks = null;
        this.mServices = null;
        this.mStackSupervisor = null;
        this.mSystemThread = null;
        this.mTaskChangeNotificationController = null;
        this.mUiHandler = injector.getUiHandler(null);
        this.mUserController = null;
        this.mVrController = null;
        this.mLockTaskController = null;
        this.mLifecycleManager = null;
        this.mProcStartHandlerThread = null;
        this.mProcStartHandler = null;
        this.mHiddenApiBlacklist = null;
    }

    public ActivityManagerService(Context systemContext) {
        this.mInstrumentationReporter = new InstrumentationReporter();
        this.mActiveInstrumentation = new ArrayList<>();
        this.mShowDialogs = true;
        this.mVr2dDisplayId = -1;
        this.mUseFifoUiScheduling = false;
        this.mBroadcastQueues = new BroadcastQueue[2];
        this.mAllowAppSwitchUids = new SparseArray<>();
        this.mPriorityDumper = new PriorityDump.PriorityDumper() { // from class: com.android.server.am.ActivityManagerService.1
            @Override // com.android.server.utils.PriorityDump.PriorityDumper
            public void dumpCritical(FileDescriptor fd, PrintWriter pw, String[] args, boolean asProto) {
                if (asProto) {
                    return;
                }
                ActivityManagerService.this.doDump(fd, pw, new String[]{"activities"}, asProto);
                ActivityManagerService.this.doDump(fd, pw, new String[]{"service", ActivityManagerService.SYSUI_COMPONENT_NAME}, asProto);
            }

            @Override // com.android.server.utils.PriorityDump.PriorityDumper
            public void dumpNormal(FileDescriptor fd, PrintWriter pw, String[] args, boolean asProto) {
                ActivityManagerService.this.doDump(fd, pw, new String[]{"-a", "--normal-priority"}, asProto);
            }

            @Override // com.android.server.utils.PriorityDump.PriorityDumper
            public void dump(FileDescriptor fd, PrintWriter pw, String[] args, boolean asProto) {
                ActivityManagerService.this.doDump(fd, pw, args, asProto);
            }
        };
        this.mPendingAssistExtras = new ArrayList<>();
        this.mProcessList = new ProcessList();
        this.mProcessNames = new ProcessMap<>();
        this.mIsolatedProcesses = new SparseArray<>();
        this.mNextIsolatedProcessUid = 0;
        this.mHeavyWeightProcess = null;
        this.mBackgroundAppIdWhitelist = new int[]{1002};
        this.mPidsSelfLocked = new SparseArray<>();
        this.mImportantProcesses = new SparseArray<>();
        this.mProcessesOnHold = new ArrayList<>();
        this.mPersistentStartingProcesses = new ArrayList<>();
        this.mRemovedProcesses = new ArrayList<>();
        this.mLruProcesses = new ArrayList<>();
        this.mLruProcessActivityStart = 0;
        this.mLruProcessServiceStart = 0;
        this.mProcessesToGc = new ArrayList<>();
        this.mPendingPssProcesses = new ArrayList<>();
        this.mBinderTransactionTrackingEnabled = false;
        this.mLastFullPssTime = SystemClock.uptimeMillis();
        this.mFullPssPending = false;
        this.mActiveUids = new SparseArray<>();
        this.mValidateUids = new SparseArray<>();
        this.mIntentSenderRecords = new HashMap<>();
        this.mAlreadyLoggedViolatedStacks = new HashSet<>();
        this.mRegisteredReceivers = new HashMap<>();
        this.mReceiverResolver = new IntentResolver<BroadcastFilter, BroadcastFilter>() { // from class: com.android.server.am.ActivityManagerService.2
            /* JADX INFO: Access modifiers changed from: protected */
            @Override // com.android.server.IntentResolver
            public boolean allowFilterResult(BroadcastFilter filter, List<BroadcastFilter> dest) {
                IBinder target = filter.receiverList.receiver.asBinder();
                for (int i = dest.size() - 1; i >= 0; i--) {
                    if (dest.get(i).receiverList.receiver.asBinder() == target) {
                        return false;
                    }
                }
                return true;
            }

            /* JADX INFO: Access modifiers changed from: protected */
            @Override // com.android.server.IntentResolver
            public BroadcastFilter newResult(BroadcastFilter filter, int match, int userId) {
                if (userId == -1 || filter.owningUserId == -1 || userId == filter.owningUserId) {
                    return (BroadcastFilter) super.newResult((AnonymousClass2) filter, match, userId);
                }
                return null;
            }

            /* JADX INFO: Access modifiers changed from: protected */
            @Override // com.android.server.IntentResolver
            public BroadcastFilter[] newArray(int size) {
                return new BroadcastFilter[size];
            }

            /* JADX INFO: Access modifiers changed from: protected */
            @Override // com.android.server.IntentResolver
            public boolean isPackageForFilter(String packageName, BroadcastFilter filter) {
                return packageName.equals(filter.packageName);
            }
        };
        this.mStickyBroadcasts = new SparseArray<>();
        this.mAssociations = new SparseArray<>();
        this.mBackupAppName = null;
        this.mBackupTarget = null;
        this.mLaunchingProviders = new ArrayList<>();
        this.mGrantedUriPermissions = new SparseArray<>();
        this.mDeviceIdleWhitelist = new int[0];
        this.mDeviceIdleExceptIdleWhitelist = new int[0];
        this.mDeviceIdleTempWhitelist = new int[0];
        this.mPendingTempWhitelist = new SparseArray<>();
        this.mTempConfig = new Configuration();
        this.mTmpUpdateConfigurationResult = new UpdateConfigurationResult();
        this.mStringBuilder = new StringBuilder(256);
        this.mTopAction = "android.intent.action.MAIN";
        this.mProcessesReady = false;
        this.mSystemReady = false;
        this.mOnBattery = false;
        this.mBooting = false;
        this.mCallFinishBooting = false;
        this.mBootAnimationComplete = false;
        this.mLaunchWarningShown = false;
        this.mCheckedForSetup = false;
        this.mSleeping = false;
        this.mTopProcessState = 2;
        this.mWakefulness = 1;
        this.mKeyguardShown = false;
        this.mShuttingDown = false;
        this.mAdjSeq = 0;
        this.mLruSeq = 0;
        this.mNumNonCachedProcs = 0;
        this.mNumCachedHiddenProcs = 0;
        this.mNumServiceProcs = 0;
        this.mNewNumAServiceProcs = 0;
        this.mNewNumServiceProcs = 0;
        this.mAllowLowerMemLevel = false;
        this.mLastMemoryLevel = 0;
        this.mLastIdleTime = SystemClock.uptimeMillis();
        this.mLowRamTimeSinceLastIdle = 0L;
        this.mLowRamStartTime = 0L;
        this.mCurResumedPackage = null;
        this.mCurResumedUid = -1;
        this.mForegroundPackages = new ProcessMap<>();
        this.mTestPssMode = false;
        this.mDebugApp = null;
        this.mWaitForDebugger = false;
        this.mDebugTransient = false;
        this.mOrigDebugApp = null;
        this.mOrigWaitForDebugger = false;
        this.mAlwaysFinishActivities = false;
        this.mController = null;
        this.mControllerIsAMonkey = false;
        this.mProfileApp = null;
        this.mProfileProc = null;
        this.mProfilerInfo = null;
        this.mAppAgentMap = null;
        this.mProfileType = 0;
        this.mMemWatchProcesses = new ProcessMap<>();
        this.mTrackAllocationApp = null;
        this.mNativeDebuggingApp = null;
        this.mTmpLong = new long[3];
        this.mTmpBroadcastQueue = new ArraySet<>();
        this.mProcStateSeqCounter = 0L;
        this.mProcStartSeqCounter = 0L;
        this.mPendingStarts = new LongSparseArray<>();
        this.mScreenObservers = new ArrayList();
        this.mProcessObservers = new RemoteCallbackList<>();
        this.mActiveProcessChanges = new ProcessChangeItem[5];
        this.mPendingProcessChanges = new ArrayList<>();
        this.mAvailProcessChanges = new ArrayList<>();
        this.mUidObservers = new RemoteCallbackList<>();
        this.mActiveUidChanges = new UidRecord.ChangeItem[5];
        this.mPendingUidChanges = new ArrayList<>();
        this.mAvailUidChanges = new ArrayList<>();
        this.mProcessCpuTracker = new ProcessCpuTracker(false);
        this.mLastCpuTime = new AtomicLong(0L);
        this.mProcessCpuMutexFree = new AtomicBoolean(true);
        this.mProcessCpuInitLatch = new CountDownLatch(1);
        this.mLastWriteTime = 0L;
        this.mUpdateLock = new UpdateLock("immersive");
        this.mBooted = false;
        this.mPostActivityRecord = null;
        this.mLastActivityRecord = null;
        this.mNotifyRecentActivity = "true".equals(SystemProperties.get("persist.infoflow.recentapp"));
        this.mLastMemUsageReportTime = 0L;
        this.mViSessionId = 1000;
        this.mBgHandler = new AnonymousClass3(BackgroundThread.getHandler().getLooper());
        this.mProcessStateStatsLongs = new long[1];
        this.mSupportedSystemLocales = null;
        LockGuard.installLock(this, 6);
        this.mInjector = new Injector();
        this.mContext = systemContext;
        this.mFactoryTest = FactoryTest.getMode();
        this.mSystemThread = ActivityThread.currentActivityThread();
        this.mUiContext = this.mSystemThread.getSystemUiContext();
        Slog.i("ActivityManager", "Memory class: " + ActivityManager.staticGetMemoryClass());
        this.mPermissionReviewRequired = this.mContext.getResources().getBoolean(17957005);
        this.mHandlerThread = new ServiceThread("ActivityManager", -2, false);
        this.mHandlerThread.start();
        this.mHandler = new MainHandler(this.mHandlerThread.getLooper());
        this.mUiHandler = this.mInjector.getUiHandler(this);
        this.mProcStartHandlerThread = new ServiceThread("ActivityManager:procStart", -2, false);
        this.mProcStartHandlerThread.start();
        this.mProcStartHandler = new Handler(this.mProcStartHandlerThread.getLooper());
        this.mConstants = new ActivityManagerConstants(this, this.mHandler);
        if (sKillHandler == null) {
            sKillThread = new ServiceThread("ActivityManager:kill", 10, true);
            sKillThread.start();
            sKillHandler = new KillHandler(sKillThread.getLooper());
        }
        this.mFgBroadcastQueue = new BroadcastQueue(this, this.mHandler, "foreground", JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY, false);
        this.mBgBroadcastQueue = new BroadcastQueue(this, this.mHandler, "background", 60000L, true);
        this.mBroadcastQueues[0] = this.mFgBroadcastQueue;
        this.mBroadcastQueues[1] = this.mBgBroadcastQueue;
        this.mServices = new ActiveServices(this);
        this.mProviderMap = new ProviderMap(this);
        this.mAppErrors = new AppErrors(this.mUiContext, this);
        File dataDir = Environment.getDataDirectory();
        File systemDir = new File(dataDir, "system");
        systemDir.mkdirs();
        this.mAppWarnings = new AppWarnings(this, this.mUiContext, this.mHandler, this.mUiHandler, systemDir);
        this.mBatteryStatsService = new BatteryStatsService(systemContext, systemDir, this.mHandler);
        this.mBatteryStatsService.getActiveStatistics().readLocked();
        this.mBatteryStatsService.scheduleWriteToDisk();
        this.mOnBattery = ActivityManagerDebugConfig.DEBUG_POWER ? true : this.mBatteryStatsService.getActiveStatistics().getIsOnBattery();
        this.mBatteryStatsService.getActiveStatistics().setCallback(this);
        this.mProcessStats = new ProcessStatsService(this, new File(systemDir, "procstats"));
        this.mAppOpsService = this.mInjector.getAppOpsService(new File(systemDir, "appops.xml"), this.mHandler);
        this.mGrantFile = new AtomicFile(new File(systemDir, "urigrants.xml"), TAG_URI_GRANTS);
        this.mUserController = new UserController(this);
        this.mVrController = new VrController(this);
        this.GL_ES_VERSION = SystemProperties.getInt("ro.opengles.version", 0);
        if (SystemProperties.getInt("sys.use_fifo_ui", 0) != 0) {
            this.mUseFifoUiScheduling = true;
        }
        this.mTrackingAssociations = "1".equals(SystemProperties.get("debug.track-associations"));
        this.mTempConfig.setToDefaults();
        this.mTempConfig.setLocales(LocaleList.getDefault());
        this.mTempConfig.seq = 1;
        this.mConfigurationSeq = 1;
        this.mStackSupervisor = createStackSupervisor();
        this.mStackSupervisor.onConfigurationChanged(this.mTempConfig);
        this.mKeyguardController = this.mStackSupervisor.getKeyguardController();
        this.mCompatModePackages = new CompatModePackages(this, systemDir, this.mHandler);
        this.mIntentFirewall = new IntentFirewall(new IntentFirewallInterface(), this.mHandler);
        this.mTaskChangeNotificationController = new TaskChangeNotificationController(this, this.mStackSupervisor, this.mHandler);
        this.mActivityStartController = new ActivityStartController(this);
        this.mRecentTasks = createRecentTasks();
        this.mStackSupervisor.setRecentTasks(this.mRecentTasks);
        this.mLockTaskController = new LockTaskController(this.mContext, this.mStackSupervisor, this.mHandler);
        this.mLifecycleManager = new ClientLifecycleManager();
        this.mProcessCpuThread = new Thread("CpuTracker") { // from class: com.android.server.am.ActivityManagerService.5
            @Override // java.lang.Thread, java.lang.Runnable
            public void run() {
                synchronized (ActivityManagerService.this.mProcessCpuTracker) {
                    ActivityManagerService.this.mProcessCpuInitLatch.countDown();
                    ActivityManagerService.this.mProcessCpuTracker.init();
                }
                while (true) {
                    try {
                        try {
                            synchronized (this) {
                                long now = SystemClock.uptimeMillis();
                                long nextCpuDelay = (ActivityManagerService.this.mLastCpuTime.get() + ActivityManagerService.MONITOR_CPU_MAX_TIME) - now;
                                long nextWriteDelay = (ActivityManagerService.this.mLastWriteTime + 1800000) - now;
                                if (nextWriteDelay < nextCpuDelay) {
                                    nextCpuDelay = nextWriteDelay;
                                }
                                if (nextCpuDelay > 0) {
                                    ActivityManagerService.this.mProcessCpuMutexFree.set(true);
                                    wait(nextCpuDelay);
                                }
                            }
                        } catch (Exception e) {
                            Slog.e("ActivityManager", "Unexpected exception collecting process stats", e);
                        }
                    } catch (InterruptedException e2) {
                    }
                    ActivityManagerService.this.updateCpuStatsNow();
                }
            }
        };
        this.mHiddenApiBlacklist = new HiddenApiSettings(this.mHandler, this.mContext);
        Watchdog.getInstance().addMonitor(this);
        Watchdog.getInstance().addThread(this.mHandler);
        updateOomAdjLocked();
        try {
            Process.setThreadGroupAndCpuset(BackgroundThread.get().getThreadId(), 0);
        } catch (Exception e) {
            Slog.w("ActivityManager", "Setting background thread cpuset failed");
        }
        xpSystemServer.init(this.mContext);
        xpActivityManagerService.get(this.mContext).onStart();
    }

    protected ActivityStackSupervisor createStackSupervisor() {
        ActivityStackSupervisor supervisor = new ActivityStackSupervisor(this, this.mHandler.getLooper());
        supervisor.initialize();
        return supervisor;
    }

    protected RecentTasks createRecentTasks() {
        return new RecentTasks(this, this.mStackSupervisor);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public RecentTasks getRecentTasks() {
        return this.mRecentTasks;
    }

    public void setSystemServiceManager(SystemServiceManager mgr) {
        this.mSystemServiceManager = mgr;
    }

    public void setInstaller(Installer installer) {
        this.mInstaller = installer;
    }

    /* JADX INFO: Access modifiers changed from: private */
    public void start() {
        Process.removeAllProcessGroups();
        this.mProcessCpuThread.start();
        this.mBatteryStatsService.publish();
        this.mAppOpsService.publish(this.mContext);
        Slog.d("AppOps", "AppOpsService published");
        LocalServices.addService(ActivityManagerInternal.class, new LocalService());
        try {
            this.mProcessCpuInitLatch.await();
        } catch (InterruptedException e) {
            Slog.wtf("ActivityManager", "Interrupted wait during start", e);
            Thread.currentThread().interrupt();
            throw new IllegalStateException("Interrupted wait during start");
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void onUserStoppedLocked(int userId) {
        this.mRecentTasks.unloadUserDataFromMemoryLocked(userId);
        this.mAllowAppSwitchUids.remove(userId);
    }

    public void initPowerManagement() {
        this.mStackSupervisor.initPowerManagement();
        this.mBatteryStatsService.initPowerManagement();
        this.mLocalPowerManager = (PowerManagerInternal) LocalServices.getService(PowerManagerInternal.class);
        PowerManager pm = (PowerManager) this.mContext.getSystemService("power");
        this.mVoiceWakeLock = pm.newWakeLock(1, "*voice*");
        this.mVoiceWakeLock.setReferenceCounted(false);
    }

    private ArraySet<String> getBackgroundLaunchBroadcasts() {
        if (this.mBackgroundLaunchBroadcasts == null) {
            this.mBackgroundLaunchBroadcasts = SystemConfig.getInstance().getAllowImplicitBroadcasts();
        }
        return this.mBackgroundLaunchBroadcasts;
    }

    public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
        int i;
        if (code == 1599295570) {
            ArrayList<IBinder> procs = new ArrayList<>();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    int NP = this.mProcessNames.getMap().size();
                    for (int ip = 0; ip < NP; ip++) {
                        SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                        int NA = apps.size();
                        for (int ia = 0; ia < NA; ia++) {
                            ProcessRecord app = apps.valueAt(ia);
                            if (app.thread != null) {
                                procs.add(app.thread.asBinder());
                            }
                        }
                    }
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            resetPriorityAfterLockedSection();
            int N = procs.size();
            for (i = 0; i < N; i++) {
                Parcel data2 = Parcel.obtain();
                try {
                    procs.get(i).transact(1599295570, data2, null, 1);
                } catch (RemoteException e) {
                }
                data2.recycle();
            }
        }
        try {
            return super.onTransact(code, data, reply, flags);
        } catch (RuntimeException e2) {
            if (!(e2 instanceof SecurityException) && !(e2 instanceof IllegalArgumentException) && !(e2 instanceof IllegalStateException)) {
                Slog.wtf("ActivityManager", "Activity Manager Crash. UID:" + Binder.getCallingUid() + " PID:" + Binder.getCallingPid() + " TRANS:" + code, e2);
            }
            throw e2;
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void updateCpuStats() {
        long now = SystemClock.uptimeMillis();
        if (this.mLastCpuTime.get() < now - 5000 && this.mProcessCpuMutexFree.compareAndSet(true, false)) {
            synchronized (this.mProcessCpuThread) {
                this.mProcessCpuThread.notify();
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* JADX WARN: Removed duplicated region for block: B:59:0x01b5 A[Catch: all -> 0x01c2, TryCatch #2 {, blocks: (B:4:0x0005, B:6:0x001e, B:8:0x0030, B:10:0x0040, B:13:0x006d, B:14:0x00b7, B:15:0x00bf, B:61:0x01bd, B:16:0x00c0, B:17:0x00c2, B:65:0x01c1, B:57:0x01aa, B:59:0x01b5, B:60:0x01bc), top: B:74:0x0005 }] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public void updateCpuStatsNow() {
        /*
            Method dump skipped, instructions count: 456
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.updateCpuStatsNow():void");
    }

    public void batteryNeedsCpuUpdate() {
        updateCpuStatsNow();
    }

    public void batteryPowerChanged(boolean onBattery) {
        updateCpuStatsNow();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    this.mOnBattery = ActivityManagerDebugConfig.DEBUG_POWER ? true : onBattery;
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void batteryStatsReset() {
        BinderCallsStatsService.reset();
    }

    public void batterySendBroadcast(Intent intent) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, -1, 1000, -1);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    private ArrayMap<String, IBinder> getCommonServicesLocked(boolean isolated) {
        if (isolated) {
            if (this.mIsolatedAppBindArgs == null) {
                this.mIsolatedAppBindArgs = new ArrayMap<>(1);
                addServiceToMap(this.mIsolatedAppBindArgs, "package");
            }
            return this.mIsolatedAppBindArgs;
        }
        if (this.mAppBindArgs == null) {
            this.mAppBindArgs = new ArrayMap<>();
            addServiceToMap(this.mAppBindArgs, "package");
            addServiceToMap(this.mAppBindArgs, "window");
            addServiceToMap(this.mAppBindArgs, "alarm");
            addServiceToMap(this.mAppBindArgs, "display");
            addServiceToMap(this.mAppBindArgs, "network_management");
            addServiceToMap(this.mAppBindArgs, "connectivity");
            addServiceToMap(this.mAppBindArgs, "accessibility");
            addServiceToMap(this.mAppBindArgs, "input_method");
            addServiceToMap(this.mAppBindArgs, "input");
            addServiceToMap(this.mAppBindArgs, GraphicsStatsService.GRAPHICS_STATS_SERVICE);
            addServiceToMap(this.mAppBindArgs, "appops");
            addServiceToMap(this.mAppBindArgs, "content");
            addServiceToMap(this.mAppBindArgs, "jobscheduler");
            addServiceToMap(this.mAppBindArgs, "notification");
            addServiceToMap(this.mAppBindArgs, "vibrator");
            addServiceToMap(this.mAppBindArgs, "account");
            addServiceToMap(this.mAppBindArgs, "power");
            addServiceToMap(this.mAppBindArgs, "user");
            addServiceToMap(this.mAppBindArgs, "mount");
        }
        return this.mAppBindArgs;
    }

    private static void addServiceToMap(ArrayMap<String, IBinder> map, String name) {
        IBinder service = ServiceManager.getService(name);
        if (service != null) {
            map.put(name, service);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public void setResumedActivityUncheckLocked(ActivityRecord r, String reason) {
        IVoiceInteractionSession session;
        TaskRecord task = r.getTask();
        if (task.isActivityTypeStandard()) {
            if (this.mCurAppTimeTracker != r.appTimeTracker) {
                if (this.mCurAppTimeTracker != null) {
                    this.mCurAppTimeTracker.stop();
                    this.mHandler.obtainMessage(54, this.mCurAppTimeTracker).sendToTarget();
                    this.mStackSupervisor.clearOtherAppTimeTrackers(r.appTimeTracker);
                    this.mCurAppTimeTracker = null;
                }
                if (r.appTimeTracker != null) {
                    this.mCurAppTimeTracker = r.appTimeTracker;
                    startTimeTrackingFocusedActivityLocked();
                }
            } else {
                startTimeTrackingFocusedActivityLocked();
            }
        } else {
            r.appTimeTracker = null;
        }
        if (task.voiceInteractor != null) {
            startRunningVoiceLocked(task.voiceSession, r.info.applicationInfo.uid);
        } else {
            finishRunningVoiceLocked();
            if (this.mLastResumedActivity != null) {
                TaskRecord lastResumedActivityTask = this.mLastResumedActivity.getTask();
                if (lastResumedActivityTask != null && lastResumedActivityTask.voiceSession != null) {
                    session = lastResumedActivityTask.voiceSession;
                } else {
                    session = this.mLastResumedActivity.voiceSession;
                }
                if (session != null) {
                    finishVoiceTask(session);
                }
            }
        }
        if (this.mLastResumedActivity != null && r.userId != this.mLastResumedActivity.userId) {
            this.mUserController.sendForegroundProfileChanged(r.userId);
        }
        updateResumedAppTrace(r);
        this.mLastResumedActivity = r;
        this.mWindowManager.setFocusedApp(r.appToken, true);
        StringBuilder sb = new StringBuilder();
        sb.append("setResumedActivityUncheckLocked r=");
        sb.append(r != null ? r.realActivity : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
        xpLogger.i("ActivityManager", sb.toString());
        handleActivityResumedLocked(r);
        applyUpdateLockStateLocked(r);
        applyUpdateVrModeLocked(r);
        EventLogTags.writeAmSetResumedActivity(r == null ? -1 : r.userId, r == null ? "NULL" : r.shortComponentName, reason);
    }

    private void updateResumedAppTrace(ActivityRecord resumed) {
        if (this.mTracedResumedActivity != null) {
            Trace.asyncTraceEnd(64L, constructResumedTraceName(this.mTracedResumedActivity.packageName), 0);
        }
        if (resumed != null) {
            Trace.asyncTraceBegin(64L, constructResumedTraceName(resumed.packageName), 0);
        }
        this.mTracedResumedActivity = resumed;
    }

    private String constructResumedTraceName(String packageName) {
        return "focused app: " + packageName;
    }

    public void setFocusedStack(int stackId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "setFocusedStack()");
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityStack stack = this.mStackSupervisor.getStack(stackId);
                if (stack == null) {
                    Slog.w("ActivityManager", "setFocusedStack: No stack with id=" + stackId);
                    resetPriorityAfterLockedSection();
                    return;
                }
                ActivityRecord r = stack.topRunningActivityLocked();
                if (this.mStackSupervisor.moveFocusableActivityStackToFrontLocked(r, "setFocusedStack")) {
                    this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                }
                resetPriorityAfterLockedSection();
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void setFocusedTask(int taskId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "setFocusedTask()");
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task != null) {
                    ActivityRecord r = task.topRunningActivityLocked();
                    if (this.mStackSupervisor.moveFocusableActivityStackToFrontLocked(r, "setFocusedTask")) {
                        this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                    }
                    resetPriorityAfterLockedSection();
                    return;
                }
                resetPriorityAfterLockedSection();
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void registerTaskStackListener(ITaskStackListener listener) throws RemoteException {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "registerTaskStackListener()");
        this.mTaskChangeNotificationController.registerTaskStackListener(listener);
    }

    public void unregisterTaskStackListener(ITaskStackListener listener) throws RemoteException {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "unregisterTaskStackListener()");
        this.mTaskChangeNotificationController.unregisterTaskStackListener(listener);
    }

    public void notifyActivityDrawn(IBinder token) {
        if (ActivityManagerDebugConfig.DEBUG_VISIBILITY) {
            Slog.d("ActivityManager", "notifyActivityDrawn: token=" + token);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = this.mStackSupervisor.isInAnyStackLocked(token);
                if (r != null) {
                    r.getStack().notifyActivityDrawnLocked(r);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    final void applyUpdateLockStateLocked(ActivityRecord r) {
        boolean nextState = r != null && r.immersive;
        this.mHandler.sendMessage(this.mHandler.obtainMessage(37, nextState ? 1 : 0, 0, r));
    }

    final void applyUpdateVrModeLocked(ActivityRecord r) {
        if (r.requestedVrComponent != null && r.getDisplayId() != 0) {
            Slog.i("ActivityManager", "Moving " + r.shortComponentName + " from stack " + r.getStackId() + " to main stack for VR");
            ActivityStack stack = this.mStackSupervisor.getDefaultDisplay().getOrCreateStack(1, r.getActivityType(), true);
            moveTaskToStack(r.getTask().taskId, stack.mStackId, true);
        }
        this.mHandler.sendMessage(this.mHandler.obtainMessage(61, 0, 0, r));
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public final void showAskCompatModeDialogLocked(ActivityRecord r) {
        Message msg = Message.obtain();
        msg.what = 30;
        msg.obj = r.getTask().askedCompatMode ? null : r;
        this.mUiHandler.sendMessage(msg);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public final AppWarnings getAppWarningsLocked() {
        return this.mAppWarnings;
    }

    final void showAppWarningsIfNeededLocked(ActivityRecord r) {
        this.mAppWarnings.showUnsupportedCompileSdkDialogIfNeeded(r);
        this.mAppWarnings.showUnsupportedDisplaySizeDialogIfNeeded(r);
        this.mAppWarnings.showDeprecatedTargetDialogIfNeeded(r);
    }

    private int updateLruProcessInternalLocked(ProcessRecord app, long now, int index, String what, Object obj, ProcessRecord srcApp) {
        app.lastActivityTime = now;
        if (app.activities.size() > 0 || app.recentTasks.size() > 0) {
            return index;
        }
        int lrui = this.mLruProcesses.lastIndexOf(app);
        if (lrui < 0) {
            Slog.wtf("ActivityManager", "Adding dependent process " + app + " not on LRU list: " + what + " " + obj + " from " + srcApp);
            return index;
        } else if (lrui >= index) {
            return index;
        } else {
            if (lrui >= this.mLruProcessActivityStart) {
                return index;
            }
            this.mLruProcesses.remove(lrui);
            if (index > 0) {
                index--;
            }
            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                Slog.d("ActivityManager", "Moving dep from " + lrui + " to " + index + " in LRU list: " + app);
            }
            this.mLruProcesses.add(index, app);
            return index;
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public static void killProcessGroup(int uid, int pid) {
        if (sKillHandler != null) {
            sKillHandler.sendMessage(sKillHandler.obtainMessage(4000, uid, pid));
            return;
        }
        Slog.w("ActivityManager", "Asked to kill process group before system bringup!");
        Process.killProcessGroup(uid, pid);
    }

    final void removeLruProcessLocked(ProcessRecord app) {
        int lrui = this.mLruProcesses.lastIndexOf(app);
        if (lrui >= 0) {
            if (!app.killed) {
                if (app.persistent) {
                    Slog.w("ActivityManager", "Removing persistent process that hasn't been killed: " + app);
                } else {
                    Slog.wtfStack("ActivityManager", "Removing process that hasn't been killed: " + app);
                    if (app.pid > 0) {
                        Process.killProcessQuiet(app.pid);
                        killProcessGroup(app.uid, app.pid);
                    } else {
                        app.pendingStart = false;
                    }
                }
            }
            if (lrui <= this.mLruProcessActivityStart) {
                this.mLruProcessActivityStart--;
            }
            if (lrui <= this.mLruProcessServiceStart) {
                this.mLruProcessServiceStart--;
            }
            this.mLruProcesses.remove(lrui);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public final void updateLruProcessLocked(ProcessRecord app, boolean activityChange, ProcessRecord client) {
        int i;
        int nextIndex;
        int j;
        int j2;
        long now;
        int N;
        boolean hasActivity = app.activities.size() > 0 || app.hasClientActivities || app.treatLikeActivity || app.recentTasks.size() > 0;
        if (!activityChange && hasActivity) {
            return;
        }
        this.mLruSeq++;
        long now2 = SystemClock.uptimeMillis();
        app.lastActivityTime = now2;
        if (hasActivity) {
            int N2 = this.mLruProcesses.size();
            if (N2 > 0 && this.mLruProcesses.get(N2 - 1) == app) {
                if (ActivityManagerDebugConfig.DEBUG_LRU) {
                    Slog.d("ActivityManager", "Not moving, already top activity: " + app);
                    return;
                }
                return;
            }
        } else if (this.mLruProcessServiceStart > 0 && this.mLruProcesses.get(this.mLruProcessServiceStart - 1) == app) {
            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                Slog.d("ActivityManager", "Not moving, already top other: " + app);
                return;
            }
            return;
        }
        int lrui = this.mLruProcesses.lastIndexOf(app);
        if (app.persistent && lrui >= 0) {
            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                Slog.d("ActivityManager", "Not moving, persistent: " + app);
                return;
            }
            return;
        }
        if (lrui >= 0) {
            if (lrui < this.mLruProcessActivityStart) {
                this.mLruProcessActivityStart--;
            }
            if (lrui < this.mLruProcessServiceStart) {
                this.mLruProcessServiceStart--;
            }
            this.mLruProcesses.remove(lrui);
        }
        if (hasActivity) {
            int N3 = this.mLruProcesses.size();
            if ((app.activities.size() == 0 || app.recentTasks.size() > 0) && this.mLruProcessActivityStart < N3 - 1) {
                if (ActivityManagerDebugConfig.DEBUG_LRU) {
                    Slog.d("ActivityManager", "Adding to second-top of LRU activity list: " + app);
                }
                this.mLruProcesses.add(N3 - 1, app);
                int uid = app.info.uid;
                int i2 = N3 - 2;
                while (i2 > this.mLruProcessActivityStart) {
                    ProcessRecord subProc = this.mLruProcesses.get(i2);
                    if (subProc.info.uid != uid) {
                        break;
                    }
                    if (this.mLruProcesses.get(i2 - 1).info.uid != uid) {
                        if (ActivityManagerDebugConfig.DEBUG_LRU) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("Pushing uid ");
                            sb.append(uid);
                            sb.append(" swapping at ");
                            sb.append(i2);
                            sb.append(": ");
                            sb.append(this.mLruProcesses.get(i2));
                            sb.append(" : ");
                            N = N3;
                            sb.append(this.mLruProcesses.get(i2 - 1));
                            Slog.d("ActivityManager", sb.toString());
                        } else {
                            N = N3;
                        }
                        ProcessRecord tmp = this.mLruProcesses.get(i2);
                        this.mLruProcesses.set(i2, this.mLruProcesses.get(i2 - 1));
                        this.mLruProcesses.set(i2 - 1, tmp);
                        i2--;
                    } else {
                        N = N3;
                    }
                    i2--;
                    N3 = N;
                }
                nextIndex = this.mLruProcessServiceStart;
                i = 1;
            }
            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                Slog.d("ActivityManager", "Adding to top of LRU activity list: " + app);
            }
            this.mLruProcesses.add(app);
            nextIndex = this.mLruProcessServiceStart;
            i = 1;
        } else {
            int index = this.mLruProcessServiceStart;
            if (client != null) {
                int clientIndex = this.mLruProcesses.lastIndexOf(client);
                if (ActivityManagerDebugConfig.DEBUG_LRU && clientIndex < 0) {
                    Slog.d("ActivityManager", "Unknown client " + client + " when updating " + app);
                }
                if (clientIndex <= lrui) {
                    clientIndex = lrui;
                }
                if (clientIndex >= 0 && index > clientIndex) {
                    index = clientIndex;
                }
            }
            if (ActivityManagerDebugConfig.DEBUG_LRU) {
                Slog.d("ActivityManager", "Adding at " + index + " of LRU list: " + app);
            }
            this.mLruProcesses.add(index, app);
            int nextIndex2 = index - 1;
            i = 1;
            this.mLruProcessActivityStart++;
            this.mLruProcessServiceStart++;
            nextIndex = nextIndex2;
        }
        int j3 = app.connections.size() - i;
        int nextIndex3 = nextIndex;
        while (true) {
            int j4 = j3;
            if (j4 < 0) {
                break;
            }
            ConnectionRecord cr = app.connections.valueAt(j4);
            if (cr.binding == null || cr.serviceDead || cr.binding.service == null || cr.binding.service.app == null || cr.binding.service.app.lruSeq == this.mLruSeq || cr.binding.service.app.persistent) {
                j2 = j4;
                now = now2;
            } else {
                j2 = j4;
                now = now2;
                nextIndex3 = updateLruProcessInternalLocked(cr.binding.service.app, now2, nextIndex3, "service connection", cr, app);
            }
            j3 = j2 - 1;
            now2 = now;
        }
        long now3 = now2;
        int j5 = app.conProviders.size() - 1;
        while (true) {
            int j6 = j5;
            if (j6 < 0) {
                return;
            }
            ContentProviderRecord cpr = app.conProviders.get(j6).provider;
            if (cpr.proc == null || cpr.proc.lruSeq == this.mLruSeq || cpr.proc.persistent) {
                j = j6;
            } else {
                j = j6;
                nextIndex3 = updateLruProcessInternalLocked(cpr.proc, now3, nextIndex3, "provider reference", cpr, app);
            }
            j5 = j - 1;
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public final ProcessRecord getProcessRecordLocked(String processName, int uid, boolean keepIfLarge) {
        if (uid == 1000) {
            SparseArray<ProcessRecord> procs = (SparseArray) this.mProcessNames.getMap().get(processName);
            if (procs == null) {
                return null;
            }
            int procCount = procs.size();
            for (int i = 0; i < procCount; i++) {
                int procUid = procs.keyAt(i);
                if (!UserHandle.isApp(procUid) && UserHandle.isSameUser(procUid, uid)) {
                    return procs.valueAt(i);
                }
            }
        }
        ProcessRecord proc = (ProcessRecord) this.mProcessNames.get(processName, uid);
        if (proc != null && !keepIfLarge && this.mLastMemoryLevel > 0 && proc.setProcState >= 18) {
            if (ActivityManagerDebugConfig.DEBUG_PSS) {
                Slog.d("ActivityManager", "May not keep " + proc + ": pss=" + proc.lastCachedPss);
            }
            if (proc.lastCachedPss >= this.mProcessList.getCachedRestoreThresholdKb()) {
                if (proc.baseProcessTracker != null) {
                    proc.baseProcessTracker.reportCachedKill(proc.pkgList, proc.lastCachedPss);
                }
                proc.kill(Long.toString(proc.lastCachedPss) + "k from cached", true);
            }
        }
        return proc;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void notifyPackageUse(String packageName, int reason) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                getPackageManagerInternalLocked().notifyPackageUse(packageName, reason);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean isNextTransitionForward() {
        int transit = this.mWindowManager.getPendingAppTransition();
        return transit == 6 || transit == 8 || transit == 10;
    }

    boolean startIsolatedProcess(String entryPoint, String[] entryPointArgs, String processName, String abiOverride, int uid, Runnable crashHandler) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ApplicationInfo info = new ApplicationInfo();
                info.uid = 1000;
                info.processName = processName;
                info.className = entryPoint;
                info.packageName = PackageManagerService.PLATFORM_PACKAGE_NAME;
                info.seInfoUser = ":complete";
                info.targetSdkVersion = Build.VERSION.SDK_INT;
                ProcessRecord proc = startProcessLocked(processName, info, false, 0, BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS, null, true, true, uid, true, abiOverride, entryPoint, entryPointArgs, crashHandler);
                z = proc != null;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return z;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) {
        return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0, keepIfLarge, null, null, null, null);
    }

    @GuardedBy("this")
    final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) {
        ProcessRecord app;
        long startTime = SystemClock.elapsedRealtime();
        if (isolated) {
            app = null;
        } else {
            app = getProcessRecordLocked(processName, info.uid, keepIfLarge);
            checkTime(startTime, "startProcess: after getProcessRecord");
            if ((intentFlags & 4) != 0) {
                if (this.mAppErrors.isBadProcessLocked(info)) {
                    if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                        Slog.v("ActivityManager", "Bad process: " + info.uid + SliceClientPermissions.SliceAuthority.DELIMITER + info.processName);
                    }
                    return null;
                }
            } else {
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                    Slog.v("ActivityManager", "Clearing bad process: " + info.uid + SliceClientPermissions.SliceAuthority.DELIMITER + info.processName);
                }
                this.mAppErrors.resetProcessCrashTimeLocked(info);
                if (this.mAppErrors.isBadProcessLocked(info)) {
                    EventLog.writeEvent((int) EventLogTags.AM_PROC_GOOD, Integer.valueOf(UserHandle.getUserId(info.uid)), Integer.valueOf(info.uid), info.processName);
                    this.mAppErrors.clearBadProcessLocked(info);
                    if (app != null) {
                        app.bad = false;
                    }
                }
            }
        }
        ProcessRecord app2 = app;
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
            StringBuilder sb = new StringBuilder();
            sb.append("startProcess: name=");
            sb.append(processName);
            sb.append(" app=");
            sb.append(app2);
            sb.append(" knownToBeDead=");
            sb.append(knownToBeDead);
            sb.append(" thread=");
            sb.append(app2 != null ? app2.thread : null);
            sb.append(" pid=");
            sb.append(app2 != null ? app2.pid : -1);
            Slog.v("ActivityManager", sb.toString());
        }
        if (app2 != null && app2.pid > 0) {
            if ((!knownToBeDead && !app2.killed) || app2.thread == null) {
                if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                    Slog.v("ActivityManager", "App already running: " + app2);
                }
                app2.addPackage(info.packageName, info.versionCode, this.mProcessStats);
                checkTime(startTime, "startProcess: done, added package to proc");
                return app2;
            }
            if (ActivityManagerDebugConfig.DEBUG_PROCESSES || ActivityManagerDebugConfig.DEBUG_CLEANUP) {
                Slog.v("ActivityManager", "App died: " + app2);
            }
            checkTime(startTime, "startProcess: bad proc running, killing");
            killProcessGroup(app2.uid, app2.pid);
            handleAppDiedLocked(app2, true, true);
            checkTime(startTime, "startProcess: done killing old proc");
        }
        String hostingNameStr = hostingName != null ? hostingName.flattenToShortString() : null;
        if (app2 == null) {
            checkTime(startTime, "startProcess: creating new process record");
            app2 = newProcessRecordLocked(info, processName, isolated, isolatedUid);
            if (app2 == null) {
                Slog.w("ActivityManager", "Failed making new process record for " + processName + SliceClientPermissions.SliceAuthority.DELIMITER + info.uid + " isolated=" + isolated);
                return null;
            }
            app2.crashHandler = crashHandler;
            app2.isolatedEntryPoint = entryPoint;
            app2.isolatedEntryPointArgs = entryPointArgs;
            checkTime(startTime, "startProcess: done creating new process record");
        } else {
            app2.addPackage(info.packageName, info.versionCode, this.mProcessStats);
            checkTime(startTime, "startProcess: added package to existing proc");
        }
        if (!this.mProcessesReady && !isAllowedWhileBooting(info) && !allowWhileBooting) {
            if (!this.mProcessesOnHold.contains(app2)) {
                this.mProcessesOnHold.add(app2);
            }
            if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                Slog.v("ActivityManager", "System not ready, putting on hold: " + app2);
            }
            checkTime(startTime, "startProcess: returning with proc on hold");
            return app2;
        }
        checkTime(startTime, "startProcess: stepping in to startProcess");
        boolean success = startProcessLocked(app2, hostingType, hostingNameStr, abiOverride);
        checkTime(startTime, "startProcess: done starting proc!");
        if (success) {
            return app2;
        }
        return null;
    }

    boolean isAllowedWhileBooting(ApplicationInfo ai) {
        return (ai.flags & 8) != 0;
    }

    @GuardedBy("this")
    private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) {
        startProcessLocked(app, hostingType, hostingNameStr, null);
    }

    @GuardedBy("this")
    private final boolean startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride) {
        return startProcessLocked(app, hostingType, hostingNameStr, false, abiOverride);
    }

    /* JADX WARN: Removed duplicated region for block: B:107:0x021e A[Catch: RuntimeException -> 0x0107, TryCatch #2 {RuntimeException -> 0x0107, blocks: (B:28:0x0097, B:30:0x00c0, B:32:0x00c7, B:34:0x00d4, B:36:0x00f7, B:37:0x00fb, B:39:0x00ff, B:49:0x0121, B:51:0x0125, B:53:0x0129, B:56:0x0138, B:58:0x013c, B:70:0x015f, B:78:0x0184, B:83:0x019e, B:94:0x01cd, B:96:0x01d7, B:99:0x01e7, B:101:0x01f3, B:103:0x01f7, B:105:0x01ff, B:107:0x021e, B:108:0x0220, B:109:0x0236, B:114:0x0241, B:120:0x0279, B:129:0x028e, B:134:0x029b, B:139:0x02b5, B:33:0x00cb, B:44:0x010f, B:45:0x0113, B:116:0x025c, B:118:0x0267), top: B:159:0x0094, inners: #4 }] */
    /* JADX WARN: Removed duplicated region for block: B:108:0x0220 A[Catch: RuntimeException -> 0x0107, TryCatch #2 {RuntimeException -> 0x0107, blocks: (B:28:0x0097, B:30:0x00c0, B:32:0x00c7, B:34:0x00d4, B:36:0x00f7, B:37:0x00fb, B:39:0x00ff, B:49:0x0121, B:51:0x0125, B:53:0x0129, B:56:0x0138, B:58:0x013c, B:70:0x015f, B:78:0x0184, B:83:0x019e, B:94:0x01cd, B:96:0x01d7, B:99:0x01e7, B:101:0x01f3, B:103:0x01f7, B:105:0x01ff, B:107:0x021e, B:108:0x0220, B:109:0x0236, B:114:0x0241, B:120:0x0279, B:129:0x028e, B:134:0x029b, B:139:0x02b5, B:33:0x00cb, B:44:0x010f, B:45:0x0113, B:116:0x025c, B:118:0x0267), top: B:159:0x0094, inners: #4 }] */
    /* JADX WARN: Removed duplicated region for block: B:114:0x0241 A[Catch: RuntimeException -> 0x0107, TRY_ENTER, TRY_LEAVE, TryCatch #2 {RuntimeException -> 0x0107, blocks: (B:28:0x0097, B:30:0x00c0, B:32:0x00c7, B:34:0x00d4, B:36:0x00f7, B:37:0x00fb, B:39:0x00ff, B:49:0x0121, B:51:0x0125, B:53:0x0129, B:56:0x0138, B:58:0x013c, B:70:0x015f, B:78:0x0184, B:83:0x019e, B:94:0x01cd, B:96:0x01d7, B:99:0x01e7, B:101:0x01f3, B:103:0x01f7, B:105:0x01ff, B:107:0x021e, B:108:0x0220, B:109:0x0236, B:114:0x0241, B:120:0x0279, B:129:0x028e, B:134:0x029b, B:139:0x02b5, B:33:0x00cb, B:44:0x010f, B:45:0x0113, B:116:0x025c, B:118:0x0267), top: B:159:0x0094, inners: #4 }] */
    /* JADX WARN: Removed duplicated region for block: B:126:0x0285  */
    /* JADX WARN: Removed duplicated region for block: B:127:0x0288 A[Catch: RuntimeException -> 0x0336, TRY_ENTER, TRY_LEAVE, TryCatch #1 {RuntimeException -> 0x0336, blocks: (B:23:0x0079, B:24:0x008b, B:47:0x0117, B:64:0x014b, B:66:0x0152, B:67:0x0157, B:73:0x0165, B:75:0x0173, B:76:0x0175, B:81:0x018f, B:86:0x01a9, B:88:0x01b7, B:89:0x01b9, B:91:0x01c7, B:92:0x01c9, B:97:0x01df, B:111:0x023a, B:132:0x0295, B:137:0x02a5, B:140:0x02e5, B:145:0x0302, B:144:0x02fe, B:127:0x0288), top: B:157:0x0079 }] */
    /* JADX WARN: Removed duplicated region for block: B:129:0x028e A[Catch: RuntimeException -> 0x0107, TRY_ENTER, TRY_LEAVE, TryCatch #2 {RuntimeException -> 0x0107, blocks: (B:28:0x0097, B:30:0x00c0, B:32:0x00c7, B:34:0x00d4, B:36:0x00f7, B:37:0x00fb, B:39:0x00ff, B:49:0x0121, B:51:0x0125, B:53:0x0129, B:56:0x0138, B:58:0x013c, B:70:0x015f, B:78:0x0184, B:83:0x019e, B:94:0x01cd, B:96:0x01d7, B:99:0x01e7, B:101:0x01f3, B:103:0x01f7, B:105:0x01ff, B:107:0x021e, B:108:0x0220, B:109:0x0236, B:114:0x0241, B:120:0x0279, B:129:0x028e, B:134:0x029b, B:139:0x02b5, B:33:0x00cb, B:44:0x010f, B:45:0x0113, B:116:0x025c, B:118:0x0267), top: B:159:0x0094, inners: #4 }] */
    /* JADX WARN: Removed duplicated region for block: B:134:0x029b A[Catch: RuntimeException -> 0x0107, TRY_ENTER, TRY_LEAVE, TryCatch #2 {RuntimeException -> 0x0107, blocks: (B:28:0x0097, B:30:0x00c0, B:32:0x00c7, B:34:0x00d4, B:36:0x00f7, B:37:0x00fb, B:39:0x00ff, B:49:0x0121, B:51:0x0125, B:53:0x0129, B:56:0x0138, B:58:0x013c, B:70:0x015f, B:78:0x0184, B:83:0x019e, B:94:0x01cd, B:96:0x01d7, B:99:0x01e7, B:101:0x01f3, B:103:0x01f7, B:105:0x01ff, B:107:0x021e, B:108:0x0220, B:109:0x0236, B:114:0x0241, B:120:0x0279, B:129:0x028e, B:134:0x029b, B:139:0x02b5, B:33:0x00cb, B:44:0x010f, B:45:0x0113, B:116:0x025c, B:118:0x0267), top: B:159:0x0094, inners: #4 }] */
    /* JADX WARN: Removed duplicated region for block: B:139:0x02b5 A[Catch: RuntimeException -> 0x0107, TRY_ENTER, TRY_LEAVE, TryCatch #2 {RuntimeException -> 0x0107, blocks: (B:28:0x0097, B:30:0x00c0, B:32:0x00c7, B:34:0x00d4, B:36:0x00f7, B:37:0x00fb, B:39:0x00ff, B:49:0x0121, B:51:0x0125, B:53:0x0129, B:56:0x0138, B:58:0x013c, B:70:0x015f, B:78:0x0184, B:83:0x019e, B:94:0x01cd, B:96:0x01d7, B:99:0x01e7, B:101:0x01f3, B:103:0x01f7, B:105:0x01ff, B:107:0x021e, B:108:0x0220, B:109:0x0236, B:114:0x0241, B:120:0x0279, B:129:0x028e, B:134:0x029b, B:139:0x02b5, B:33:0x00cb, B:44:0x010f, B:45:0x0113, B:116:0x025c, B:118:0x0267), top: B:159:0x0094, inners: #4 }] */
    /* JADX WARN: Removed duplicated region for block: B:142:0x02fb  */
    /* JADX WARN: Removed duplicated region for block: B:144:0x02fe A[Catch: RuntimeException -> 0x0336, TRY_ENTER, TryCatch #1 {RuntimeException -> 0x0336, blocks: (B:23:0x0079, B:24:0x008b, B:47:0x0117, B:64:0x014b, B:66:0x0152, B:67:0x0157, B:73:0x0165, B:75:0x0173, B:76:0x0175, B:81:0x018f, B:86:0x01a9, B:88:0x01b7, B:89:0x01b9, B:91:0x01c7, B:92:0x01c9, B:97:0x01df, B:111:0x023a, B:132:0x0295, B:137:0x02a5, B:140:0x02e5, B:145:0x0302, B:144:0x02fe, B:127:0x0288), top: B:157:0x0079 }] */
    /* JADX WARN: Removed duplicated region for block: B:66:0x0152 A[Catch: RuntimeException -> 0x0336, TryCatch #1 {RuntimeException -> 0x0336, blocks: (B:23:0x0079, B:24:0x008b, B:47:0x0117, B:64:0x014b, B:66:0x0152, B:67:0x0157, B:73:0x0165, B:75:0x0173, B:76:0x0175, B:81:0x018f, B:86:0x01a9, B:88:0x01b7, B:89:0x01b9, B:91:0x01c7, B:92:0x01c9, B:97:0x01df, B:111:0x023a, B:132:0x0295, B:137:0x02a5, B:140:0x02e5, B:145:0x0302, B:144:0x02fe, B:127:0x0288), top: B:157:0x0079 }] */
    /* JADX WARN: Removed duplicated region for block: B:75:0x0173 A[Catch: RuntimeException -> 0x0336, TryCatch #1 {RuntimeException -> 0x0336, blocks: (B:23:0x0079, B:24:0x008b, B:47:0x0117, B:64:0x014b, B:66:0x0152, B:67:0x0157, B:73:0x0165, B:75:0x0173, B:76:0x0175, B:81:0x018f, B:86:0x01a9, B:88:0x01b7, B:89:0x01b9, B:91:0x01c7, B:92:0x01c9, B:97:0x01df, B:111:0x023a, B:132:0x0295, B:137:0x02a5, B:140:0x02e5, B:145:0x0302, B:144:0x02fe, B:127:0x0288), top: B:157:0x0079 }] */
    /* JADX WARN: Removed duplicated region for block: B:88:0x01b7 A[Catch: RuntimeException -> 0x0336, TryCatch #1 {RuntimeException -> 0x0336, blocks: (B:23:0x0079, B:24:0x008b, B:47:0x0117, B:64:0x014b, B:66:0x0152, B:67:0x0157, B:73:0x0165, B:75:0x0173, B:76:0x0175, B:81:0x018f, B:86:0x01a9, B:88:0x01b7, B:89:0x01b9, B:91:0x01c7, B:92:0x01c9, B:97:0x01df, B:111:0x023a, B:132:0x0295, B:137:0x02a5, B:140:0x02e5, B:145:0x0302, B:144:0x02fe, B:127:0x0288), top: B:157:0x0079 }] */
    /* JADX WARN: Removed duplicated region for block: B:91:0x01c7 A[Catch: RuntimeException -> 0x0336, TryCatch #1 {RuntimeException -> 0x0336, blocks: (B:23:0x0079, B:24:0x008b, B:47:0x0117, B:64:0x014b, B:66:0x0152, B:67:0x0157, B:73:0x0165, B:75:0x0173, B:76:0x0175, B:81:0x018f, B:86:0x01a9, B:88:0x01b7, B:89:0x01b9, B:91:0x01c7, B:92:0x01c9, B:97:0x01df, B:111:0x023a, B:132:0x0295, B:137:0x02a5, B:140:0x02e5, B:145:0x0302, B:144:0x02fe, B:127:0x0288), top: B:157:0x0079 }] */
    @com.android.internal.annotations.GuardedBy("this")
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    private final boolean startProcessLocked(com.android.server.am.ProcessRecord r30, java.lang.String r31, java.lang.String r32, boolean r33, java.lang.String r34) {
        /*
            Method dump skipped, instructions count: 895
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.startProcessLocked(com.android.server.am.ProcessRecord, java.lang.String, java.lang.String, boolean, java.lang.String):boolean");
    }

    @GuardedBy("this")
    private boolean startProcessLocked(String hostingType, String hostingNameStr, final String entryPoint, final ProcessRecord app, int uid, final int[] gids, final int runtimeFlags, final int mountExternal, String seInfo, final String requiredAbi, final String instructionSet, final String invokeWith, long startTime) {
        app.pendingStart = true;
        app.killedByAm = false;
        app.removed = false;
        app.killed = false;
        if (app.startSeq != 0) {
            Slog.wtf("ActivityManager", "startProcessLocked processName:" + app.processName + " with non-zero startSeq:" + app.startSeq);
        }
        if (app.pid != 0) {
            Slog.wtf("ActivityManager", "startProcessLocked processName:" + app.processName + " with non-zero pid:" + app.pid);
        }
        final long startSeq = 1 + this.mProcStartSeqCounter;
        this.mProcStartSeqCounter = startSeq;
        app.startSeq = startSeq;
        app.setStartParams(uid, hostingType, hostingNameStr, seInfo, startTime);
        if (this.mConstants.FLAG_PROCESS_START_ASYNC) {
            if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                Slog.i("ActivityManager", "Posting procStart msg for " + app.toShortString());
            }
            this.mProcStartHandler.post(new Runnable() { // from class: com.android.server.am.-$$Lambda$ActivityManagerService$UgpguyCBuObHjnmry_xkrJGkFi0
                @Override // java.lang.Runnable
                public final void run() {
                    ActivityManagerService.lambda$startProcessLocked$0(ActivityManagerService.this, app, startSeq, invokeWith, entryPoint, gids, runtimeFlags, mountExternal, requiredAbi, instructionSet);
                }
            });
            return true;
        }
        try {
            Process.ProcessStartResult startResult = startProcess(hostingType, entryPoint, app, uid, gids, runtimeFlags, mountExternal, seInfo, requiredAbi, instructionSet, invokeWith, startTime);
            handleProcessStartedLocked(app, startResult.pid, startResult.usingWrapper, startSeq, false);
        } catch (RuntimeException e) {
            Slog.e("ActivityManager", "Failure starting process " + app.processName, e);
            app.pendingStart = false;
            forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
        }
        if (app.pid > 0) {
            return true;
        }
        return false;
    }

    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Removed duplicated region for block: B:58:0x007e A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /* JADX WARN: Type inference failed for: r11v0, types: [long] */
    /* JADX WARN: Type inference failed for: r11v1 */
    /* JADX WARN: Type inference failed for: r11v4 */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public static /* synthetic */ void lambda$startProcessLocked$0(com.android.server.am.ActivityManagerService r20, com.android.server.am.ProcessRecord r21, long r22, java.lang.String r24, java.lang.String r25, int[] r26, int r27, int r28, java.lang.String r29, java.lang.String r30) {
        /*
            Method dump skipped, instructions count: 257
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.lambda$startProcessLocked$0(com.android.server.am.ActivityManagerService, com.android.server.am.ProcessRecord, long, java.lang.String, java.lang.String, int[], int, int, java.lang.String, java.lang.String):void");
    }

    private Process.ProcessStartResult startProcess(String hostingType, String entryPoint, ProcessRecord app, int uid, int[] gids, int runtimeFlags, int mountExternal, String seInfo, String requiredAbi, String instructionSet, String invokeWith, long startTime) {
        Process.ProcessStartResult startResult;
        try {
            Trace.traceBegin(64L, "Start proc: " + app.processName);
            checkTime(startTime, "startProcess: asking zygote to start proc");
        } catch (Throwable th) {
            th = th;
        }
        try {
            if (hostingType.equals("webview_service")) {
                String str = app.processName;
                int i = app.info.targetSdkVersion;
                String str2 = app.info.dataDir;
                startResult = Process.startWebView(entryPoint, str, uid, uid, gids, runtimeFlags, mountExternal, i, seInfo, requiredAbi, instructionSet, str2, null, new String[]{"seq=" + app.startSeq});
            } else {
                String str3 = app.processName;
                int i2 = app.info.targetSdkVersion;
                String str4 = app.info.dataDir;
                startResult = Process.start(entryPoint, str3, uid, uid, gids, runtimeFlags, mountExternal, i2, seInfo, requiredAbi, instructionSet, str4, invokeWith, new String[]{"seq=" + app.startSeq});
            }
            checkTime(startTime, "startProcess: returned from zygote!");
            Trace.traceEnd(64L);
            return startResult;
        } catch (Throwable th2) {
            th = th2;
            Trace.traceEnd(64L);
            throw th;
        }
    }

    @GuardedBy("this")
    private String isProcStartValidLocked(ProcessRecord app, long expectedStartSeq) {
        if (app.killedByAm) {
            sb = 0 == 0 ? new StringBuilder() : null;
            sb.append("killedByAm=true;");
        }
        if (this.mProcessNames.get(app.processName, app.uid) != app) {
            if (sb == null) {
                sb = new StringBuilder();
            }
            sb.append("No entry in mProcessNames;");
        }
        if (!app.pendingStart) {
            if (sb == null) {
                sb = new StringBuilder();
            }
            sb.append("pendingStart=false;");
        }
        if (app.startSeq > expectedStartSeq) {
            if (sb == null) {
                sb = new StringBuilder();
            }
            sb.append("seq=" + app.startSeq + ",expected=" + expectedStartSeq + ";");
        }
        if (sb == null) {
            return null;
        }
        return sb.toString();
    }

    @GuardedBy("this")
    private boolean handleProcessStartedLocked(ProcessRecord pending, Process.ProcessStartResult startResult, long expectedStartSeq) {
        if (this.mPendingStarts.get(expectedStartSeq) == null) {
            if (pending.pid == startResult.pid) {
                pending.usingWrapper = startResult.usingWrapper;
                return false;
            }
            return false;
        }
        return handleProcessStartedLocked(pending, startResult.pid, startResult.usingWrapper, expectedStartSeq, false);
    }

    @GuardedBy("this")
    private boolean handleProcessStartedLocked(ProcessRecord app, int pid, boolean usingWrapper, long expectedStartSeq, boolean procAttached) {
        ProcessRecord oldApp;
        this.mPendingStarts.remove(expectedStartSeq);
        String reason = isProcStartValidLocked(app, expectedStartSeq);
        if (reason != null) {
            Slog.w("ActivityManager", app + " start not valid, killing pid=" + pid + ", " + reason);
            app.pendingStart = false;
            Process.killProcessQuiet(pid);
            Process.killProcessGroup(app.uid, app.pid);
            return false;
        }
        this.mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(app.startTime, "startProcess: done updating battery stats");
        Object[] objArr = new Object[6];
        objArr[0] = Integer.valueOf(UserHandle.getUserId(app.startUid));
        objArr[1] = Integer.valueOf(pid);
        objArr[2] = Integer.valueOf(app.startUid);
        objArr[3] = app.processName;
        objArr[4] = app.hostingType;
        objArr[5] = app.hostingNameStr != null ? app.hostingNameStr : BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
        EventLog.writeEvent((int) EventLogTags.AM_PROC_START, objArr);
        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, app.seInfo, app.info.sourceDir, pid);
        } catch (RemoteException e) {
        }
        StringBuilder bootbuf = new StringBuilder();
        bootbuf.setLength(0);
        bootbuf.append("Start proc: [");
        bootbuf.append(app.hostingType);
        bootbuf.append("]:[");
        bootbuf.append(app.processName);
        if (app.hostingNameStr != null) {
            bootbuf.append("]:[");
            bootbuf.append(app.hostingNameStr);
        }
        bootbuf.append("]:pid:");
        bootbuf.append(pid);
        if (app.persistent) {
            bootbuf.append(":(persistent)");
        }
        BootEvent.addBootEvent(bootbuf.toString());
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, pid);
        }
        checkTime(app.startTime, "startProcess: building log message");
        StringBuilder buf = this.mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, app.startUid);
        if (app.isolatedEntryPoint != null) {
            buf.append(" [");
            buf.append(app.isolatedEntryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(app.hostingType);
        if (app.hostingNameStr != null) {
            buf.append(" ");
            buf.append(app.hostingNameStr);
        }
        reportUidInfoMessageLocked("ActivityManager", buf.toString(), app.startUid);
        app.setPid(pid);
        app.usingWrapper = usingWrapper;
        app.pendingStart = false;
        checkTime(app.startTime, "startProcess: starting to update pids map");
        synchronized (this.mPidsSelfLocked) {
            try {
                oldApp = this.mPidsSelfLocked.get(pid);
            } catch (Throwable th) {
                th = th;
                while (true) {
                    try {
                        break;
                    } catch (Throwable th2) {
                        th = th2;
                    }
                }
                throw th;
            }
        }
        if (oldApp != null && !app.isolated) {
            Slog.wtf("ActivityManager", "handleProcessStartedLocked process:" + app.processName + " startSeq:" + app.startSeq + " pid:" + pid + " belongs to another existing app:" + oldApp.processName + " startSeq:" + oldApp.startSeq);
            cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
        }
        synchronized (this.mPidsSelfLocked) {
            this.mPidsSelfLocked.put(pid, app);
            if (!procAttached) {
                Message msg = this.mHandler.obtainMessage(20);
                msg.obj = app;
                this.mHandler.sendMessageDelayed(msg, usingWrapper ? 1200000L : JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
            }
        }
        checkTime(app.startTime, "startProcess: done updating pids map");
        return true;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void updateUsageStats(ActivityRecord component, boolean resumed) {
        int i;
        if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
            Slog.d("ActivityManager", "updateUsageStats: comp=" + component + "res=" + resumed);
        }
        BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
        int i2 = component.app.uid;
        String packageName = component.realActivity.getPackageName();
        String shortClassName = component.realActivity.getShortClassName();
        if (resumed) {
            i = 1;
        } else {
            i = 0;
        }
        StatsLog.write(42, i2, packageName, shortClassName, i);
        if (resumed) {
            if (component.realActivity.getPackageName().equals("com.andromeda.androbench2")) {
                Slog.d("ActivityManager", "updateUsageStats:resume androbench ");
                mSpecificAppPerfHint.perfHint(4228, component.app.processName, -1, 3);
            }
            if (this.mUsageStatsService != null) {
                this.mUsageStatsService.reportEvent(component.realActivity, component.userId, 1);
            }
            synchronized (stats) {
                stats.noteActivityResumedLocked(component.app.uid);
            }
            return;
        }
        if (component.realActivity.getPackageName().equals("com.andromeda.androbench2")) {
            Slog.d("ActivityManager", "updateUsageStats:pause androbench ");
            mSpecificAppPerfHint.perfLockRelease();
        }
        if (this.mUsageStatsService != null) {
            this.mUsageStatsService.reportEvent(component.realActivity, component.userId, 2);
        }
        synchronized (stats) {
            stats.noteActivityPausedLocked(component.app.uid);
        }
    }

    Intent getHomeIntent() {
        Intent intent = new Intent(this.mTopAction, this.mTopData != null ? Uri.parse(this.mTopData) : null);
        intent.setComponent(this.mTopComponent);
        intent.addFlags(256);
        if (this.mFactoryTest != 1) {
            intent.addCategory("android.intent.category.HOME");
        }
        return intent;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean startHomeActivityLocked(int userId, String reason) {
        if (this.mFactoryTest == 1 && this.mTopAction == null) {
            return false;
        }
        Intent intent = getHomeIntent();
        ActivityInfo aInfo = resolveActivityInfo(intent, 1024, userId);
        if (aInfo != null) {
            intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
            ActivityInfo aInfo2 = new ActivityInfo(aInfo);
            aInfo2.applicationInfo = getAppInfoForUser(aInfo2.applicationInfo, userId);
            ProcessRecord app = getProcessRecordLocked(aInfo2.processName, aInfo2.applicationInfo.uid, true);
            if (app == null || app.instr == null) {
                intent.setFlags(intent.getFlags() | 268435456);
                int resolvedUserId = UserHandle.getUserId(aInfo2.applicationInfo.uid);
                String myReason = reason + ":" + userId + ":" + resolvedUserId;
                this.mActivityStartController.startHomeActivity(intent, aInfo2, myReason);
            }
        } else {
            Slog.wtf("ActivityManager", "No home screen found for " + intent, new Throwable());
        }
        return true;
    }

    private ActivityInfo resolveActivityInfo(Intent intent, int flags, int userId) {
        ActivityInfo ai = null;
        ComponentName comp = intent.getComponent();
        try {
            if (comp != null) {
                ai = AppGlobals.getPackageManager().getActivityInfo(comp, flags, userId);
            } else {
                ResolveInfo info = AppGlobals.getPackageManager().resolveIntent(intent, intent.resolveTypeIfNeeded(this.mContext.getContentResolver()), flags, userId);
                if (info != null) {
                    ai = info.activityInfo;
                }
            }
        } catch (RemoteException e) {
        }
        return ai;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean getCheckedForSetup() {
        return this.mCheckedForSetup;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void setCheckedForSetup(boolean checked) {
        this.mCheckedForSetup = checked;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public CompatibilityInfo compatibilityInfoForPackageLocked(ApplicationInfo ai) {
        return this.mCompatModePackages.compatibilityInfoForPackageLocked(ai);
    }

    void enforceNotIsolatedCaller(String caller) {
        if (UserHandle.isIsolated(Binder.getCallingUid())) {
            throw new SecurityException("Isolated process not allowed to call " + caller);
        }
    }

    public int getFrontActivityScreenCompatMode() {
        int frontActivityScreenCompatModeLocked;
        enforceNotIsolatedCaller("getFrontActivityScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                frontActivityScreenCompatModeLocked = this.mCompatModePackages.getFrontActivityScreenCompatModeLocked();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return frontActivityScreenCompatModeLocked;
    }

    public void setFrontActivityScreenCompatMode(int mode) {
        enforceCallingPermission("android.permission.SET_SCREEN_COMPATIBILITY", "setFrontActivityScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCompatModePackages.setFrontActivityScreenCompatModeLocked(mode);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public int getPackageScreenCompatMode(String packageName) {
        int packageScreenCompatModeLocked;
        enforceNotIsolatedCaller("getPackageScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                packageScreenCompatModeLocked = this.mCompatModePackages.getPackageScreenCompatModeLocked(packageName);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return packageScreenCompatModeLocked;
    }

    public void setPackageScreenCompatMode(String packageName, int mode) {
        enforceCallingPermission("android.permission.SET_SCREEN_COMPATIBILITY", "setPackageScreenCompatMode");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCompatModePackages.setPackageScreenCompatModeLocked(packageName, mode);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean getPackageAskScreenCompat(String packageName) {
        boolean packageAskCompatModeLocked;
        enforceNotIsolatedCaller("getPackageAskScreenCompat");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                packageAskCompatModeLocked = this.mCompatModePackages.getPackageAskCompatModeLocked(packageName);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return packageAskCompatModeLocked;
    }

    public void setPackageAskScreenCompat(String packageName, boolean ask) {
        enforceCallingPermission("android.permission.SET_SCREEN_COMPATIBILITY", "setPackageAskScreenCompat");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCompatModePackages.setPackageAskCompatModeLocked(packageName, ask);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    private boolean hasUsageStatsPermission(String callingPackage) {
        int mode = this.mAppOpsService.noteOperation(43, Binder.getCallingUid(), callingPackage);
        return mode == 3 ? checkCallingPermission("android.permission.PACKAGE_USAGE_STATS") == 0 : mode == 0;
    }

    public int getPackageProcessState(String packageName, String callingPackage) {
        if (!hasUsageStatsPermission(callingPackage)) {
            enforceCallingPermission("android.permission.PACKAGE_USAGE_STATS", "getPackageProcessState");
        }
        int procState = 19;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord proc = this.mLruProcesses.get(i);
                    if (procState > proc.setProcState && (proc.pkgList.containsKey(packageName) || (proc.pkgDeps != null && proc.pkgDeps.contains(packageName)))) {
                        procState = proc.setProcState;
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return procState;
    }

    public boolean setProcessMemoryTrimLevel(String process, int userId, int level) throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord app = findProcessLocked(process, userId, "setProcessMemoryTrimLevel");
                if (app == null) {
                    throw new IllegalArgumentException("Unknown process: " + process);
                } else if (app.thread == null) {
                    throw new IllegalArgumentException("Process has no app thread");
                } else {
                    if (app.trimMemoryLevel >= level) {
                        throw new IllegalArgumentException("Unable to set a higher trim level than current level");
                    }
                    if (level >= 20 && app.curProcState <= 5) {
                        throw new IllegalArgumentException("Unable to set a background trim level on a foreground process");
                    }
                    app.thread.scheduleTrimMemory(level);
                    app.trimMemoryLevel = level;
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return true;
    }

    /* JADX INFO: Access modifiers changed from: private */
    public void dispatchProcessesChanged() {
        int N;
        int j;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                N = this.mPendingProcessChanges.size();
                if (this.mActiveProcessChanges.length < N) {
                    this.mActiveProcessChanges = new ProcessChangeItem[N];
                }
                this.mPendingProcessChanges.toArray(this.mActiveProcessChanges);
                this.mPendingProcessChanges.clear();
                if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                    Slog.i("ActivityManager", "*** Delivering " + N + " process changes");
                }
            } finally {
            }
        }
        resetPriorityAfterLockedSection();
        int i = this.mProcessObservers.beginBroadcast();
        while (true) {
            j = 0;
            if (i <= 0) {
                break;
            }
            i--;
            IProcessObserver observer = this.mProcessObservers.getBroadcastItem(i);
            if (observer != null) {
                while (j < N) {
                    try {
                        ProcessChangeItem item = this.mActiveProcessChanges[j];
                        if ((item.changes & 1) != 0) {
                            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                                Slog.i("ActivityManager", "ACTIVITIES CHANGED pid=" + item.pid + " uid=" + item.uid + ": " + item.foregroundActivities);
                            }
                            observer.onForegroundActivitiesChanged(item.pid, item.uid, item.foregroundActivities);
                        }
                        j++;
                    } catch (RemoteException e) {
                    }
                }
            }
        }
        this.mProcessObservers.finishBroadcast();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                while (j < N) {
                    this.mAvailProcessChanges.add(this.mActiveProcessChanges[j]);
                    j++;
                }
            } finally {
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: private */
    public void dispatchProcessDied(int pid, int uid) {
        int i = this.mProcessObservers.beginBroadcast();
        while (i > 0) {
            i--;
            IProcessObserver observer = this.mProcessObservers.getBroadcastItem(i);
            if (observer != null) {
                try {
                    observer.onProcessDied(pid, uid);
                } catch (RemoteException e) {
                }
            }
        }
        this.mProcessObservers.finishBroadcast();
    }

    @VisibleForTesting
    void dispatchUidsChanged() {
        int N;
        int j;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                N = this.mPendingUidChanges.size();
                if (this.mActiveUidChanges.length < N) {
                    this.mActiveUidChanges = new UidRecord.ChangeItem[N];
                }
                for (int i = 0; i < N; i++) {
                    UidRecord.ChangeItem change = this.mPendingUidChanges.get(i);
                    this.mActiveUidChanges[i] = change;
                    if (change.uidRecord != null) {
                        change.uidRecord.pendingChange = null;
                        change.uidRecord = null;
                    }
                }
                this.mPendingUidChanges.clear();
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i("ActivityManager", "*** Delivering " + N + " uid changes");
                }
            } finally {
            }
        }
        resetPriorityAfterLockedSection();
        this.mUidChangeDispatchCount += N;
        int i2 = this.mUidObservers.beginBroadcast();
        while (i2 > 0) {
            i2--;
            dispatchUidsChangedForObserver(this.mUidObservers.getBroadcastItem(i2), (UidObserverRegistration) this.mUidObservers.getBroadcastCookie(i2), N);
        }
        this.mUidObservers.finishBroadcast();
        if (this.mUidObservers.getRegisteredCallbackCount() > 0) {
            for (int j2 = 0; j2 < N; j2++) {
                UidRecord.ChangeItem item = this.mActiveUidChanges[j2];
                if ((item.change & 1) != 0) {
                    this.mValidateUids.remove(item.uid);
                } else {
                    UidRecord validateUid = this.mValidateUids.get(item.uid);
                    if (validateUid == null) {
                        validateUid = new UidRecord(item.uid);
                        this.mValidateUids.put(item.uid, validateUid);
                    }
                    if ((item.change & 2) != 0) {
                        validateUid.idle = true;
                    } else if ((item.change & 4) != 0) {
                        validateUid.idle = false;
                    }
                    int i3 = item.processState;
                    validateUid.setProcState = i3;
                    validateUid.curProcState = i3;
                    validateUid.lastDispatchedProcStateSeq = item.procStateSeq;
                }
            }
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                for (j = 0; j < N; j++) {
                    this.mAvailUidChanges.add(this.mActiveUidChanges[j]);
                }
            } finally {
            }
        }
        resetPriorityAfterLockedSection();
    }

    private void dispatchUidsChangedForObserver(IUidObserver observer, UidObserverRegistration reg, int changesSize) {
        boolean z;
        boolean lastAboveCut;
        boolean newAboveCut;
        boolean z2;
        if (observer == null) {
            return;
        }
        for (int j = 0; j < changesSize; j++) {
            try {
                UidRecord.ChangeItem item = this.mActiveUidChanges[j];
                int change = item.change;
                if (change != 0 || (reg.which & 1) != 0) {
                    long start = SystemClock.uptimeMillis();
                    if ((change & 2) != 0) {
                        if ((reg.which & 4) != 0) {
                            if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                Slog.i("ActivityManager", "UID idle uid=" + item.uid);
                            }
                            observer.onUidIdle(item.uid, item.ephemeral);
                        }
                    } else if ((change & 4) != 0 && (reg.which & 8) != 0) {
                        if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                            Slog.i("ActivityManager", "UID active uid=" + item.uid);
                        }
                        observer.onUidActive(item.uid);
                    }
                    if ((reg.which & 16) != 0) {
                        if ((change & 8) != 0) {
                            if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                Slog.i("ActivityManager", "UID cached uid=" + item.uid);
                            }
                            observer.onUidCachedChanged(item.uid, true);
                        } else if ((change & 16) != 0) {
                            if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                Slog.i("ActivityManager", "UID active uid=" + item.uid);
                            }
                            observer.onUidCachedChanged(item.uid, false);
                        }
                    }
                    if ((change & 1) == 0) {
                        if ((reg.which & 1) != 0) {
                            if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                Slog.i("ActivityManager", "UID CHANGED uid=" + item.uid + ": " + item.processState);
                            }
                            boolean doReport = true;
                            if (reg.cutpoint >= 0) {
                                int lastState = reg.lastProcStates.get(item.uid, -1);
                                if (lastState != -1) {
                                    if (lastState > reg.cutpoint) {
                                        lastAboveCut = false;
                                    } else {
                                        lastAboveCut = true;
                                    }
                                    if (item.processState > reg.cutpoint) {
                                        newAboveCut = false;
                                    } else {
                                        newAboveCut = true;
                                    }
                                    if (lastAboveCut == newAboveCut) {
                                        z2 = false;
                                    } else {
                                        z2 = true;
                                    }
                                    doReport = z2;
                                } else {
                                    if (item.processState == 19) {
                                        z = false;
                                    } else {
                                        z = true;
                                    }
                                    doReport = z;
                                }
                            }
                            if (doReport) {
                                if (reg.lastProcStates != null) {
                                    reg.lastProcStates.put(item.uid, item.processState);
                                }
                                observer.onUidStateChanged(item.uid, item.processState, item.procStateSeq);
                            }
                        }
                    } else {
                        if ((reg.which & 2) != 0) {
                            if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                Slog.i("ActivityManager", "UID gone uid=" + item.uid);
                            }
                            observer.onUidGone(item.uid, item.ephemeral);
                        }
                        if (reg.lastProcStates != null) {
                            reg.lastProcStates.delete(item.uid);
                        }
                    }
                    int duration = (int) (SystemClock.uptimeMillis() - start);
                    if (reg.mMaxDispatchTime < duration) {
                        reg.mMaxDispatchTime = duration;
                    }
                    if (duration >= 20) {
                        reg.mSlowDispatchCount++;
                    }
                }
            } catch (RemoteException e) {
                return;
            }
        }
    }

    void dispatchOomAdjObserver(String msg) {
        OomAdjObserver observer;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                observer = this.mCurOomAdjObserver;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (observer != null) {
            observer.onOomAdjMessage(msg);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void setOomAdjObserver(int uid, OomAdjObserver observer) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCurOomAdjUid = uid;
                this.mCurOomAdjObserver = observer;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void clearOomAdjObserver() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mCurOomAdjUid = -1;
                this.mCurOomAdjObserver = null;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    void reportOomAdjMessageLocked(String tag, String msg) {
        Slog.d(tag, msg);
        if (this.mCurOomAdjObserver != null) {
            this.mUiHandler.obtainMessage(70, msg).sendToTarget();
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void reportUidInfoMessageLocked(String tag, String msg, int uid) {
        Slog.i("ActivityManager", msg);
        if (this.mCurOomAdjObserver != null && uid == this.mCurOomAdjUid) {
            this.mUiHandler.obtainMessage(70, msg).sendToTarget();
        }
    }

    public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());
    }

    public int startXpApp(String pkgName, Intent intent) {
        return 0;
    }

    public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId, true);
    }

    public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser) {
        enforceNotIsolatedCaller("startActivity");
        Intent intent2 = intent;
        Bundle bOptions2 = bOptions;
        xpActivityManager.ActivityRecordInfo ari = xpActivityManager.getOverrideActivityRecord(intent2, bOptions2);
        if (ari != null) {
            intent2 = ari.intent != null ? ari.intent : intent2;
            bOptions2 = ari.options != null ? ari.options : bOptions2;
        }
        int ret = this.mActivityStartController.obtainStarter(intent2, "startActivityAsUser").setCaller(caller).setCallingPackage(callingPackage).setResolvedType(resolvedType).setResultTo(resultTo).setResultWho(resultWho).setRequestCode(requestCode).setStartFlags(startFlags).setProfilerInfo(profilerInfo).setActivityOptions(bOptions2).setMayWait(this.mActivityStartController.checkTargetUser(userId, validateIncomingUser, Binder.getCallingPid(), Binder.getCallingUid(), "startActivityAsUser")).execute();
        overridePendingTransition(resultTo, callingPackage, 17432576, 17432577);
        return ret;
    }

    /* JADX WARN: Code restructure failed: missing block: B:21:0x0065, code lost:
        if (r19.getComponent() == null) goto L29;
     */
    /* JADX WARN: Code restructure failed: missing block: B:23:0x006b, code lost:
        if (r19.getSelector() != null) goto L27;
     */
    /* JADX WARN: Code restructure failed: missing block: B:26:0x0075, code lost:
        throw new java.lang.SecurityException("Selector not allowed with ignoreTargetSecurity");
     */
    /* JADX WARN: Code restructure failed: missing block: B:28:0x007d, code lost:
        throw new java.lang.SecurityException("Component must be specified with ignoreTargetSecurity");
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public final int startActivityAsCaller(android.app.IApplicationThread r17, java.lang.String r18, android.content.Intent r19, java.lang.String r20, android.os.IBinder r21, java.lang.String r22, int r23, int r24, android.app.ProfilerInfo r25, android.os.Bundle r26, boolean r27, int r28) {
        /*
            Method dump skipped, instructions count: 382
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.startActivityAsCaller(android.app.IApplicationThread, java.lang.String, android.content.Intent, java.lang.String, android.os.IBinder, java.lang.String, int, int, android.app.ProfilerInfo, android.os.Bundle, boolean, int):int");
    }

    public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("startActivityAndWait");
        int userId2 = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivityAndWait", null);
        WaitResult res = new WaitResult();
        this.mActivityStartController.obtainStarter(intent, "startActivityAndWait").setCaller(caller).setCallingPackage(callingPackage).setResolvedType(resolvedType).setResultTo(resultTo).setResultWho(resultWho).setRequestCode(requestCode).setStartFlags(startFlags).setActivityOptions(bOptions).setMayWait(userId2).setProfilerInfo(profilerInfo).setWaitResult(res).execute();
        return res;
    }

    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, Configuration config, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("startActivityWithConfig");
        return this.mActivityStartController.obtainStarter(intent, "startActivityWithConfig").setCaller(caller).setCallingPackage(callingPackage).setResolvedType(resolvedType).setResultTo(resultTo).setResultWho(resultWho).setRequestCode(requestCode).setStartFlags(startFlags).setGlobalConfiguration(config).setActivityOptions(bOptions).setMayWait(this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivityWithConfig", null)).execute();
    }

    public int startActivityIntentSender(IApplicationThread caller, IIntentSender target, IBinder whitelistToken, Intent fillInIntent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle bOptions) throws TransactionTooLargeException {
        enforceNotIsolatedCaller("startActivityIntentSender");
        if (fillInIntent != null && fillInIntent.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        if (!(target instanceof PendingIntentRecord)) {
            throw new IllegalArgumentException("Bad PendingIntent object");
        }
        PendingIntentRecord pir = (PendingIntentRecord) target;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = getFocusedStack();
                if (stack.mResumedActivity != null && stack.mResumedActivity.info.applicationInfo.uid == Binder.getCallingUid()) {
                    this.mAppSwitchesAllowedTime = 0L;
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        int ret = pir.sendInner(0, fillInIntent, resolvedType, whitelistToken, null, null, resultTo, resultWho, requestCode, flagsMask, flagsValues, bOptions);
        return ret;
    }

    public int startVoiceActivity(String callingPackage, int callingPid, int callingUid, Intent intent, String resolvedType, IVoiceInteractionSession session, IVoiceInteractor interactor, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        enforceCallingPermission("android.permission.BIND_VOICE_INTERACTION", "startVoiceActivity()");
        if (session == null || interactor == null) {
            throw new NullPointerException("null session or interactor");
        }
        return this.mActivityStartController.obtainStarter(intent, "startVoiceActivity").setCallingUid(callingUid).setCallingPackage(callingPackage).setResolvedType(resolvedType).setVoiceSession(session).setVoiceInteractor(interactor).setStartFlags(startFlags).setProfilerInfo(profilerInfo).setActivityOptions(bOptions).setMayWait(this.mUserController.handleIncomingUser(callingPid, callingUid, userId, false, 2, "startVoiceActivity", null)).execute();
    }

    public int startAssistantActivity(String callingPackage, int callingPid, int callingUid, Intent intent, String resolvedType, Bundle bOptions, int userId) {
        enforceCallingPermission("android.permission.BIND_VOICE_INTERACTION", "startAssistantActivity()");
        return this.mActivityStartController.obtainStarter(intent, "startAssistantActivity").setCallingUid(callingUid).setCallingPackage(callingPackage).setResolvedType(resolvedType).setActivityOptions(bOptions).setMayWait(this.mUserController.handleIncomingUser(callingPid, callingUid, userId, false, 2, "startAssistantActivity", null)).execute();
    }

    public void startRecentsActivity(Intent intent, IAssistDataReceiver assistDataReceiver, IRecentsAnimationRunner recentsAnimationRunner) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "startRecentsActivity()");
        int callingPid = Binder.getCallingPid();
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ComponentName recentsComponent = this.mRecentTasks.getRecentsComponent();
                int recentsUid = this.mRecentTasks.getRecentsComponentUid();
                RecentsAnimation anim = new RecentsAnimation(this, this.mStackSupervisor, this.mActivityStartController, this.mWindowManager, this.mUserController, callingPid);
                anim.startRecentsActivity(intent, recentsAnimationRunner, recentsComponent, recentsUid, assistDataReceiver);
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public void cancelRecentsAnimation(boolean restoreHomeStackPosition) {
        int i;
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "cancelRecentsAnimation()");
        long callingUid = Binder.getCallingUid();
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                WindowManagerService windowManagerService = this.mWindowManager;
                if (restoreHomeStackPosition) {
                    i = 2;
                } else {
                    i = 0;
                }
                windowManagerService.cancelRecentsAnimationSynchronously(i, "cancelRecentsAnimation/uid=" + callingUid);
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public void startLocalVoiceInteraction(IBinder callingActivity, Bundle options) throws RemoteException {
        Slog.i("ActivityManager", "Activity tried to startVoiceInteraction");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord activity = getFocusedStack().getTopActivity();
                if (ActivityRecord.forTokenLocked(callingActivity) != activity) {
                    throw new SecurityException("Only focused activity can call startVoiceInteraction");
                }
                if (this.mRunningVoice == null && activity.getTask().voiceSession == null && activity.voiceSession == null) {
                    if (activity.pendingVoiceInteractionStart) {
                        Slog.w("ActivityManager", "Pending start of voice interaction already.");
                        resetPriorityAfterLockedSection();
                        return;
                    }
                    activity.pendingVoiceInteractionStart = true;
                    resetPriorityAfterLockedSection();
                    ((VoiceInteractionManagerInternal) LocalServices.getService(VoiceInteractionManagerInternal.class)).startLocalVoiceInteraction(callingActivity, options);
                    return;
                }
                Slog.w("ActivityManager", "Already in a voice interaction, cannot start new voice interaction");
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void stopLocalVoiceInteraction(IBinder callingActivity) throws RemoteException {
        ((VoiceInteractionManagerInternal) LocalServices.getService(VoiceInteractionManagerInternal.class)).stopLocalVoiceInteraction(callingActivity);
    }

    public boolean supportsLocalVoiceInteraction() throws RemoteException {
        return ((VoiceInteractionManagerInternal) LocalServices.getService(VoiceInteractionManagerInternal.class)).supportsLocalVoiceInteraction();
    }

    @GuardedBy("this")
    void onLocalVoiceInteractionStartedLocked(IBinder activity, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {
        ActivityRecord activityToCallback = ActivityRecord.forTokenLocked(activity);
        if (activityToCallback == null) {
            return;
        }
        activityToCallback.setVoiceSessionLocked(voiceSession);
        try {
            activityToCallback.app.thread.scheduleLocalVoiceInteractionStarted(activity, voiceInteractor);
            long token = Binder.clearCallingIdentity();
            startRunningVoiceLocked(voiceSession, activityToCallback.appInfo.uid);
            Binder.restoreCallingIdentity(token);
        } catch (RemoteException e) {
            activityToCallback.clearVoiceSessionLocked();
        }
    }

    public void setVoiceKeepAwake(IVoiceInteractionSession session, boolean keepAwake) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mRunningVoice != null && this.mRunningVoice.asBinder() == session.asBinder()) {
                    if (keepAwake) {
                        this.mVoiceWakeLock.acquire();
                    } else {
                        this.mVoiceWakeLock.release();
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX WARN: Code restructure failed: missing block: B:38:0x00a0, code lost:
        r11 = r11 + 1;
     */
    /* JADX WARN: Code restructure failed: missing block: B:39:0x00a1, code lost:
        if (r11 >= r10) goto L41;
     */
    /* JADX WARN: Code restructure failed: missing block: B:40:0x00a3, code lost:
        r9 = r0.get(r11).activityInfo;
     */
    /* JADX WARN: Code restructure failed: missing block: B:41:0x00ac, code lost:
        if (r8 == false) goto L48;
     */
    /* JADX WARN: Code restructure failed: missing block: B:42:0x00ae, code lost:
        android.util.Slog.v("ActivityManager", "Next matching activity: found current " + r0.packageName + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r0.info.name);
        r14 = new java.lang.StringBuilder();
        r14.append("Next matching activity: next is ");
     */
    /* JADX WARN: Code restructure failed: missing block: B:43:0x00de, code lost:
        if (r9 != null) goto L47;
     */
    /* JADX WARN: Code restructure failed: missing block: B:44:0x00e0, code lost:
        r15 = "null";
     */
    /* JADX WARN: Code restructure failed: missing block: B:45:0x00e4, code lost:
        r15 = r9.packageName + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r9.name;
     */
    /* JADX WARN: Code restructure failed: missing block: B:46:0x00fc, code lost:
        r14.append(r15);
        android.util.Slog.v("ActivityManager", r14.toString());
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public boolean startNextMatchingActivity(android.os.IBinder r18, android.content.Intent r19, android.os.Bundle r20) {
        /*
            Method dump skipped, instructions count: 448
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.startNextMatchingActivity(android.os.IBinder, android.content.Intent, android.os.Bundle):boolean");
    }

    public final int startActivityFromRecents(int taskId, Bundle bOptions) {
        int startActivityFromRecents;
        enforceCallerIsRecentsOrHasPermission("android.permission.START_TASKS_FROM_RECENTS", "startActivityFromRecents()");
        int callingPid = Binder.getCallingPid();
        int callingUid = Binder.getCallingUid();
        SafeActivityOptions safeOptions = SafeActivityOptions.fromBundle(bOptions);
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                startActivityFromRecents = this.mStackSupervisor.startActivityFromRecents(callingPid, callingUid, taskId, safeOptions);
            }
            resetPriorityAfterLockedSection();
            return startActivityFromRecents;
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public final int startActivities(IApplicationThread caller, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("startActivities");
        int ret = this.mActivityStartController.startActivities(caller, -1, 0, -10000, callingPackage, intents, resolvedTypes, resultTo, SafeActivityOptions.fromBundle(bOptions), this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startActivities", null), "startActivities", null);
        return ret;
    }

    public void reportActivityFullyDrawn(IBinder token, boolean restoredFromBundle) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                r.reportFullyDrawnLocked(restoredFromBundle);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void setRequestedOrientation(IBinder token, int requestedOrientation) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                long origId = Binder.clearCallingIdentity();
                r.setRequestedOrientation(requestedOrientation);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public int getRequestedOrientation(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return -1;
                }
                int requestedOrientation = r.getRequestedOrientation();
                resetPriorityAfterLockedSection();
                return requestedOrientation;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public final boolean finishActivity(IBinder token, int resultCode, Intent resultData, int finishTask) {
        IBinder iBinder;
        long origId;
        boolean res;
        if (resultData != null && resultData.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return true;
                }
                TaskRecord tr = r.getTask();
                ActivityRecord rootR = tr.getRootActivity();
                if (rootR == null) {
                    Slog.w("ActivityManager", "Finishing task with all activities already finished");
                }
                if (this.mLockTaskController.activityBlockedFromFinish(r)) {
                    resetPriorityAfterLockedSection();
                    return false;
                }
                if (this.mController != null) {
                    iBinder = token;
                    try {
                        ActivityRecord next = r.getStack().topRunningActivityLocked(iBinder, 0);
                        if (next != null) {
                            boolean resumeOK = true;
                            try {
                                resumeOK = this.mController.activityResuming(next.packageName);
                            } catch (RemoteException e) {
                                this.mController = null;
                                Watchdog.getInstance().setActivityController(null);
                            }
                            if (!resumeOK) {
                                Slog.i("ActivityManager", "Not finishing activity because controller resumed");
                                resetPriorityAfterLockedSection();
                                return false;
                            }
                        }
                    } catch (Throwable th) {
                        th = th;
                        resetPriorityAfterLockedSection();
                        throw th;
                    }
                } else {
                    iBinder = token;
                }
                long origId2 = Binder.clearCallingIdentity();
                boolean finishWithRootActivity = finishTask == 1;
                try {
                    if (finishTask == 2) {
                        origId = origId2;
                    } else if (!finishWithRootActivity || r != rootR) {
                        try {
                            origId = origId2;
                            res = tr.getStack().requestFinishActivityLocked(iBinder, resultCode, resultData, "app-request", true);
                            if (!res) {
                                Slog.i("ActivityManager", "Failed to finish by app-request");
                            }
                            Binder.restoreCallingIdentity(origId);
                            resetPriorityAfterLockedSection();
                            return res;
                        } catch (Throwable th2) {
                            th = th2;
                            origId = origId2;
                            Binder.restoreCallingIdentity(origId);
                            throw th;
                        }
                    } else {
                        origId = origId2;
                    }
                    res = this.mStackSupervisor.removeTaskByIdLocked(tr.taskId, false, finishWithRootActivity, "finish-activity");
                    if (!res) {
                        Slog.i("ActivityManager", "Removing task failed to finish activity");
                    }
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return res;
                } catch (Throwable th3) {
                    th = th3;
                }
            } catch (Throwable th4) {
                th = th4;
            }
        }
    }

    public final void finishHeavyWeightApp() {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: finishHeavyWeightApp() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.FORCE_STOP_PACKAGES";
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord proc = this.mHeavyWeightProcess;
                if (proc == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                ArrayList<ActivityRecord> activities = new ArrayList<>(proc.activities);
                for (int i = 0; i < activities.size(); i++) {
                    ActivityRecord r = activities.get(i);
                    if (!r.finishing && r.isInStackLocked()) {
                        r.getStack().finishActivityLocked(r, 0, null, "finish-heavy", true);
                    }
                }
                this.mHandler.sendMessage(this.mHandler.obtainMessage(25, proc.userId, 0));
                this.mHeavyWeightProcess = null;
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void crashApplication(int uid, int initialPid, String packageName, int userId, String message) {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: crashApplication() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.FORCE_STOP_PACKAGES";
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mAppErrors.scheduleAppCrashLocked(uid, initialPid, packageName, userId, message);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public final void finishSubActivity(IBinder token, String resultWho, int requestCode) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    r.getStack().finishSubActivityLocked(r, resultWho, requestCode);
                }
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean finishActivityAffinity(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return false;
                }
                TaskRecord task = r.getTask();
                if (this.mLockTaskController.activityBlockedFromFinish(r)) {
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return false;
                }
                boolean finishActivityAffinityLocked = task.getStack().finishActivityAffinityLocked(r);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return finishActivityAffinityLocked;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void finishVoiceTask(IVoiceInteractionSession session) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                this.mStackSupervisor.finishVoiceTask(session);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean releaseActivityInstance(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    boolean safelyDestroyActivityLocked = r.getStack().safelyDestroyActivityLocked(r, "app-req");
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return safelyDestroyActivityLocked;
                }
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return false;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void releaseSomeActivities(IApplicationThread appInt) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                ProcessRecord app = getRecordForAppLocked(appInt);
                this.mStackSupervisor.releaseSomeActivitiesLocked(app, "low-mem");
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean willActivityBeVisible(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    boolean willActivityBeVisibleLocked = stack.willActivityBeVisibleLocked(token);
                    resetPriorityAfterLockedSection();
                    return willActivityBeVisibleLocked;
                }
                resetPriorityAfterLockedSection();
                return false;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void overridePendingTransition(IBinder token, String packageName, int enterAnim, int exitAnim) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord self = ActivityRecord.isInStackLocked(token);
                if (self == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                long origId = Binder.clearCallingIdentity();
                if (self.isState(ActivityStack.ActivityState.RESUMED, ActivityStack.ActivityState.PAUSING)) {
                    this.mWindowManager.overridePendingAppTransition(packageName, enterAnim, exitAnim, null);
                }
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    @GuardedBy("this")
    private final void handleAppDiedLocked(ProcessRecord app, boolean restarting, boolean allowRestart) {
        int pid = app.pid;
        if (restarting || !app.removed || !app.foregroundActivities) {
        }
        boolean kept = cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1, false);
        if (!kept && !restarting) {
            removeLruProcessLocked(app);
            if (pid > 0) {
                ProcessList.remove(pid);
            }
        }
        if (this.mProfileProc == app) {
            clearProfilerLocked();
        }
        boolean hasVisibleActivities = this.mStackSupervisor.handleAppDiedLocked(app);
        app.clearRecentTasks();
        app.activities.clear();
        if (app.instr != null) {
            Slog.w("ActivityManager", "Crash of app " + app.processName + " running instrumentation " + app.instr.mClass);
            Bundle info = new Bundle();
            info.putString("shortMsg", "Process crashed.");
            finishInstrumentationLocked(app, 0, info);
        }
        this.mWindowManager.deferSurfaceLayout();
        if (!restarting && hasVisibleActivities) {
            try {
                if (!this.mStackSupervisor.resumeFocusedStackTopActivityLocked()) {
                    this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                }
            } finally {
                this.mWindowManager.continueSurfaceLayout();
            }
        }
    }

    private final int getLRURecordIndexForAppLocked(IApplicationThread thread) {
        IBinder threadBinder = thread.asBinder();
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord rec = this.mLruProcesses.get(i);
            if (rec.thread != null && rec.thread.asBinder() == threadBinder) {
                return i;
            }
        }
        return -1;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public ProcessRecord getRecordForAppLocked(IApplicationThread thread) {
        if (thread == null) {
            return null;
        }
        int appIndex = getLRURecordIndexForAppLocked(thread);
        if (appIndex >= 0) {
            return this.mLruProcesses.get(appIndex);
        }
        IBinder threadBinder = thread.asBinder();
        ArrayMap<String, SparseArray<ProcessRecord>> pmap = this.mProcessNames.getMap();
        for (int i = pmap.size() - 1; i >= 0; i--) {
            SparseArray<ProcessRecord> procs = pmap.valueAt(i);
            for (int j = procs.size() - 1; j >= 0; j--) {
                ProcessRecord proc = procs.valueAt(j);
                if (proc.thread != null && proc.thread.asBinder() == threadBinder) {
                    Slog.wtf("ActivityManager", "getRecordForApp: exists in name list but not in LRU list: " + proc);
                    return proc;
                }
            }
        }
        return null;
    }

    final void doLowMemReportIfNeededLocked(ProcessRecord dyingProc) {
        boolean haveBg = false;
        int i = this.mLruProcesses.size() - 1;
        while (true) {
            if (i < 0) {
                break;
            }
            ProcessRecord rec = this.mLruProcesses.get(i);
            if (rec.thread != null && rec.setProcState >= 15) {
                haveBg = true;
                break;
            }
            i--;
        }
        if (haveBg) {
            return;
        }
        boolean doReport = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
        if (doReport) {
            long now = SystemClock.uptimeMillis();
            if (now < this.mLastMemUsageReportTime + BackupAgentTimeoutParameters.DEFAULT_FULL_BACKUP_AGENT_TIMEOUT_MILLIS) {
                doReport = false;
            } else {
                this.mLastMemUsageReportTime = now;
            }
        }
        ArrayList<ProcessMemInfo> memInfos = doReport ? new ArrayList<>(this.mLruProcesses.size()) : null;
        EventLog.writeEvent((int) EventLogTags.AM_LOW_MEMORY, this.mLruProcesses.size());
        long now2 = SystemClock.uptimeMillis();
        for (int i2 = this.mLruProcesses.size() - 1; i2 >= 0; i2--) {
            ProcessRecord rec2 = this.mLruProcesses.get(i2);
            if (rec2 != dyingProc && rec2.thread != null) {
                if (doReport) {
                    memInfos.add(new ProcessMemInfo(rec2.processName, rec2.pid, rec2.setAdj, rec2.setProcState, rec2.adjType, rec2.makeAdjReason()));
                }
                if (rec2.lastLowMemory + this.mConstants.GC_MIN_INTERVAL <= now2) {
                    if (rec2.setAdj <= 400) {
                        rec2.lastRequestedGc = 0L;
                    } else {
                        rec2.lastRequestedGc = rec2.lastLowMemory;
                    }
                    rec2.reportLowMemory = true;
                    rec2.lastLowMemory = now2;
                    this.mProcessesToGc.remove(rec2);
                    addProcessToGcListLocked(rec2);
                }
            }
        }
        if (doReport) {
            Message msg = this.mHandler.obtainMessage(33, memInfos);
            this.mHandler.sendMessage(msg);
        }
        scheduleAppGcsLocked();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public final void appDiedLocked(ProcessRecord app) {
        appDiedLocked(app, app.pid, app.thread, false);
    }

    @GuardedBy("this")
    final void appDiedLocked(ProcessRecord app, int pid, IApplicationThread thread, boolean fromBinderDied) {
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord curProc = this.mPidsSelfLocked.get(pid);
            if (curProc != app) {
                Slog.w("ActivityManager", "Spurious death for " + app + ", curProc for " + pid + ": " + curProc);
                return;
            }
            Log.d("ActivityManager", "appDiedLocked name=" + app.processName + " pid=" + pid + "  killed=" + app.killed + " killedByAm=" + app.killedByAm + " fromBinderDied=" + fromBinderDied);
            BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
            synchronized (stats) {
                stats.noteProcessDiedLocked(app.info.uid, pid);
            }
            if (!app.killed) {
                if (!fromBinderDied) {
                    Process.killProcessQuiet(pid);
                }
                killProcessGroup(app.uid, pid);
                app.killed = true;
            }
            if (app.pid == pid && app.thread != null && app.thread.asBinder() == thread.asBinder()) {
                boolean doLowMem = app.instr == null;
                boolean doOomAdj = doLowMem;
                if (!app.killedByAm) {
                    reportUidInfoMessageLocked("ActivityManager", "Process " + app.processName + " (pid " + pid + ") has died: " + ProcessList.makeOomAdjString(app.setAdj) + ProcessList.makeProcStateString(app.setProcState), app.info.uid);
                    this.mAllowLowerMemLevel = true;
                } else {
                    this.mAllowLowerMemLevel = false;
                    doLowMem = false;
                }
                EventLog.writeEvent((int) EventLogTags.AM_PROC_DIED, Integer.valueOf(app.userId), Integer.valueOf(app.pid), app.processName, Integer.valueOf(app.setAdj), Integer.valueOf(app.setProcState));
                if (ActivityManagerDebugConfig.DEBUG_CLEANUP) {
                    Slog.v("ActivityManager", "Dying app: " + app + ", pid: " + pid + ", thread: " + thread.asBinder());
                }
                handleAppDiedLocked(app, false, true);
                if (doOomAdj) {
                    updateOomAdjLocked();
                }
                if (doLowMem) {
                    doLowMemReportIfNeededLocked(app);
                }
            } else if (app.pid != pid) {
                reportUidInfoMessageLocked("ActivityManager", "Process " + app.processName + " (pid " + pid + ") has died and restarted (pid " + app.pid + ").", app.info.uid);
                EventLog.writeEvent((int) EventLogTags.AM_PROC_DIED, Integer.valueOf(app.userId), Integer.valueOf(app.pid), app.processName);
            } else if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                Slog.d("ActivityManager", "Received spurious death notification for thread " + thread.asBinder());
            }
            if (!MemoryStatUtil.hasMemcg()) {
                StatsLog.write(65, SystemClock.elapsedRealtime());
            }
        }
    }

    public static File dumpStackTraces(boolean clearTraces, ArrayList<Integer> firstPids, ProcessCpuTracker processCpuTracker, SparseArray<Boolean> lastPids, ArrayList<Integer> nativePids) {
        File tracesFile;
        ArrayList<Integer> extraPids = null;
        if (processCpuTracker != null) {
            processCpuTracker.init();
            try {
                Thread.sleep(NETWORK_ACCESS_TIMEOUT_DEFAULT_MS);
            } catch (InterruptedException e) {
            }
            processCpuTracker.update();
            int N = processCpuTracker.countWorkingStats();
            extraPids = new ArrayList<>();
            for (int i = 0; i < N && extraPids.size() < 5; i++) {
                ProcessCpuTracker.Stats stats = processCpuTracker.getWorkingStats(i);
                if (lastPids.indexOfKey(stats.pid) >= 0) {
                    extraPids.add(Integer.valueOf(stats.pid));
                }
            }
        }
        boolean useTombstonedForJavaTraces = false;
        String tracesDirProp = SystemProperties.get("dalvik.vm.stack-trace-dir", BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
        if (tracesDirProp.isEmpty()) {
            String globalTracesPath = SystemProperties.get("dalvik.vm.stack-trace-file", (String) null);
            if (globalTracesPath.isEmpty()) {
                Slog.w("ActivityManager", "dumpStackTraces: no trace path configured");
                return null;
            }
            tracesFile = new File(globalTracesPath);
            if (clearTraces) {
                try {
                    if (tracesFile.exists()) {
                        tracesFile.delete();
                    }
                } catch (IOException e2) {
                    Slog.w("ActivityManager", "Unable to prepare ANR traces file: " + tracesFile, e2);
                    return null;
                }
            }
            tracesFile.createNewFile();
            FileUtils.setPermissions(globalTracesPath, 438, -1, -1);
        } else {
            File tracesDir = new File(tracesDirProp);
            int oldMaskone = StrictMode.allowThreadDiskReadsMask();
            StrictMode.allowThreadDiskWritesMask();
            try {
                maybePruneOldTraces(tracesDir);
                File tracesFile2 = createAnrDumpFile(tracesDir);
                if (tracesFile2 == null) {
                    return null;
                }
                useTombstonedForJavaTraces = true;
                tracesFile = tracesFile2;
            } finally {
                StrictMode.setThreadPolicyMask(oldMaskone);
            }
        }
        dumpStackTraces(tracesFile.getAbsolutePath(), firstPids, nativePids, extraPids, useTombstonedForJavaTraces);
        return tracesFile;
    }

    /* JADX INFO: Access modifiers changed from: private */
    public static synchronized File createAnrDumpFile(File tracesDir) {
        synchronized (ActivityManagerService.class) {
            boostPriorityForLockedSection();
            if (sAnrFileDateFormat == null) {
                sAnrFileDateFormat = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss-SSS");
            }
            String formattedDate = sAnrFileDateFormat.format(new Date());
            File anrFile = new File(tracesDir, "anr_" + formattedDate);
            try {
            } catch (IOException ioe) {
                Slog.w("ActivityManager", "Exception creating ANR dump file:", ioe);
            }
            if (anrFile.createNewFile()) {
                FileUtils.setPermissions(anrFile.getAbsolutePath(), 384, -1, -1);
                resetPriorityAfterLockedSection();
                return anrFile;
            }
            Slog.w("ActivityManager", "Unable to create ANR dump file: createNewFile failed");
            resetPriorityAfterLockedSection();
            return null;
        }
    }

    private static void maybePruneOldTraces(File tracesDir) {
        long now = System.currentTimeMillis();
        File[] traceFiles = tracesDir.listFiles();
        if (traceFiles != null) {
            for (File file : traceFiles) {
                if (now - file.lastModified() > 86400000 && !file.delete()) {
                    Slog.w("ActivityManager", "Unable to prune stale trace file: " + file);
                }
            }
        }
    }

    @Deprecated
    /* loaded from: classes.dex */
    public static class DumpStackFileObserver extends FileObserver {
        private static final int TRACE_DUMP_TIMEOUT_MS = 10000;
        private boolean mClosed;
        private final String mTracesPath;

        public DumpStackFileObserver(String tracesPath) {
            super(tracesPath, 8);
            this.mTracesPath = tracesPath;
        }

        @Override // android.os.FileObserver
        public synchronized void onEvent(int event, String path) {
            this.mClosed = true;
            notify();
        }

        public long dumpWithTimeout(int pid, long timeout) {
            Process.sendSignal(pid, 3);
            long start = SystemClock.elapsedRealtime();
            long waitTime = Math.min(timeout, (long) JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
            synchronized (this) {
                try {
                    wait(waitTime);
                } catch (InterruptedException e) {
                    Slog.wtf("ActivityManager", e);
                }
            }
            long timeWaited = SystemClock.elapsedRealtime() - start;
            if (timeWaited >= timeout) {
                return timeWaited;
            }
            if (!this.mClosed) {
                Slog.w("ActivityManager", "Didn't see close of " + this.mTracesPath + " for pid " + pid + ". Attempting native stack collection.");
                long nativeDumpTimeoutMs = Math.min(2000L, timeout - timeWaited);
                Debug.dumpNativeBacktraceToFileTimeout(pid, this.mTracesPath, (int) (nativeDumpTimeoutMs / 1000));
            }
            long end = SystemClock.elapsedRealtime();
            this.mClosed = false;
            return end - start;
        }
    }

    private static long dumpJavaTracesTombstoned(int pid, String fileName, long timeoutMs) {
        long timeStart = SystemClock.elapsedRealtime();
        if (!Debug.dumpJavaBacktraceToFileTimeout(pid, fileName, (int) (timeoutMs / 1000))) {
            Debug.dumpNativeBacktraceToFileTimeout(pid, fileName, 2);
        }
        return SystemClock.elapsedRealtime() - timeStart;
    }

    private static void dumpStackTraces(String tracesFile, ArrayList<Integer> firstPids, ArrayList<Integer> nativePids, ArrayList<Integer> extraPids, boolean useTombstonedForJavaTraces) {
        DumpStackFileObserver observer = useTombstonedForJavaTraces ? null : new DumpStackFileObserver(tracesFile);
        long remainingTime = 20000;
        if (observer != null) {
            try {
                observer.startWatching();
            } catch (Throwable th) {
                if (observer != null) {
                    observer.stopWatching();
                }
                throw th;
            }
        }
        if (firstPids != null) {
            int num = firstPids.size();
            for (int i = 0; i < num; i++) {
                long timeTaken = useTombstonedForJavaTraces ? dumpJavaTracesTombstoned(firstPids.get(i).intValue(), tracesFile, remainingTime) : observer.dumpWithTimeout(firstPids.get(i).intValue(), remainingTime);
                remainingTime -= timeTaken;
                if (remainingTime <= 0) {
                    Slog.e("ActivityManager", "Aborting stack trace dump (current firstPid=" + firstPids.get(i) + "); deadline exceeded.");
                    if (observer != null) {
                        observer.stopWatching();
                        return;
                    }
                    return;
                }
            }
        }
        if (nativePids != null) {
            Iterator<Integer> it = nativePids.iterator();
            while (it.hasNext()) {
                int pid = it.next().intValue();
                long nativeDumpTimeoutMs = Math.min(2000L, remainingTime);
                long start = SystemClock.elapsedRealtime();
                Debug.dumpNativeBacktraceToFileTimeout(pid, tracesFile, (int) (nativeDumpTimeoutMs / 1000));
                long timeTaken2 = SystemClock.elapsedRealtime() - start;
                remainingTime -= timeTaken2;
                if (remainingTime <= 0) {
                    Slog.e("ActivityManager", "Aborting stack trace dump (current native pid=" + pid + "); deadline exceeded.");
                    if (observer != null) {
                        observer.stopWatching();
                        return;
                    }
                    return;
                }
            }
        }
        if (extraPids != null) {
            Iterator<Integer> it2 = extraPids.iterator();
            while (it2.hasNext()) {
                int pid2 = it2.next().intValue();
                long timeTaken3 = useTombstonedForJavaTraces ? dumpJavaTracesTombstoned(pid2, tracesFile, remainingTime) : observer.dumpWithTimeout(pid2, remainingTime);
                remainingTime -= timeTaken3;
                if (remainingTime <= 0) {
                    Slog.e("ActivityManager", "Aborting stack trace dump (current extra pid=" + pid2 + "); deadline exceeded.");
                    if (observer != null) {
                        observer.stopWatching();
                        return;
                    }
                    return;
                }
            }
        }
        if (observer != null) {
            observer.stopWatching();
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public final void logAppTooSlow(ProcessRecord app, long startTime, String msg) {
    }

    @GuardedBy("this")
    final void showLaunchWarningLocked(final ActivityRecord cur, final ActivityRecord next) {
        if (!this.mLaunchWarningShown) {
            this.mLaunchWarningShown = true;
            this.mUiHandler.post(new Runnable() { // from class: com.android.server.am.ActivityManagerService.6
                @Override // java.lang.Runnable
                public void run() {
                    synchronized (ActivityManagerService.this) {
                        try {
                            ActivityManagerService.boostPriorityForLockedSection();
                            final Dialog d = new LaunchWarningWindow(ActivityManagerService.this.mContext, cur, next);
                            d.show();
                            ActivityManagerService.this.mUiHandler.postDelayed(new Runnable() { // from class: com.android.server.am.ActivityManagerService.6.1
                                @Override // java.lang.Runnable
                                public void run() {
                                    synchronized (ActivityManagerService.this) {
                                        try {
                                            ActivityManagerService.boostPriorityForLockedSection();
                                            d.dismiss();
                                            ActivityManagerService.this.mLaunchWarningShown = false;
                                        } catch (Throwable th) {
                                            ActivityManagerService.resetPriorityAfterLockedSection();
                                            throw th;
                                        }
                                    }
                                    ActivityManagerService.resetPriorityAfterLockedSection();
                                }
                            }, 4000L);
                        } catch (Throwable th) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                            throw th;
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                }
            });
        }
    }

    /*  JADX ERROR: JadxRuntimeException in pass: BlockProcessor
        jadx.core.utils.exceptions.JadxRuntimeException: Unreachable block: B:32:0x00a4
        	at jadx.core.dex.visitors.blocks.BlockProcessor.checkForUnreachableBlocks(BlockProcessor.java:81)
        	at jadx.core.dex.visitors.blocks.BlockProcessor.processBlocksTree(BlockProcessor.java:47)
        	at jadx.core.dex.visitors.blocks.BlockProcessor.visit(BlockProcessor.java:39)
        */
    public boolean clearApplicationUserData(java.lang.String r23, boolean r24, android.content.pm.IPackageDataObserver r25, int r26) {
        /*
            Method dump skipped, instructions count: 460
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.clearApplicationUserData(java.lang.String, boolean, android.content.pm.IPackageDataObserver, int):boolean");
    }

    /* JADX WARN: Code restructure failed: missing block: B:30:0x00d8, code lost:
        resetPriorityAfterLockedSection();
     */
    /* JADX WARN: Code restructure failed: missing block: B:31:0x00db, code lost:
        r7 = r16 + 1;
        r8 = r17;
        r9 = r23;
     */
    /* JADX WARN: Code restructure failed: missing block: B:37:0x00ee, code lost:
        r0 = th;
     */
    /* JADX WARN: Code restructure failed: missing block: B:38:0x00ef, code lost:
        r1 = r23;
     */
    /* JADX WARN: Unsupported multi-entry loop pattern (BACK_EDGE: B:52:? -> B:39:0x00f2). Please submit an issue!!! */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public void killBackgroundProcesses(java.lang.String r26, int r27) {
        /*
            Method dump skipped, instructions count: 262
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.killBackgroundProcesses(java.lang.String, int):void");
    }

    public void killAllBackgroundProcesses() {
        if (checkCallingPermission("android.permission.KILL_BACKGROUND_PROCESSES") != 0) {
            String msg = "Permission Denial: killAllBackgroundProcesses() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.KILL_BACKGROUND_PROCESSES";
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ArrayList<ProcessRecord> procs = new ArrayList<>();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    for (int ia = 0; ia < NA; ia++) {
                        ProcessRecord app = apps.valueAt(ia);
                        if (!app.persistent) {
                            if (app.removed) {
                                procs.add(app);
                            } else if (app.setAdj >= 900) {
                                app.removed = true;
                                procs.add(app);
                            }
                        }
                    }
                }
                int N = procs.size();
                for (int i = 0; i < N; i++) {
                    removeProcessLocked(procs.get(i), false, true, "kill all background");
                }
                this.mAllowLowerMemLevel = true;
                updateOomAdjLocked();
                doLowMemReportIfNeededLocked(null);
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    private void killAllBackgroundProcessesExcept(int minTargetSdk, int maxProcState) {
        if (checkCallingPermission("android.permission.KILL_BACKGROUND_PROCESSES") != 0) {
            String msg = "Permission Denial: killAllBackgroundProcessesExcept() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.KILL_BACKGROUND_PROCESSES";
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ArrayList<ProcessRecord> procs = new ArrayList<>();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    for (int ia = 0; ia < NA; ia++) {
                        ProcessRecord app = apps.valueAt(ia);
                        if (app.removed) {
                            procs.add(app);
                        } else if ((minTargetSdk < 0 || app.info.targetSdkVersion < minTargetSdk) && (maxProcState < 0 || app.setProcState > maxProcState)) {
                            app.removed = true;
                            procs.add(app);
                        }
                    }
                }
                int N = procs.size();
                for (int i = 0; i < N; i++) {
                    removeProcessLocked(procs.get(i), false, true, "kill all background except");
                }
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void forceStopPackage(String packageName, int userId) {
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: forceStopPackage() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.FORCE_STOP_PACKAGES";
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        int callingPid = Binder.getCallingPid();
        int userId2 = this.mUserController.handleIncomingUser(callingPid, Binder.getCallingUid(), userId, true, 2, "forceStopPackage", null);
        long callingId = Binder.clearCallingIdentity();
        try {
            IPackageManager pm = AppGlobals.getPackageManager();
            synchronized (this) {
                boostPriorityForLockedSection();
                boolean z = true;
                int i = -1;
                int[] users = userId2 == -1 ? this.mUserController.getUsers() : new int[]{userId2};
                int length = users.length;
                int i2 = 0;
                while (i2 < length) {
                    int user = users[i2];
                    if (getPackageManagerInternalLocked().isPackageStateProtected(packageName, user)) {
                        Slog.w("ActivityManager", "Ignoring request to force stop protected package " + packageName + " u" + user);
                        resetPriorityAfterLockedSection();
                        return;
                    }
                    int pkgUid = i;
                    try {
                        pkgUid = pm.getPackageUid(packageName, 268435456, user);
                    } catch (RemoteException e) {
                    }
                    if (pkgUid == i) {
                        Slog.w("ActivityManager", "Invalid packageName: " + packageName);
                    } else {
                        try {
                            pm.setPackageStoppedState(packageName, z, user);
                        } catch (RemoteException e2) {
                        } catch (IllegalArgumentException e3) {
                            Slog.w("ActivityManager", "Failed trying to unstop package " + packageName + ": " + e3);
                        }
                        if (this.mUserController.isUserRunning(user, 0)) {
                            forceStopPackageLocked(packageName, pkgUid, "from pid " + callingPid);
                            finishForceStopPackageLocked(packageName, pkgUid);
                        }
                    }
                    i2++;
                    z = true;
                    i = -1;
                }
                resetPriorityAfterLockedSection();
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void addPackageDependency(String packageName) {
        ProcessRecord proc;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int callingPid = Binder.getCallingPid();
                if (callingPid == Process.myPid()) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                synchronized (this.mPidsSelfLocked) {
                    proc = this.mPidsSelfLocked.get(Binder.getCallingPid());
                }
                if (proc != null) {
                    if (proc.pkgDeps == null) {
                        proc.pkgDeps = new ArraySet<>(1);
                    }
                    proc.pkgDeps.add(packageName);
                }
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void killApplication(String pkg, int appId, int userId, String reason) {
        if (pkg == null) {
            return;
        }
        if (appId < 0) {
            Slog.w("ActivityManager", "Invalid appid specified for pkg : " + pkg);
            return;
        }
        int callerUid = Binder.getCallingUid();
        if (UserHandle.getAppId(callerUid) == 1000) {
            Message msg = this.mHandler.obtainMessage(22);
            msg.arg1 = appId;
            msg.arg2 = userId;
            Bundle bundle = new Bundle();
            bundle.putString("pkg", pkg);
            bundle.putString(PhoneWindowManager.SYSTEM_DIALOG_REASON_KEY, reason);
            msg.obj = bundle;
            this.mHandler.sendMessage(msg);
            return;
        }
        throw new SecurityException(callerUid + " cannot kill pkg: " + pkg);
    }

    public void closeSystemDialogs(String reason) {
        ProcessRecord proc;
        enforceNotIsolatedCaller("closeSystemDialogs");
        int pid = Binder.getCallingPid();
        int uid = Binder.getCallingUid();
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                if (uid >= 10000) {
                    synchronized (this.mPidsSelfLocked) {
                        proc = this.mPidsSelfLocked.get(pid);
                    }
                    if (proc.curRawAdj > 200) {
                        Slog.w("ActivityManager", "Ignoring closeSystemDialogs " + reason + " from background process " + proc);
                        resetPriorityAfterLockedSection();
                        return;
                    }
                }
                closeSystemDialogsLocked(reason);
                resetPriorityAfterLockedSection();
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    @GuardedBy("this")
    void closeSystemDialogsLocked(String reason) {
        Intent intent = new Intent("android.intent.action.CLOSE_SYSTEM_DIALOGS");
        intent.addFlags(1342177280);
        if (reason != null) {
            intent.putExtra(PhoneWindowManager.SYSTEM_DIALOG_REASON_KEY, reason);
        }
        this.mWindowManager.closeSystemDialogs(reason);
        this.mStackSupervisor.closeSystemDialogsLocked();
        broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, -1, 1000, -1);
    }

    /* JADX WARN: Unsupported multi-entry loop pattern (BACK_EDGE: B:78:? -> B:45:0x009e). Please submit an issue!!! */
    public Debug.MemoryInfo[] getProcessMemoryInfo(int[] pids) {
        ProcessRecord proc;
        int i;
        int oomAdj;
        Debug.MemoryInfo[] infos;
        ActivityManagerService activityManagerService = this;
        int[] iArr = pids;
        activityManagerService.enforceNotIsolatedCaller("getProcessMemoryInfo");
        Debug.MemoryInfo[] infos2 = new Debug.MemoryInfo[iArr.length];
        int i2 = iArr.length - 1;
        while (true) {
            int i3 = i2;
            if (i3 >= 0) {
                synchronized (this) {
                    try {
                        try {
                            boostPriorityForLockedSection();
                            synchronized (activityManagerService.mPidsSelfLocked) {
                                try {
                                    proc = activityManagerService.mPidsSelfLocked.get(iArr[i3]);
                                    if (proc == null) {
                                        i = 0;
                                    } else {
                                        try {
                                            i = proc.setAdj;
                                        } catch (Throwable th) {
                                            th = th;
                                            while (true) {
                                                try {
                                                    break;
                                                } catch (Throwable th2) {
                                                    th = th2;
                                                }
                                            }
                                            throw th;
                                        }
                                    }
                                    oomAdj = i;
                                } catch (Throwable th3) {
                                    th = th3;
                                }
                            }
                        } catch (Throwable th4) {
                            th = th4;
                            resetPriorityAfterLockedSection();
                            throw th;
                        }
                    } catch (Throwable th5) {
                        th = th5;
                    }
                }
                resetPriorityAfterLockedSection();
                infos2[i3] = new Debug.MemoryInfo();
                long startTime = SystemClock.currentThreadTimeMillis();
                Debug.getMemoryInfo(iArr[i3], infos2[i3]);
                long endTime = SystemClock.currentThreadTimeMillis();
                if (proc == null) {
                    infos = infos2;
                } else {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            if (proc.thread == null || proc.setAdj != oomAdj) {
                                infos = infos2;
                            } else {
                                try {
                                    infos = infos2;
                                    try {
                                        proc.baseProcessTracker.addPss(infos2[i3].getTotalPss(), infos2[i3].getTotalUss(), infos2[i3].getTotalRss(), false, 4, endTime - startTime, proc.pkgList);
                                    } catch (Throwable th6) {
                                        th = th6;
                                        resetPriorityAfterLockedSection();
                                        throw th;
                                    }
                                } catch (Throwable th7) {
                                    th = th7;
                                }
                            }
                            activityManagerService = this;
                        } catch (Throwable th8) {
                            th = th8;
                        }
                        try {
                        } catch (Throwable th9) {
                            th = th9;
                            resetPriorityAfterLockedSection();
                            throw th;
                        }
                    }
                    resetPriorityAfterLockedSection();
                }
                i2 = i3 - 1;
                infos2 = infos;
                iArr = pids;
            } else {
                return infos2;
            }
        }
    }

    public long[] getProcessPss(int[] pids) {
        ProcessRecord proc;
        int oomAdj;
        enforceNotIsolatedCaller("getProcessPss");
        long[] pss = new long[pids.length];
        int i = pids.length - 1;
        while (true) {
            int i2 = i;
            if (i2 >= 0) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        synchronized (this.mPidsSelfLocked) {
                            proc = this.mPidsSelfLocked.get(pids[i2]);
                            oomAdj = proc != null ? proc.setAdj : 0;
                        }
                    } finally {
                    }
                }
                resetPriorityAfterLockedSection();
                long[] tmpUss = new long[3];
                long startTime = SystemClock.currentThreadTimeMillis();
                pss[i2] = Debug.getPss(pids[i2], tmpUss, null);
                long endTime = SystemClock.currentThreadTimeMillis();
                if (proc != null) {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            if (proc.thread != null && proc.setAdj == oomAdj) {
                                proc.baseProcessTracker.addPss(pss[i2], tmpUss[0], tmpUss[2], false, 3, endTime - startTime, proc.pkgList);
                            }
                        } finally {
                        }
                    }
                    resetPriorityAfterLockedSection();
                }
                i = i2 - 1;
            } else {
                return pss;
            }
        }
    }

    public void killApplicationProcess(String processName, int uid) {
        if (processName == null) {
            return;
        }
        int callerUid = Binder.getCallingUid();
        if (callerUid == 1000) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ProcessRecord app = getProcessRecordLocked(processName, uid, true);
                    if (app != null && app.thread != null) {
                        try {
                            app.thread.scheduleSuicide();
                        } catch (RemoteException e) {
                        }
                    } else {
                        Slog.w("ActivityManager", "Process/uid not found attempting kill of " + processName + " / " + uid);
                    }
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            resetPriorityAfterLockedSection();
            return;
        }
        throw new SecurityException(callerUid + " cannot kill app process: " + processName);
    }

    @GuardedBy("this")
    private void forceStopPackageLocked(String packageName, int uid, String reason) {
        forceStopPackageLocked(packageName, UserHandle.getAppId(uid), false, false, true, false, false, UserHandle.getUserId(uid), reason);
    }

    /* JADX INFO: Access modifiers changed from: private */
    @GuardedBy("this")
    public void finishForceStopPackageLocked(String packageName, int uid) {
        Intent intent = new Intent("android.intent.action.PACKAGE_RESTARTED", Uri.fromParts("package", packageName, null));
        if (!this.mProcessesReady) {
            intent.addFlags(1342177280);
        }
        intent.putExtra("android.intent.extra.UID", uid);
        intent.putExtra("android.intent.extra.user_handle", UserHandle.getUserId(uid));
        broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, -1, null, false, false, MY_PID, 1000, UserHandle.getUserId(uid));
    }

    /* JADX WARN: Code restructure failed: missing block: B:22:0x0057, code lost:
        if (r12.userId != r19) goto L9;
     */
    /* JADX WARN: Code restructure failed: missing block: B:26:0x0062, code lost:
        if (android.os.UserHandle.getAppId(r12.uid) != r18) goto L9;
     */
    /* JADX WARN: Code restructure failed: missing block: B:36:0x007c, code lost:
        if (android.os.UserHandle.getAppId(r12.uid) != r18) goto L9;
     */
    /* JADX WARN: Code restructure failed: missing block: B:41:0x0084, code lost:
        if (r12.userId != r19) goto L9;
     */
    /* JADX WARN: Code restructure failed: missing block: B:45:0x008f, code lost:
        if (r8 == false) goto L9;
     */
    /* JADX WARN: Removed duplicated region for block: B:50:0x0096  */
    /* JADX WARN: Removed duplicated region for block: B:61:0x0094 A[SYNTHETIC] */
    @com.android.internal.annotations.GuardedBy("this")
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    private final boolean killPackageProcessesLocked(java.lang.String r17, int r18, int r19, int r20, boolean r21, boolean r22, boolean r23, boolean r24, java.lang.String r25) {
        /*
            Method dump skipped, instructions count: 207
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.killPackageProcessesLocked(java.lang.String, int, int, int, boolean, boolean, boolean, boolean, java.lang.String):boolean");
    }

    private void cleanupDisabledPackageComponentsLocked(String packageName, int userId, boolean killProcess, String[] changedClasses) {
        Set<String> disabledClasses;
        IPackageManager pm = AppGlobals.getPackageManager();
        if (changedClasses == null) {
            return;
        }
        int enabled = 0;
        int i = changedClasses.length - 1;
        int i2 = 0;
        Set<String> disabledClasses2 = null;
        while (true) {
            if (i >= 0) {
                String changedClass = changedClasses[i];
                if (changedClass.equals(packageName)) {
                    try {
                        enabled = pm.getApplicationEnabledSetting(packageName, userId != -1 ? userId : 0);
                        if (enabled != 1 && enabled != 0) {
                            r7 = 1;
                        }
                        i2 = r7;
                        if (i2 != 0) {
                            disabledClasses = null;
                            break;
                        }
                    } catch (Exception e) {
                        return;
                    }
                } else {
                    try {
                        int enabled2 = pm.getComponentEnabledSetting(new ComponentName(packageName, changedClass), userId != -1 ? userId : 0);
                        if (enabled2 != 1 && enabled2 != 0) {
                            if (disabledClasses2 == null) {
                                disabledClasses2 = new ArraySet<>(changedClasses.length);
                            }
                            disabledClasses2.add(changedClass);
                        }
                        enabled = enabled2;
                    } catch (Exception e2) {
                        return;
                    }
                }
                i--;
            } else {
                disabledClasses = disabledClasses2;
                break;
            }
        }
        if (i2 == 0 && disabledClasses == null) {
            return;
        }
        if (this.mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, disabledClasses, true, false, userId) && this.mBooted) {
            this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
            this.mStackSupervisor.scheduleIdleLocked();
        }
        this.mRecentTasks.cleanupDisabledPackageTasksLocked(packageName, disabledClasses, userId);
        Set<String> set = disabledClasses;
        this.mServices.bringDownDisabledPackageServicesLocked(packageName, set, userId, false, killProcess, true);
        ArrayList<ContentProviderRecord> providers = new ArrayList<>();
        this.mProviderMap.collectPackageProvidersLocked(packageName, set, true, false, userId, providers);
        for (int i3 = providers.size() - 1; i3 >= 0; i3--) {
            removeDyingProviderLocked(null, providers.get(i3), true);
        }
        for (int i4 = this.mBroadcastQueues.length - 1; i4 >= 0; i4--) {
            this.mBroadcastQueues[i4].cleanupDisabledPackageReceiversLocked(packageName, disabledClasses, userId, true);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public final boolean clearBroadcastQueueForUserLocked(int userId) {
        boolean didSomething = false;
        for (int i = this.mBroadcastQueues.length - 1; i >= 0; i--) {
            didSomething |= this.mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(null, null, userId, true);
        }
        return didSomething;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Removed duplicated region for block: B:113:0x019d A[SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:15:0x0030  */
    /* JADX WARN: Removed duplicated region for block: B:25:0x008e  */
    /* JADX WARN: Removed duplicated region for block: B:27:0x00a3  */
    /* JADX WARN: Removed duplicated region for block: B:30:0x00d8  */
    /* JADX WARN: Removed duplicated region for block: B:34:0x00df  */
    /* JADX WARN: Removed duplicated region for block: B:37:0x00f0  */
    /* JADX WARN: Removed duplicated region for block: B:41:0x00f6  */
    /* JADX WARN: Removed duplicated region for block: B:44:0x0110  */
    /* JADX WARN: Removed duplicated region for block: B:50:0x011c A[LOOP:0: B:48:0x0119->B:50:0x011c, LOOP_END] */
    /* JADX WARN: Removed duplicated region for block: B:53:0x012e  */
    /* JADX WARN: Removed duplicated region for block: B:63:0x015d  */
    /* JADX WARN: Removed duplicated region for block: B:85:0x019e  */
    /* JADX WARN: Removed duplicated region for block: B:92:0x01c1  */
    /* JADX WARN: Type inference failed for: r8v2 */
    /* JADX WARN: Type inference failed for: r8v3, types: [int, boolean] */
    /* JADX WARN: Type inference failed for: r8v4 */
    @com.android.internal.annotations.GuardedBy("this")
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public final boolean forceStopPackageLocked(java.lang.String r19, int r20, boolean r21, boolean r22, boolean r23, boolean r24, boolean r25, int r26, java.lang.String r27) {
        /*
            Method dump skipped, instructions count: 477
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.forceStopPackageLocked(java.lang.String, int, boolean, boolean, boolean, boolean, boolean, int, java.lang.String):boolean");
    }

    private final ProcessRecord removeProcessNameLocked(String name, int uid) {
        return removeProcessNameLocked(name, uid, null);
    }

    private final ProcessRecord removeProcessNameLocked(String name, int uid, ProcessRecord expecting) {
        ProcessRecord old = (ProcessRecord) this.mProcessNames.get(name, uid);
        if (expecting == null || old == expecting) {
            this.mProcessNames.remove(name, uid);
        }
        if (old != null && old.uidRecord != null) {
            old.uidRecord.numProcs--;
            if (old.uidRecord.numProcs == 0) {
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i("ActivityManager", "No more processes in " + old.uidRecord);
                }
                enqueueUidChangeLocked(old.uidRecord, -1, 1);
                EventLogTags.writeAmUidStopped(uid);
                this.mActiveUids.remove(uid);
                noteUidProcessState(uid, 19);
            }
            old.uidRecord = null;
        }
        this.mIsolatedProcesses.remove(uid);
        return old;
    }

    private final void addProcessNameLocked(ProcessRecord proc) {
        ProcessRecord old = removeProcessNameLocked(proc.processName, proc.uid);
        if (old == proc && proc.persistent) {
            Slog.w("ActivityManager", "Re-adding persistent process " + proc);
        } else if (old != null) {
            Slog.wtf("ActivityManager", "Already have existing proc " + old + " when adding " + proc);
        }
        UidRecord uidRec = this.mActiveUids.get(proc.uid);
        if (uidRec == null) {
            uidRec = new UidRecord(proc.uid);
            if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                Slog.i("ActivityManager", "Creating new process uid: " + uidRec);
            }
            if (Arrays.binarySearch(this.mDeviceIdleTempWhitelist, UserHandle.getAppId(proc.uid)) >= 0 || this.mPendingTempWhitelist.indexOfKey(proc.uid) >= 0) {
                uidRec.curWhitelist = true;
                uidRec.setWhitelist = true;
            }
            uidRec.updateHasInternetPermission();
            this.mActiveUids.put(proc.uid, uidRec);
            EventLogTags.writeAmUidRunning(uidRec.uid);
            noteUidProcessState(uidRec.uid, uidRec.curProcState);
        }
        proc.uidRecord = uidRec;
        proc.renderThreadTid = 0;
        uidRec.numProcs++;
        this.mProcessNames.put(proc.processName, proc.uid, proc);
        if (proc.isolated) {
            this.mIsolatedProcesses.put(proc.uid, proc);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public boolean removeProcessLocked(ProcessRecord app, boolean callerWillRestart, boolean allowRestart, String reason) {
        String name = app.processName;
        int uid = app.uid;
        if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
            Slog.d("ActivityManager", "Force removing proc " + app.toShortString() + " (" + name + SliceClientPermissions.SliceAuthority.DELIMITER + uid + ")");
        }
        ProcessRecord old = (ProcessRecord) this.mProcessNames.get(name, uid);
        if (old != app) {
            Slog.w("ActivityManager", "Ignoring remove of inactive process: " + app);
            return false;
        }
        removeProcessNameLocked(name, uid);
        if (this.mHeavyWeightProcess == app) {
            this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
            this.mHeavyWeightProcess = null;
        }
        boolean needRestart = false;
        if ((app.pid > 0 && app.pid != MY_PID) || (app.pid == 0 && app.pendingStart)) {
            int pid = app.pid;
            if (pid > 0) {
                synchronized (this.mPidsSelfLocked) {
                    this.mPidsSelfLocked.remove(pid);
                    this.mHandler.removeMessages(20, app);
                }
                this.mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
                if (app.isolated) {
                    this.mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
                    getPackageManagerInternalLocked().removeIsolatedUid(app.uid);
                }
            }
            boolean willRestart = false;
            if (app.persistent && !app.isolated) {
                if (!callerWillRestart) {
                    willRestart = true;
                } else {
                    needRestart = true;
                }
            }
            app.kill(reason, true);
            handleAppDiedLocked(app, willRestart, allowRestart);
            if (willRestart) {
                removeLruProcessLocked(app);
                addAppLocked(app.info, null, false, null);
            }
        } else {
            this.mRemovedProcesses.add(app);
        }
        return needRestart;
    }

    /* JADX INFO: Access modifiers changed from: private */
    @GuardedBy("this")
    public final void processContentProviderPublishTimedOutLocked(ProcessRecord app) {
        cleanupAppInLaunchingProvidersLocked(app, true);
        removeProcessLocked(app, false, true, "timeout publishing content providers");
    }

    /* JADX INFO: Access modifiers changed from: private */
    public final void processStartTimedOutLocked(final ProcessRecord app) {
        int pid = app.pid;
        boolean gone = false;
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord knownApp = this.mPidsSelfLocked.get(pid);
            if (knownApp != null && knownApp.thread == null) {
                this.mPidsSelfLocked.remove(pid);
                gone = true;
            }
        }
        if (gone) {
            Slog.w("ActivityManager", "Process " + app + " failed to attach");
            EventLog.writeEvent((int) EventLogTags.AM_PROCESS_START_TIMEOUT, Integer.valueOf(app.userId), Integer.valueOf(pid), Integer.valueOf(app.uid), app.processName);
            removeProcessNameLocked(app.processName, app.uid);
            if (this.mHeavyWeightProcess == app) {
                this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
                this.mHeavyWeightProcess = null;
            }
            this.mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
            cleanupAppInLaunchingProvidersLocked(app, true);
            this.mServices.processStartTimedOutLocked(app);
            app.kill("start timeout", true);
            if (app.isolated) {
                this.mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
            }
            removeLruProcessLocked(app);
            if (this.mBackupTarget != null && this.mBackupTarget.app.pid == pid) {
                Slog.w("ActivityManager", "Unattached app died before backup, skipping");
                this.mHandler.post(new Runnable() { // from class: com.android.server.am.ActivityManagerService.8
                    @Override // java.lang.Runnable
                    public void run() {
                        try {
                            IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(BatteryService.HealthServiceWrapper.INSTANCE_HEALTHD));
                            bm.agentDisconnected(app.info.packageName);
                        } catch (RemoteException e) {
                        }
                    }
                });
            }
            if (isPendingBroadcastProcessLocked(pid)) {
                Slog.w("ActivityManager", "Unattached app died before broadcast acknowledged, skipping");
                skipPendingBroadcastLocked(pid);
                return;
            }
            return;
        }
        Slog.w("ActivityManager", "Spurious process start timeout - pid not known for " + app);
    }

    /* JADX WARN: Code restructure failed: missing block: B:305:0x0674, code lost:
        if (r67.mBackupTarget == null) goto L262;
     */
    /* JADX WARN: Code restructure failed: missing block: B:307:0x067a, code lost:
        if (r67.mBackupTarget.app != r1) goto L262;
     */
    /* JADX WARN: Code restructure failed: missing block: B:309:0x067e, code lost:
        if (com.android.server.am.ActivityManagerDebugConfig.DEBUG_BACKUP == false) goto L243;
     */
    /* JADX WARN: Code restructure failed: missing block: B:310:0x0680, code lost:
        android.util.Slog.v("ActivityManager", "New app is backup target, launching agent for " + r1);
     */
    /* JADX WARN: Code restructure failed: missing block: B:311:0x0696, code lost:
        notifyPackageUse(r67.mBackupTarget.appInfo.packageName, 5);
     */
    /* JADX WARN: Code restructure failed: missing block: B:314:0x06b2, code lost:
        r68.scheduleCreateBackupAgent(r67.mBackupTarget.appInfo, compatibilityInfoForPackageLocked(r67.mBackupTarget.appInfo), r67.mBackupTarget.backupMode);
     */
    /* JADX WARN: Code restructure failed: missing block: B:316:0x06b6, code lost:
        r0 = e;
     */
    /* JADX WARN: Code restructure failed: missing block: B:318:0x06b8, code lost:
        r0 = e;
     */
    /* JADX WARN: Code restructure failed: missing block: B:320:0x06bb, code lost:
        android.util.Slog.wtf("ActivityManager", "Exception thrown creating backup agent in " + r1, r0);
        r2 = true;
     */
    /* JADX WARN: Removed duplicated region for block: B:146:0x0318 A[Catch: Exception -> 0x0256, TryCatch #3 {Exception -> 0x0256, blocks: (B:82:0x0237, B:84:0x023d, B:88:0x0245, B:90:0x024d, B:100:0x026d, B:102:0x0275, B:107:0x0281, B:109:0x0289, B:111:0x0291, B:113:0x0298, B:115:0x029f, B:123:0x02af, B:126:0x02bf, B:129:0x02e5, B:134:0x02f8, B:136:0x0300, B:138:0x0306, B:140:0x030c, B:146:0x0318, B:148:0x0329, B:150:0x032f, B:166:0x036d, B:168:0x0375, B:170:0x037f, B:172:0x0389, B:173:0x03ab, B:175:0x03b1, B:177:0x03c1, B:179:0x03c5, B:181:0x03d5, B:183:0x03d9, B:187:0x03e1, B:189:0x03e7, B:194:0x03f7, B:196:0x03fb, B:198:0x0405, B:200:0x0409, B:158:0x0345, B:160:0x034b), top: B:351:0x0237 }] */
    /* JADX WARN: Removed duplicated region for block: B:147:0x0324  */
    /* JADX WARN: Removed duplicated region for block: B:150:0x032f A[Catch: Exception -> 0x0256, TRY_LEAVE, TryCatch #3 {Exception -> 0x0256, blocks: (B:82:0x0237, B:84:0x023d, B:88:0x0245, B:90:0x024d, B:100:0x026d, B:102:0x0275, B:107:0x0281, B:109:0x0289, B:111:0x0291, B:113:0x0298, B:115:0x029f, B:123:0x02af, B:126:0x02bf, B:129:0x02e5, B:134:0x02f8, B:136:0x0300, B:138:0x0306, B:140:0x030c, B:146:0x0318, B:148:0x0329, B:150:0x032f, B:166:0x036d, B:168:0x0375, B:170:0x037f, B:172:0x0389, B:173:0x03ab, B:175:0x03b1, B:177:0x03c1, B:179:0x03c5, B:181:0x03d5, B:183:0x03d9, B:187:0x03e1, B:189:0x03e7, B:194:0x03f7, B:196:0x03fb, B:198:0x0405, B:200:0x0409, B:158:0x0345, B:160:0x034b), top: B:351:0x0237 }] */
    /* JADX WARN: Removed duplicated region for block: B:152:0x0334  */
    /* JADX WARN: Removed duplicated region for block: B:166:0x036d A[Catch: Exception -> 0x0256, TRY_ENTER, TryCatch #3 {Exception -> 0x0256, blocks: (B:82:0x0237, B:84:0x023d, B:88:0x0245, B:90:0x024d, B:100:0x026d, B:102:0x0275, B:107:0x0281, B:109:0x0289, B:111:0x0291, B:113:0x0298, B:115:0x029f, B:123:0x02af, B:126:0x02bf, B:129:0x02e5, B:134:0x02f8, B:136:0x0300, B:138:0x0306, B:140:0x030c, B:146:0x0318, B:148:0x0329, B:150:0x032f, B:166:0x036d, B:168:0x0375, B:170:0x037f, B:172:0x0389, B:173:0x03ab, B:175:0x03b1, B:177:0x03c1, B:179:0x03c5, B:181:0x03d5, B:183:0x03d9, B:187:0x03e1, B:189:0x03e7, B:194:0x03f7, B:196:0x03fb, B:198:0x0405, B:200:0x0409, B:158:0x0345, B:160:0x034b), top: B:351:0x0237 }] */
    /* JADX WARN: Removed duplicated region for block: B:172:0x0389 A[Catch: Exception -> 0x0256, TryCatch #3 {Exception -> 0x0256, blocks: (B:82:0x0237, B:84:0x023d, B:88:0x0245, B:90:0x024d, B:100:0x026d, B:102:0x0275, B:107:0x0281, B:109:0x0289, B:111:0x0291, B:113:0x0298, B:115:0x029f, B:123:0x02af, B:126:0x02bf, B:129:0x02e5, B:134:0x02f8, B:136:0x0300, B:138:0x0306, B:140:0x030c, B:146:0x0318, B:148:0x0329, B:150:0x032f, B:166:0x036d, B:168:0x0375, B:170:0x037f, B:172:0x0389, B:173:0x03ab, B:175:0x03b1, B:177:0x03c1, B:179:0x03c5, B:181:0x03d5, B:183:0x03d9, B:187:0x03e1, B:189:0x03e7, B:194:0x03f7, B:196:0x03fb, B:198:0x0405, B:200:0x0409, B:158:0x0345, B:160:0x034b), top: B:351:0x0237 }] */
    /* JADX WARN: Removed duplicated region for block: B:173:0x03ab A[Catch: Exception -> 0x0256, TryCatch #3 {Exception -> 0x0256, blocks: (B:82:0x0237, B:84:0x023d, B:88:0x0245, B:90:0x024d, B:100:0x026d, B:102:0x0275, B:107:0x0281, B:109:0x0289, B:111:0x0291, B:113:0x0298, B:115:0x029f, B:123:0x02af, B:126:0x02bf, B:129:0x02e5, B:134:0x02f8, B:136:0x0300, B:138:0x0306, B:140:0x030c, B:146:0x0318, B:148:0x0329, B:150:0x032f, B:166:0x036d, B:168:0x0375, B:170:0x037f, B:172:0x0389, B:173:0x03ab, B:175:0x03b1, B:177:0x03c1, B:179:0x03c5, B:181:0x03d5, B:183:0x03d9, B:187:0x03e1, B:189:0x03e7, B:194:0x03f7, B:196:0x03fb, B:198:0x0405, B:200:0x0409, B:158:0x0345, B:160:0x034b), top: B:351:0x0237 }] */
    /* JADX WARN: Removed duplicated region for block: B:177:0x03c1 A[Catch: Exception -> 0x0256, TryCatch #3 {Exception -> 0x0256, blocks: (B:82:0x0237, B:84:0x023d, B:88:0x0245, B:90:0x024d, B:100:0x026d, B:102:0x0275, B:107:0x0281, B:109:0x0289, B:111:0x0291, B:113:0x0298, B:115:0x029f, B:123:0x02af, B:126:0x02bf, B:129:0x02e5, B:134:0x02f8, B:136:0x0300, B:138:0x0306, B:140:0x030c, B:146:0x0318, B:148:0x0329, B:150:0x032f, B:166:0x036d, B:168:0x0375, B:170:0x037f, B:172:0x0389, B:173:0x03ab, B:175:0x03b1, B:177:0x03c1, B:179:0x03c5, B:181:0x03d5, B:183:0x03d9, B:187:0x03e1, B:189:0x03e7, B:194:0x03f7, B:196:0x03fb, B:198:0x0405, B:200:0x0409, B:158:0x0345, B:160:0x034b), top: B:351:0x0237 }] */
    /* JADX WARN: Removed duplicated region for block: B:187:0x03e1 A[Catch: Exception -> 0x0256, TRY_ENTER, TryCatch #3 {Exception -> 0x0256, blocks: (B:82:0x0237, B:84:0x023d, B:88:0x0245, B:90:0x024d, B:100:0x026d, B:102:0x0275, B:107:0x0281, B:109:0x0289, B:111:0x0291, B:113:0x0298, B:115:0x029f, B:123:0x02af, B:126:0x02bf, B:129:0x02e5, B:134:0x02f8, B:136:0x0300, B:138:0x0306, B:140:0x030c, B:146:0x0318, B:148:0x0329, B:150:0x032f, B:166:0x036d, B:168:0x0375, B:170:0x037f, B:172:0x0389, B:173:0x03ab, B:175:0x03b1, B:177:0x03c1, B:179:0x03c5, B:181:0x03d5, B:183:0x03d9, B:187:0x03e1, B:189:0x03e7, B:194:0x03f7, B:196:0x03fb, B:198:0x0405, B:200:0x0409, B:158:0x0345, B:160:0x034b), top: B:351:0x0237 }] */
    /* JADX WARN: Removed duplicated region for block: B:194:0x03f7 A[Catch: Exception -> 0x0256, TRY_ENTER, TryCatch #3 {Exception -> 0x0256, blocks: (B:82:0x0237, B:84:0x023d, B:88:0x0245, B:90:0x024d, B:100:0x026d, B:102:0x0275, B:107:0x0281, B:109:0x0289, B:111:0x0291, B:113:0x0298, B:115:0x029f, B:123:0x02af, B:126:0x02bf, B:129:0x02e5, B:134:0x02f8, B:136:0x0300, B:138:0x0306, B:140:0x030c, B:146:0x0318, B:148:0x0329, B:150:0x032f, B:166:0x036d, B:168:0x0375, B:170:0x037f, B:172:0x0389, B:173:0x03ab, B:175:0x03b1, B:177:0x03c1, B:179:0x03c5, B:181:0x03d5, B:183:0x03d9, B:187:0x03e1, B:189:0x03e7, B:194:0x03f7, B:196:0x03fb, B:198:0x0405, B:200:0x0409, B:158:0x0345, B:160:0x034b), top: B:351:0x0237 }] */
    /* JADX WARN: Removed duplicated region for block: B:198:0x0405 A[Catch: Exception -> 0x0256, TryCatch #3 {Exception -> 0x0256, blocks: (B:82:0x0237, B:84:0x023d, B:88:0x0245, B:90:0x024d, B:100:0x026d, B:102:0x0275, B:107:0x0281, B:109:0x0289, B:111:0x0291, B:113:0x0298, B:115:0x029f, B:123:0x02af, B:126:0x02bf, B:129:0x02e5, B:134:0x02f8, B:136:0x0300, B:138:0x0306, B:140:0x030c, B:146:0x0318, B:148:0x0329, B:150:0x032f, B:166:0x036d, B:168:0x0375, B:170:0x037f, B:172:0x0389, B:173:0x03ab, B:175:0x03b1, B:177:0x03c1, B:179:0x03c5, B:181:0x03d5, B:183:0x03d9, B:187:0x03e1, B:189:0x03e7, B:194:0x03f7, B:196:0x03fb, B:198:0x0405, B:200:0x0409, B:158:0x0345, B:160:0x034b), top: B:351:0x0237 }] */
    /* JADX WARN: Removed duplicated region for block: B:222:0x047b A[Catch: Exception -> 0x047f, TRY_LEAVE, TryCatch #9 {Exception -> 0x047f, blocks: (B:201:0x0411, B:203:0x0415, B:205:0x041f, B:207:0x0424, B:209:0x0432, B:219:0x046c, B:211:0x043c, B:213:0x0444, B:215:0x0456, B:216:0x045e, B:222:0x047b, B:231:0x0494, B:233:0x049e, B:238:0x04c6), top: B:363:0x0411 }] */
    /* JADX WARN: Removed duplicated region for block: B:231:0x0494 A[Catch: Exception -> 0x047f, TRY_ENTER, TryCatch #9 {Exception -> 0x047f, blocks: (B:201:0x0411, B:203:0x0415, B:205:0x041f, B:207:0x0424, B:209:0x0432, B:219:0x046c, B:211:0x043c, B:213:0x0444, B:215:0x0456, B:216:0x045e, B:222:0x047b, B:231:0x0494, B:233:0x049e, B:238:0x04c6), top: B:363:0x0411 }] */
    /* JADX WARN: Removed duplicated region for block: B:238:0x04c6 A[Catch: Exception -> 0x047f, TRY_ENTER, TRY_LEAVE, TryCatch #9 {Exception -> 0x047f, blocks: (B:201:0x0411, B:203:0x0415, B:205:0x041f, B:207:0x0424, B:209:0x0432, B:219:0x046c, B:211:0x043c, B:213:0x0444, B:215:0x0456, B:216:0x045e, B:222:0x047b, B:231:0x0494, B:233:0x049e, B:238:0x04c6), top: B:363:0x0411 }] */
    /* JADX WARN: Removed duplicated region for block: B:240:0x04d5 A[Catch: Exception -> 0x06fb, TRY_ENTER, TRY_LEAVE, TryCatch #12 {Exception -> 0x06fb, blocks: (B:228:0x0488, B:236:0x04b4, B:240:0x04d5), top: B:369:0x0488 }] */
    /* JADX WARN: Removed duplicated region for block: B:270:0x05a0 A[Catch: Exception -> 0x05a5, TRY_ENTER, TRY_LEAVE, TryCatch #16 {Exception -> 0x05a5, blocks: (B:270:0x05a0, B:253:0x0530), top: B:377:0x0530 }] */
    /* JADX WARN: Removed duplicated region for block: B:279:0x05cf  */
    /* JADX WARN: Removed duplicated region for block: B:296:0x0642  */
    /* JADX WARN: Removed duplicated region for block: B:302:0x066e A[ADDED_TO_REGION] */
    /* JADX WARN: Removed duplicated region for block: B:323:0x06d7  */
    /* JADX WARN: Removed duplicated region for block: B:325:0x06e2  */
    /* JADX WARN: Removed duplicated region for block: B:371:0x061b A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:37:0x00ea  */
    /* JADX WARN: Removed duplicated region for block: B:383:0x05f6 A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:47:0x0123  */
    @com.android.internal.annotations.GuardedBy("this")
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    private final boolean attachApplicationLocked(android.app.IApplicationThread r68, int r69, int r70, long r71) {
        /*
            Method dump skipped, instructions count: 1861
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.attachApplicationLocked(android.app.IApplicationThread, int, int, long):boolean");
    }

    public final void attachApplication(IApplicationThread thread, long startSeq) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int callingPid = Binder.getCallingPid();
                int callingUid = Binder.getCallingUid();
                long origId = Binder.clearCallingIdentity();
                attachApplicationLocked(thread, callingPid, callingUid, startSeq);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    ActivityRecord r = this.mStackSupervisor.activityIdleInternalLocked(token, false, false, config);
                    if (stopProfiling && this.mProfileProc == r.app && this.mProfilerInfo != null) {
                        clearProfilerLocked();
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        Binder.restoreCallingIdentity(origId);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void postFinishBooting(boolean finishBooting, boolean enableScreen) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(45, finishBooting ? 1 : 0, enableScreen ? 1 : 0));
    }

    void enableScreenAfterBoot() {
        EventLog.writeEvent((int) EventLogTags.BOOT_PROGRESS_ENABLE_SCREEN, SystemClock.uptimeMillis());
        BootEvent.addBootEvent("AMS: boot_progress_enable_screen");
        this.mWindowManager.enableScreenAfterBoot();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                updateEventDispatchingLocked();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void showBootMessage(CharSequence msg, boolean always) {
        if (Binder.getCallingUid() != Process.myUid()) {
            throw new SecurityException();
        }
        this.mWindowManager.showBootMessage(msg, always);
    }

    public void keyguardGoingAway(int flags) {
        enforceNotIsolatedCaller("keyguardGoingAway");
        long token = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mKeyguardController.keyguardGoingAway(flags);
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean isKeyguardLocked() {
        return this.mKeyguardController.isKeyguardLocked();
    }

    final void finishBooting() {
        String[] strArr;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!this.mBootAnimationComplete) {
                    this.mCallFinishBooting = true;
                    return;
                }
                this.mCallFinishBooting = false;
                resetPriorityAfterLockedSection();
                ArraySet<String> completedIsas = new ArraySet<>();
                for (String abi : Build.SUPPORTED_ABIS) {
                    Process.zygoteProcess.establishZygoteConnectionForAbi(abi);
                    String instructionSet = VMRuntime.getInstructionSet(abi);
                    if (!completedIsas.contains(instructionSet)) {
                        try {
                            this.mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi));
                        } catch (Installer.InstallerException e) {
                            Slog.w("ActivityManager", "Unable to mark boot complete for abi: " + abi + " (" + e.getMessage() + ")");
                        }
                        completedIsas.add(instructionSet);
                    }
                }
                IntentFilter pkgFilter = new IntentFilter();
                pkgFilter.addAction("android.intent.action.QUERY_PACKAGE_RESTART");
                pkgFilter.addDataScheme("package");
                this.mContext.registerReceiver(new BroadcastReceiver() { // from class: com.android.server.am.ActivityManagerService.9
                    @Override // android.content.BroadcastReceiver
                    public void onReceive(Context context, Intent intent) {
                        ActivityManagerService activityManagerService;
                        String[] pkgs = intent.getStringArrayExtra("android.intent.extra.PACKAGES");
                        if (pkgs != null) {
                            for (String pkg : pkgs) {
                                ActivityManagerService activityManagerService2 = ActivityManagerService.this;
                                synchronized (activityManagerService2) {
                                    try {
                                        ActivityManagerService.boostPriorityForLockedSection();
                                        activityManagerService = activityManagerService2;
                                        try {
                                            if (ActivityManagerService.this.forceStopPackageLocked(pkg, -1, false, false, false, false, false, 0, "query restart")) {
                                                setResultCode(-1);
                                                ActivityManagerService.resetPriorityAfterLockedSection();
                                                return;
                                            }
                                            ActivityManagerService.resetPriorityAfterLockedSection();
                                        } catch (Throwable th) {
                                            th = th;
                                            ActivityManagerService.resetPriorityAfterLockedSection();
                                            throw th;
                                        }
                                    } catch (Throwable th2) {
                                        th = th2;
                                        activityManagerService = activityManagerService2;
                                    }
                                }
                            }
                        }
                    }
                }, pkgFilter);
                IntentFilter dumpheapFilter = new IntentFilter();
                dumpheapFilter.addAction("com.android.server.am.DELETE_DUMPHEAP");
                this.mContext.registerReceiver(new BroadcastReceiver() { // from class: com.android.server.am.ActivityManagerService.10
                    @Override // android.content.BroadcastReceiver
                    public void onReceive(Context context, Intent intent) {
                        if (intent.getBooleanExtra("delay_delete", false)) {
                            ActivityManagerService.this.mHandler.sendEmptyMessageDelayed(50, BackupAgentTimeoutParameters.DEFAULT_FULL_BACKUP_AGENT_TIMEOUT_MILLIS);
                        } else {
                            ActivityManagerService.this.mHandler.sendEmptyMessage(50);
                        }
                    }
                }, dumpheapFilter);
                IntentFilter dumpNativeStackFilter = new IntentFilter();
                dumpNativeStackFilter.addAction("com.android.server.am.DUMPNATIVE");
                this.mContext.registerReceiver(new BroadcastReceiver() { // from class: com.android.server.am.ActivityManagerService.11
                    @Override // android.content.BroadcastReceiver
                    public void onReceive(Context context, Intent intent) {
                        String globalTracesPath = SystemProperties.get("dalvik.vm.stack-trace-dir", (String) null);
                        if (globalTracesPath.isEmpty()) {
                            Slog.i("ActivityManager", "dumpStackTraces: no trace path configured");
                            return;
                        }
                        File tracesDir = new File(globalTracesPath);
                        File tracesFile = ActivityManagerService.createAnrDumpFile(tracesDir);
                        if (tracesFile == null) {
                            Slog.i("ActivityManager", "DUMPNATIVE tracesFile is Null");
                            return;
                        }
                        int pid = intent.getIntExtra("pid", -1);
                        if (pid < 0) {
                            Slog.i("ActivityManager", "DUMPNATIVE bad pid");
                        } else {
                            Debug.dumpNativeBacktraceToFileTimeout(pid, tracesFile.getAbsolutePath(), 2);
                        }
                    }
                }, dumpNativeStackFilter);
                this.mSystemServiceManager.startBootPhase(1000);
                BootEvent.setEnabled(false);
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        int NP = this.mProcessesOnHold.size();
                        if (NP > 0) {
                            ArrayList<ProcessRecord> procs = new ArrayList<>(this.mProcessesOnHold);
                            for (int ip = 0; ip < NP; ip++) {
                                if (ActivityManagerDebugConfig.DEBUG_PROCESSES) {
                                    Slog.v("ActivityManager", "Starting process on hold: " + procs.get(ip));
                                }
                                startProcessLocked(procs.get(ip), "on-hold", null);
                            }
                        }
                        int ip2 = this.mFactoryTest;
                        if (ip2 == 1) {
                            return;
                        }
                        Message nmsg = this.mHandler.obtainMessage(CHECK_EXCESSIVE_POWER_USE_MSG);
                        this.mHandler.sendMessageDelayed(nmsg, this.mConstants.POWER_CHECK_INTERVAL);
                        SystemProperties.set("sys.boot_completed", "1");
                        if (!xpBootManagerPolicy.BOOT_POLICY_ENABLED) {
                            xpBootManagerPolicy.get(this.mContext).onBootCompleted();
                        }
                        if (!"trigger_restart_min_framework".equals(SystemProperties.get("vold.decrypt")) || BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS.equals(SystemProperties.get("vold.encrypt_progress"))) {
                            SystemProperties.set("dev.bootcomplete", "1");
                        }
                        this.mUserController.sendBootCompleted(new IIntentReceiver.Stub() { // from class: com.android.server.am.ActivityManagerService.12
                            public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
                                synchronized (ActivityManagerService.this) {
                                    try {
                                        ActivityManagerService.boostPriorityForLockedSection();
                                        ActivityManagerService.this.requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                                    } catch (Throwable th) {
                                        ActivityManagerService.resetPriorityAfterLockedSection();
                                        throw th;
                                    }
                                }
                                ActivityManagerService.resetPriorityAfterLockedSection();
                            }
                        });
                        this.mUserController.scheduleStartProfiles();
                        resetPriorityAfterLockedSection();
                    } finally {
                        resetPriorityAfterLockedSection();
                    }
                }
            } finally {
                resetPriorityAfterLockedSection();
            }
        }
    }

    public void bootAnimationComplete() {
        boolean callFinishBooting;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                callFinishBooting = this.mCallFinishBooting;
                this.mBootAnimationComplete = true;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (callFinishBooting) {
            Trace.traceBegin(64L, "FinishBooting");
            finishBooting();
            Trace.traceEnd(64L);
        }
    }

    final void ensureBootCompleted() {
        boolean booting;
        boolean enableScreen;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                booting = this.mBooting;
                this.mBooting = false;
                enableScreen = !this.mBooted;
                this.mBooted = true;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (booting) {
            Trace.traceBegin(64L, "FinishBooting");
            finishBooting();
            Trace.traceEnd(64L);
        }
        if (enableScreen) {
            enableScreenAfterBoot();
        }
    }

    public final void activityResumed(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord.activityResumedLocked(token);
                this.mWindowManager.notifyAppResumedFinished(token);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        Binder.restoreCallingIdentity(origId);
    }

    public final void activityPaused(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    stack.activityPausedLocked(token, false);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        Binder.restoreCallingIdentity(origId);
    }

    public final void activityStopped(IBinder token, Bundle icicle, PersistableBundle persistentState, CharSequence description) {
        if (ActivityManagerDebugConfig.DEBUG_ALL) {
            Slog.v("ActivityManager", "Activity stopped: token=" + token);
        }
        if (icicle != null && icicle.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Bundle");
        }
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    r.activityStoppedLocked(icicle, persistentState, description);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        trimApplications();
        Binder.restoreCallingIdentity(origId);
    }

    public final void activityDestroyed(IBinder token) {
        if (ActivityManagerDebugConfig.DEBUG_SWITCH) {
            Slog.v("ActivityManager", "ACTIVITY DESTROYED: " + token);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(token);
                if (stack != null) {
                    stack.activityDestroyedLocked(token, "activityDestroyed");
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public final void activityRelaunched(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mStackSupervisor.activityRelaunchedLocked(token);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        Binder.restoreCallingIdentity(origId);
    }

    public void reportSizeConfigurations(IBinder token, int[] horizontalSizeConfiguration, int[] verticalSizeConfigurations, int[] smallestSizeConfigurations) {
        if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
            Slog.v("ActivityManager", "Report configuration: " + token + " " + horizontalSizeConfiguration + " " + verticalSizeConfigurations);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord record = ActivityRecord.isInStackLocked(token);
                if (record == null) {
                    throw new IllegalArgumentException("reportSizeConfigurations: ActivityRecord not found for: " + token);
                }
                record.setSizeConfigurations(horizontalSizeConfiguration, verticalSizeConfigurations, smallestSizeConfigurations);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public final void notifyLaunchTaskBehindComplete(IBinder token) {
        this.mStackSupervisor.scheduleLaunchTaskBehindComplete(token);
    }

    public final void notifyEnterAnimationComplete(IBinder token) {
        this.mHandler.sendMessage(this.mHandler.obtainMessage(44, token));
    }

    public String getCallingPackage(IBinder token) {
        String str;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = getCallingRecordLocked(token);
                str = r != null ? r.info.packageName : null;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return str;
    }

    public ComponentName getCallingActivity(IBinder token) {
        ComponentName component;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = getCallingRecordLocked(token);
                component = r != null ? r.intent.getComponent() : null;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return component;
    }

    private ActivityRecord getCallingRecordLocked(IBinder token) {
        ActivityRecord r = ActivityRecord.isInStackLocked(token);
        if (r == null) {
            return null;
        }
        return r.resultTo;
    }

    public ComponentName getActivityClassForToken(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return null;
                }
                ComponentName component = r.intent.getComponent();
                resetPriorityAfterLockedSection();
                return component;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public String getPackageForToken(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return null;
                }
                String str = r.packageName;
                resetPriorityAfterLockedSection();
                return str;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public boolean isRootVoiceInteraction(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return false;
                }
                boolean z = r.rootVoiceInteraction;
                resetPriorityAfterLockedSection();
                return z;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public IIntentSender getIntentSender(int type, String packageName, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions, int userId) {
        enforceNotIsolatedCaller("getIntentSender");
        if (intents != null) {
            if (intents.length < 1) {
                throw new IllegalArgumentException("Intents array length must be >= 1");
            }
            for (int i = 0; i < intents.length; i++) {
                Intent intent = intents[i];
                if (intent != null) {
                    if (intent.hasFileDescriptors()) {
                        throw new IllegalArgumentException("File descriptors passed in Intent");
                    }
                    if (type == 1 && (intent.getFlags() & 33554432) != 0) {
                        throw new IllegalArgumentException("Can't use FLAG_RECEIVER_BOOT_UPGRADE here");
                    }
                    intents[i] = new Intent(intent);
                }
            }
            if (resolvedTypes != null && resolvedTypes.length != intents.length) {
                throw new IllegalArgumentException("Intent array length does not match resolvedTypes length");
            }
        }
        if (bOptions != null && bOptions.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in options");
        }
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    int callingUid = Binder.getCallingUid();
                    int userId2 = this.mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid, userId, type == 1, 0, "getIntentSender", null);
                    if (userId == -2) {
                        userId2 = -2;
                    }
                    int userId3 = userId2;
                    if (callingUid != 0 && callingUid != 1000) {
                        try {
                            int uid = AppGlobals.getPackageManager().getPackageUid(packageName, 268435456, UserHandle.getUserId(callingUid));
                            if (!UserHandle.isSameApp(callingUid, uid)) {
                                String msg = "Permission Denial: getIntentSender() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + ", (need uid=" + uid + ") is not allowed to send as package " + packageName;
                                Slog.w("ActivityManager", msg);
                                throw new SecurityException(msg);
                            }
                        } catch (RemoteException e) {
                            e = e;
                            throw new SecurityException(e);
                        }
                    }
                    try {
                        IIntentSender intentSenderLocked = getIntentSenderLocked(type, packageName, callingUid, userId3, token, resultWho, requestCode, intents, resolvedTypes, flags, bOptions);
                        resetPriorityAfterLockedSection();
                        return intentSenderLocked;
                    } catch (RemoteException e2) {
                        e = e2;
                        throw new SecurityException(e);
                    }
                } catch (Throwable th) {
                    e = th;
                    resetPriorityAfterLockedSection();
                    throw e;
                }
            } catch (Throwable th2) {
                e = th2;
                resetPriorityAfterLockedSection();
                throw e;
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public IIntentSender getIntentSenderLocked(int type, String packageName, int callingUid, int userId, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions) {
        Intent intent;
        if (ActivityManagerDebugConfig.DEBUG_MU) {
            Slog.v(TAG_MU, "getIntentSenderLocked(): uid=" + callingUid);
        }
        ActivityRecord activity = null;
        if (type == 3) {
            activity = ActivityRecord.isInStackLocked(token);
            if (activity == null) {
                Slog.w("ActivityManager", "Failed createPendingResult: activity " + token + " not in any stack");
                return null;
            } else if (activity.finishing) {
                Slog.w("ActivityManager", "Failed createPendingResult: activity " + activity + " is finishing");
                return null;
            }
        }
        ActivityRecord activity2 = activity;
        if (intents != null) {
            for (Intent intent2 : intents) {
                intent2.setDefusable(true);
            }
        }
        Bundle.setDefusable(bOptions, true);
        boolean noCreate = (flags & 536870912) != 0;
        boolean cancelCurrent = (flags & 268435456) != 0;
        boolean updateCurrent = (flags & 134217728) != 0;
        PendingIntentRecord.Key key = new PendingIntentRecord.Key(type, packageName, activity2, resultWho, requestCode, intents, resolvedTypes, flags & (-939524097), SafeActivityOptions.fromBundle(bOptions), userId);
        WeakReference<PendingIntentRecord> ref = this.mIntentSenderRecords.get(key);
        PendingIntentRecord rec = ref != null ? ref.get() : null;
        if (rec != null) {
            if (!cancelCurrent) {
                if (updateCurrent) {
                    if (rec.key.requestIntent != null) {
                        Intent intent3 = rec.key.requestIntent;
                        if (intents == null) {
                            intent = null;
                        } else {
                            intent = intents[intents.length - 1];
                        }
                        intent3.replaceExtras(intent);
                    }
                    if (intents != null) {
                        intents[intents.length - 1] = rec.key.requestIntent;
                        rec.key.allIntents = intents;
                        rec.key.allResolvedTypes = resolvedTypes;
                    } else {
                        rec.key.allIntents = null;
                        rec.key.allResolvedTypes = null;
                    }
                }
                return rec;
            }
            makeIntentSenderCanceledLocked(rec);
            this.mIntentSenderRecords.remove(key);
        }
        if (noCreate) {
            return rec;
        }
        PendingIntentRecord rec2 = new PendingIntentRecord(this, key, callingUid);
        this.mIntentSenderRecords.put(key, rec2.ref);
        if (type == 3) {
            if (activity2.pendingResults == null) {
                activity2.pendingResults = new HashSet<>();
            }
            activity2.pendingResults.add(rec2.ref);
        }
        return rec2;
    }

    public int sendIntentSender(IIntentSender target, IBinder whitelistToken, int code, Intent intent, String resolvedType, IIntentReceiver finishedReceiver, String requiredPermission, Bundle options) {
        Intent intent2;
        if (target instanceof PendingIntentRecord) {
            return ((PendingIntentRecord) target).sendWithResult(code, intent, resolvedType, whitelistToken, finishedReceiver, requiredPermission, options);
        }
        if (intent == null) {
            Slog.wtf("ActivityManager", "Can't use null intent with direct IIntentSender call");
            intent2 = new Intent("android.intent.action.MAIN");
        } else {
            intent2 = intent;
        }
        try {
            target.send(code, intent2, resolvedType, whitelistToken, (IIntentReceiver) null, requiredPermission, options);
        } catch (RemoteException e) {
        }
        if (finishedReceiver != null) {
            try {
                finishedReceiver.performReceive(intent2, 0, (String) null, (Bundle) null, false, false, UserHandle.getCallingUserId());
                return 0;
            } catch (RemoteException e2) {
                return 0;
            }
        }
        return 0;
    }

    public void cancelIntentSender(IIntentSender sender) {
        if (!(sender instanceof PendingIntentRecord)) {
            return;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                PendingIntentRecord rec = (PendingIntentRecord) sender;
                try {
                    int uid = AppGlobals.getPackageManager().getPackageUid(rec.key.packageName, 268435456, UserHandle.getCallingUserId());
                    if (!UserHandle.isSameApp(uid, Binder.getCallingUid())) {
                        String msg = "Permission Denial: cancelIntentSender() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " is not allowed to cancel package " + rec.key.packageName;
                        Slog.w("ActivityManager", msg);
                        throw new SecurityException(msg);
                    }
                    cancelIntentSenderLocked(rec, true);
                } catch (RemoteException e) {
                    throw new SecurityException(e);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void cancelIntentSenderLocked(PendingIntentRecord rec, boolean cleanActivity) {
        makeIntentSenderCanceledLocked(rec);
        this.mIntentSenderRecords.remove(rec.key);
        if (cleanActivity && rec.key.activity != null) {
            rec.key.activity.pendingResults.remove(rec.ref);
        }
    }

    void makeIntentSenderCanceledLocked(PendingIntentRecord rec) {
        rec.canceled = true;
        RemoteCallbackList<IResultReceiver> callbacks = rec.detachCancelListenersLocked();
        if (callbacks != null) {
            this.mHandler.obtainMessage(67, callbacks).sendToTarget();
        }
    }

    public String getPackageForIntentSender(IIntentSender pendingResult) {
        if (pendingResult instanceof PendingIntentRecord) {
            try {
                PendingIntentRecord res = (PendingIntentRecord) pendingResult;
                return res.key.packageName;
            } catch (ClassCastException e) {
                return null;
            }
        }
        return null;
    }

    public void registerIntentSenderCancelListener(IIntentSender sender, IResultReceiver receiver) {
        boolean isCancelled;
        if (!(sender instanceof PendingIntentRecord)) {
            return;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                PendingIntentRecord pendingIntent = (PendingIntentRecord) sender;
                isCancelled = pendingIntent.canceled;
                if (!isCancelled) {
                    pendingIntent.registerCancelListenerLocked(receiver);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (isCancelled) {
            try {
                receiver.send(0, (Bundle) null);
            } catch (RemoteException e) {
            }
        }
    }

    public void unregisterIntentSenderCancelListener(IIntentSender sender, IResultReceiver receiver) {
        if (!(sender instanceof PendingIntentRecord)) {
            return;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ((PendingIntentRecord) sender).unregisterCancelListenerLocked(receiver);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public int getUidForIntentSender(IIntentSender sender) {
        if (sender instanceof PendingIntentRecord) {
            try {
                PendingIntentRecord res = (PendingIntentRecord) sender;
                return res.uid;
            } catch (ClassCastException e) {
                return -1;
            }
        }
        return -1;
    }

    public boolean isIntentSenderTargetedToPackage(IIntentSender pendingResult) {
        if (pendingResult instanceof PendingIntentRecord) {
            try {
                PendingIntentRecord res = (PendingIntentRecord) pendingResult;
                if (res.key.allIntents == null) {
                    return false;
                }
                for (int i = 0; i < res.key.allIntents.length; i++) {
                    Intent intent = res.key.allIntents[i];
                    if (intent.getPackage() != null && intent.getComponent() != null) {
                        return false;
                    }
                }
                return true;
            } catch (ClassCastException e) {
                return false;
            }
        }
        return false;
    }

    public boolean isIntentSenderAnActivity(IIntentSender pendingResult) {
        if (pendingResult instanceof PendingIntentRecord) {
            try {
                PendingIntentRecord res = (PendingIntentRecord) pendingResult;
                return res.key.type == 2;
            } catch (ClassCastException e) {
                return false;
            }
        }
        return false;
    }

    public boolean isIntentSenderAForegroundService(IIntentSender pendingResult) {
        if (pendingResult instanceof PendingIntentRecord) {
            PendingIntentRecord res = (PendingIntentRecord) pendingResult;
            return res.key.type == 5;
        }
        return false;
    }

    public Intent getIntentForIntentSender(IIntentSender pendingResult) {
        enforceCallingPermission("android.permission.GET_INTENT_SENDER_INTENT", "getIntentForIntentSender()");
        if (pendingResult instanceof PendingIntentRecord) {
            try {
                PendingIntentRecord res = (PendingIntentRecord) pendingResult;
                if (res.key.requestIntent != null) {
                    return new Intent(res.key.requestIntent);
                }
                return null;
            } catch (ClassCastException e) {
                return null;
            }
        }
        return null;
    }

    public String getTagForIntentSender(IIntentSender pendingResult, String prefix) {
        String tagForIntentSenderLocked;
        if (pendingResult instanceof PendingIntentRecord) {
            try {
                PendingIntentRecord res = (PendingIntentRecord) pendingResult;
                synchronized (this) {
                    boostPriorityForLockedSection();
                    tagForIntentSenderLocked = getTagForIntentSenderLocked(res, prefix);
                }
                resetPriorityAfterLockedSection();
                return tagForIntentSenderLocked;
            } catch (ClassCastException e) {
                return null;
            }
        }
        return null;
    }

    String getTagForIntentSenderLocked(PendingIntentRecord res, String prefix) {
        Intent intent = res.key.requestIntent;
        if (intent != null) {
            if (res.lastTag != null && res.lastTagPrefix == prefix && (res.lastTagPrefix == null || res.lastTagPrefix.equals(prefix))) {
                return res.lastTag;
            }
            res.lastTagPrefix = prefix;
            StringBuilder sb = new StringBuilder(128);
            if (prefix != null) {
                sb.append(prefix);
            }
            if (intent.getAction() != null) {
                sb.append(intent.getAction());
            } else if (intent.getComponent() != null) {
                intent.getComponent().appendShortString(sb);
            } else {
                sb.append("?");
            }
            String sb2 = sb.toString();
            res.lastTag = sb2;
            return sb2;
        }
        return null;
    }

    public void setProcessLimit(int max) {
        enforceCallingPermission("android.permission.SET_PROCESS_LIMIT", "setProcessLimit()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mConstants.setOverrideMaxCachedProcesses(max);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        trimApplications();
    }

    public int getProcessLimit() {
        int overrideMaxCachedProcesses;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                overrideMaxCachedProcesses = this.mConstants.getOverrideMaxCachedProcesses();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return overrideMaxCachedProcesses;
    }

    void importanceTokenDied(ImportanceToken token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    ImportanceToken cur = this.mImportantProcesses.get(token.pid);
                    if (cur != token) {
                        resetPriorityAfterLockedSection();
                        return;
                    }
                    this.mImportantProcesses.remove(token.pid);
                    ProcessRecord pr = this.mPidsSelfLocked.get(token.pid);
                    if (pr == null) {
                        resetPriorityAfterLockedSection();
                        return;
                    }
                    pr.forcingToImportant = null;
                    updateProcessForegroundLocked(pr, false, false);
                    updateOomAdjLocked();
                    resetPriorityAfterLockedSection();
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void setProcessImportant(IBinder token, int pid, boolean isForeground, String reason) {
        enforceCallingPermission("android.permission.SET_PROCESS_LIMIT", "setProcessImportant()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                boolean changed = false;
                synchronized (this.mPidsSelfLocked) {
                    ProcessRecord pr = this.mPidsSelfLocked.get(pid);
                    if (pr == null && isForeground) {
                        Slog.w("ActivityManager", "setProcessForeground called on unknown pid: " + pid);
                        resetPriorityAfterLockedSection();
                        return;
                    }
                    ImportanceToken oldToken = this.mImportantProcesses.get(pid);
                    if (oldToken != null) {
                        oldToken.token.unlinkToDeath(oldToken, 0);
                        this.mImportantProcesses.remove(pid);
                        if (pr != null) {
                            pr.forcingToImportant = null;
                        }
                        changed = true;
                    }
                    if (isForeground && token != null) {
                        ImportanceToken newToken = new ImportanceToken(pid, token, reason) { // from class: com.android.server.am.ActivityManagerService.13
                            @Override // android.os.IBinder.DeathRecipient
                            public void binderDied() {
                                ActivityManagerService.this.importanceTokenDied(this);
                            }
                        };
                        try {
                            token.linkToDeath(newToken, 0);
                            this.mImportantProcesses.put(pid, newToken);
                            pr.forcingToImportant = newToken;
                            changed = true;
                        } catch (RemoteException e) {
                        }
                    }
                    if (changed) {
                        updateOomAdjLocked();
                    }
                    resetPriorityAfterLockedSection();
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public boolean isAppForeground(int uid) {
        int callerUid = Binder.getCallingUid();
        if (UserHandle.isCore(callerUid) || callerUid == uid) {
            return isAppForegroundInternal(uid);
        }
        return false;
    }

    private boolean isAppForegroundInternal(int uid) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord uidRec = this.mActiveUids.get(uid);
                if (uidRec != null && !uidRec.idle) {
                    boolean z = uidRec.curProcState <= 5;
                    resetPriorityAfterLockedSection();
                    return z;
                }
                resetPriorityAfterLockedSection();
                return false;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public int getUidState(int uid) {
        int uidStateLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                uidStateLocked = getUidStateLocked(uid);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return uidStateLocked;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public int getUidStateLocked(int uid) {
        UidRecord uidRec = this.mActiveUids.get(uid);
        if (uidRec == null) {
            return 19;
        }
        return uidRec.curProcState;
    }

    public boolean isInMultiWindowMode(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    boolean inMultiWindowMode = r.inMultiWindowMode();
                    resetPriorityAfterLockedSection();
                    return inMultiWindowMode;
                }
                resetPriorityAfterLockedSection();
                return false;
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean isInPictureInPictureMode(IBinder token) {
        boolean isInPictureInPictureMode;
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                isInPictureInPictureMode = isInPictureInPictureMode(ActivityRecord.forTokenLocked(token));
            }
            resetPriorityAfterLockedSection();
            return isInPictureInPictureMode;
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    private boolean isInPictureInPictureMode(ActivityRecord r) {
        if (r == null || r.getStack() == null || !r.inPinnedWindowingMode() || r.getStack().isInStackLocked(r) == null) {
            return false;
        }
        PinnedActivityStack stack = (PinnedActivityStack) r.getStack();
        PinnedStackWindowController windowController = stack.getWindowContainerController();
        return !windowController.isAnimatingBoundsToFullscreen();
    }

    public boolean enterPictureInPictureMode(IBinder token, final PictureInPictureParams params) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                final ActivityRecord r = ensureValidPictureInPictureActivityParamsLocked("enterPictureInPictureMode", token, params);
                if (isInPictureInPictureMode(r)) {
                    resetPriorityAfterLockedSection();
                    return true;
                } else if (!r.checkEnterPictureInPictureState("enterPictureInPictureMode", false)) {
                    resetPriorityAfterLockedSection();
                    return false;
                } else {
                    final Runnable enterPipRunnable = new Runnable() { // from class: com.android.server.am.-$$Lambda$ActivityManagerService$nLON5M4YCRoJpSNB1Y_UERhbBKo
                        @Override // java.lang.Runnable
                        public final void run() {
                            ActivityManagerService.lambda$enterPictureInPictureMode$1(ActivityManagerService.this, r, params);
                        }
                    };
                    if (isKeyguardLocked()) {
                        try {
                            dismissKeyguard(token, new KeyguardDismissCallback() { // from class: com.android.server.am.ActivityManagerService.14
                                public void onDismissSucceeded() throws RemoteException {
                                    ActivityManagerService.this.mHandler.post(enterPipRunnable);
                                }
                            }, null);
                        } catch (RemoteException e) {
                        }
                    } else {
                        enterPipRunnable.run();
                    }
                    resetPriorityAfterLockedSection();
                    return true;
                }
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public static /* synthetic */ void lambda$enterPictureInPictureMode$1(ActivityManagerService activityManagerService, ActivityRecord r, PictureInPictureParams params) {
        r.pictureInPictureArgs.copyOnlySet(params);
        float aspectRatio = r.pictureInPictureArgs.getAspectRatio();
        List<RemoteAction> actions = r.pictureInPictureArgs.getActions();
        Rect sourceBounds = new Rect(r.pictureInPictureArgs.getSourceRectHint());
        activityManagerService.mStackSupervisor.moveActivityToPinnedStackLocked(r, sourceBounds, aspectRatio, "enterPictureInPictureMode");
        PinnedActivityStack stack = (PinnedActivityStack) r.getStack();
        stack.setPictureInPictureAspectRatio(aspectRatio);
        stack.setPictureInPictureActions(actions);
        MetricsLoggerWrapper.logPictureInPictureEnter(activityManagerService.mContext, r.appInfo.uid, r.shortComponentName, r.supportsEnterPipOnTaskSwitch);
        activityManagerService.logPictureInPictureArgs(params);
    }

    public void setPictureInPictureParams(IBinder token, PictureInPictureParams params) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ensureValidPictureInPictureActivityParamsLocked("setPictureInPictureParams", token, params);
                r.pictureInPictureArgs.copyOnlySet(params);
                if (r.inPinnedWindowingMode()) {
                    PinnedActivityStack stack = (PinnedActivityStack) r.getStack();
                    if (!stack.isAnimatingBoundsToFullscreen()) {
                        stack.setPictureInPictureAspectRatio(r.pictureInPictureArgs.getAspectRatio());
                        stack.setPictureInPictureActions(r.pictureInPictureArgs.getActions());
                    }
                }
                logPictureInPictureArgs(params);
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public int getMaxNumPictureInPictureActions(IBinder token) {
        return 3;
    }

    private void logPictureInPictureArgs(PictureInPictureParams params) {
        if (params.hasSetActions()) {
            MetricsLogger.histogram(this.mContext, "tron_varz_picture_in_picture_actions_count", params.getActions().size());
        }
        if (params.hasSetAspectRatio()) {
            LogMaker lm = new LogMaker(824);
            lm.addTaggedData(825, Float.valueOf(params.getAspectRatio()));
            MetricsLogger.action(lm);
        }
    }

    private ActivityRecord ensureValidPictureInPictureActivityParamsLocked(String caller, IBinder token, PictureInPictureParams params) {
        if (!this.mSupportsPictureInPicture) {
            throw new IllegalStateException(caller + ": Device doesn't support picture-in-picture mode.");
        }
        ActivityRecord r = ActivityRecord.forTokenLocked(token);
        if (r == null) {
            throw new IllegalStateException(caller + ": Can't find activity for token=" + token);
        } else if (!r.supportsPictureInPicture()) {
            throw new IllegalStateException(caller + ": Current activity does not support picture-in-picture.");
        } else if (params.hasSetAspectRatio() && !this.mWindowManager.isValidPictureInPictureAspectRatio(r.getStack().mDisplayId, params.getAspectRatio())) {
            float minAspectRatio = this.mContext.getResources().getFloat(17104991);
            float maxAspectRatio = this.mContext.getResources().getFloat(17104990);
            throw new IllegalArgumentException(String.format(caller + ": Aspect ratio is too extreme (must be between %f and %f).", Float.valueOf(minAspectRatio), Float.valueOf(maxAspectRatio)));
        } else {
            params.truncateActions(getMaxNumPictureInPictureActions(token));
            return r;
        }
    }

    /* loaded from: classes.dex */
    static class ProcessInfoService extends IProcessInfoService.Stub {
        final ActivityManagerService mActivityManagerService;

        ProcessInfoService(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        public void getProcessStatesFromPids(int[] pids, int[] states) {
            this.mActivityManagerService.getProcessStatesAndOomScoresForPIDs(pids, states, null);
        }

        public void getProcessStatesAndOomScoresFromPids(int[] pids, int[] states, int[] scores) {
            this.mActivityManagerService.getProcessStatesAndOomScoresForPIDs(pids, states, scores);
        }
    }

    public void getProcessStatesAndOomScoresForPIDs(int[] pids, int[] states, int[] scores) {
        if (scores != null) {
            enforceCallingPermission("android.permission.GET_PROCESS_STATE_AND_OOM_SCORE", "getProcessStatesAndOomScoresForPIDs()");
        }
        if (pids == null) {
            throw new NullPointerException("pids");
        }
        if (states == null) {
            throw new NullPointerException("states");
        }
        if (pids.length != states.length) {
            throw new IllegalArgumentException("pids and states arrays have different lengths!");
        }
        if (scores != null && pids.length != scores.length) {
            throw new IllegalArgumentException("pids and scores arrays have different lengths!");
        }
        synchronized (this.mPidsSelfLocked) {
            for (int i = 0; i < pids.length; i++) {
                ProcessRecord pr = this.mPidsSelfLocked.get(pids[i]);
                states[i] = pr == null ? 19 : pr.curProcState;
                if (scores != null) {
                    scores[i] = pr == null ? -10000 : pr.curAdj;
                }
            }
        }
    }

    /* loaded from: classes.dex */
    static class PermissionController extends IPermissionController.Stub {
        ActivityManagerService mActivityManagerService;

        PermissionController(ActivityManagerService activityManagerService) {
            this.mActivityManagerService = activityManagerService;
        }

        public boolean checkPermission(String permission, int pid, int uid) {
            return this.mActivityManagerService.checkPermission(permission, pid, uid) == 0;
        }

        public int noteOp(String op, int uid, String packageName) {
            return this.mActivityManagerService.mAppOpsService.noteOperation(AppOpsManager.strOpToOp(op), uid, packageName);
        }

        public String[] getPackagesForUid(int uid) {
            return this.mActivityManagerService.mContext.getPackageManager().getPackagesForUid(uid);
        }

        public boolean isRuntimePermission(String permission) {
            try {
                PermissionInfo info = this.mActivityManagerService.mContext.getPackageManager().getPermissionInfo(permission, 0);
                return (info.protectionLevel & 15) == 1;
            } catch (PackageManager.NameNotFoundException nnfe) {
                Slog.e("ActivityManager", "No such permission: " + permission, nnfe);
                return false;
            }
        }

        public int getPackageUid(String packageName, int flags) {
            try {
                return this.mActivityManagerService.mContext.getPackageManager().getPackageUid(packageName, flags);
            } catch (PackageManager.NameNotFoundException e) {
                return -1;
            }
        }
    }

    /* loaded from: classes.dex */
    class IntentFirewallInterface implements IntentFirewall.AMSInterface {
        IntentFirewallInterface() {
        }

        @Override // com.android.server.firewall.IntentFirewall.AMSInterface
        public int checkComponentPermission(String permission, int pid, int uid, int owningUid, boolean exported) {
            return ActivityManagerService.this.checkComponentPermission(permission, pid, uid, owningUid, exported);
        }

        @Override // com.android.server.firewall.IntentFirewall.AMSInterface
        public Object getAMSLock() {
            return ActivityManagerService.this;
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public int checkComponentPermission(String permission, int pid, int uid, int owningUid, boolean exported) {
        if (pid == MY_PID) {
            return 0;
        }
        return ActivityManager.checkComponentPermission(permission, uid, owningUid, exported);
    }

    public int checkPermission(String permission, int pid, int uid) {
        if (permission == null) {
            return -1;
        }
        return checkComponentPermission(permission, pid, uid, -1, true);
    }

    public int checkPermissionWithToken(String permission, int pid, int uid, IBinder callerToken) {
        if (permission == null) {
            return -1;
        }
        Identity tlsIdentity = sCallerIdentity.get();
        if (tlsIdentity != null && tlsIdentity.token == callerToken) {
            Slog.d("ActivityManager", "checkComponentPermission() adjusting {pid,uid} to {" + tlsIdentity.pid + "," + tlsIdentity.uid + "}");
            uid = tlsIdentity.uid;
            pid = tlsIdentity.pid;
        }
        return checkComponentPermission(permission, pid, uid, -1, true);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public int checkCallingPermission(String permission) {
        return checkPermission(permission, Binder.getCallingPid(), UserHandle.getAppId(Binder.getCallingUid()));
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void enforceCallingPermission(String permission, String func) {
        if (checkCallingPermission(permission) == 0) {
            return;
        }
        String msg = "Permission Denial: " + func + " from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + permission;
        Slog.w("ActivityManager", msg);
        throw new SecurityException(msg);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void enforcePermission(String permission, int pid, int uid, String func) {
        if (checkPermission(permission, pid, uid) == 0) {
            return;
        }
        String msg = "Permission Denial: " + func + " from pid=" + pid + ", uid=" + uid + " requires " + permission;
        Slog.w("ActivityManager", msg);
        throw new SecurityException(msg);
    }

    void enforceCallerIsRecentsOrHasPermission(String permission, String func) {
        if (!this.mRecentTasks.isCallerRecents(Binder.getCallingUid())) {
            enforceCallingPermission(permission, func);
        }
    }

    private final boolean checkHoldingPermissionsLocked(IPackageManager pm, ProviderInfo pi, GrantUri grantUri, int uid, int modeFlags) {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v("ActivityManager", "checkHoldingPermissionsLocked: uri=" + grantUri + " uid=" + uid);
        }
        if (UserHandle.getUserId(uid) != grantUri.sourceUserId && ActivityManager.checkComponentPermission("android.permission.INTERACT_ACROSS_USERS", uid, -1, true) != 0) {
            return false;
        }
        return checkHoldingPermissionsInternalLocked(pm, pi, grantUri, uid, modeFlags, true);
    }

    /* JADX WARN: Removed duplicated region for block: B:66:0x00dd A[Catch: RemoteException -> 0x0144, TryCatch #0 {RemoteException -> 0x0144, blocks: (B:44:0x0060, B:50:0x0072, B:53:0x007e, B:55:0x0087, B:59:0x00cc, B:66:0x00dd, B:68:0x00e5, B:72:0x0128), top: B:97:0x0060 }] */
    /* JADX WARN: Removed duplicated region for block: B:76:0x0132  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    private final boolean checkHoldingPermissionsInternalLocked(android.content.pm.IPackageManager r20, android.content.pm.ProviderInfo r21, com.android.server.am.ActivityManagerService.GrantUri r22, int r23, int r24, boolean r25) {
        /*
            Method dump skipped, instructions count: 348
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.checkHoldingPermissionsInternalLocked(android.content.pm.IPackageManager, android.content.pm.ProviderInfo, com.android.server.am.ActivityManagerService$GrantUri, int, int, boolean):boolean");
    }

    public boolean isAppStartModeDisabled(int uid, String packageName) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                z = getAppStartModeLocked(uid, packageName, 0, -1, false, true, false) == 3;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return z;
    }

    int appRestrictedInBackgroundLocked(int uid, String packageName, int packageTargetSdk) {
        if (packageTargetSdk >= 26) {
            if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                Slog.i("ActivityManager", "App " + uid + SliceClientPermissions.SliceAuthority.DELIMITER + packageName + " targets O+, restricted");
            }
            return 2;
        }
        int appop = this.mAppOpsService.noteOperation(HANDLE_TRUST_STORAGE_UPDATE_MSG, uid, packageName);
        if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
            Slog.i("ActivityManager", "Legacy app " + uid + SliceClientPermissions.SliceAuthority.DELIMITER + packageName + " bg appop " + appop);
        }
        switch (appop) {
            case 0:
                if (this.mForceBackgroundCheck && !UserHandle.isCore(uid) && !isOnDeviceIdleWhitelistLocked(uid, true)) {
                    if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                        Slog.i("ActivityManager", "Force background check: " + uid + SliceClientPermissions.SliceAuthority.DELIMITER + packageName + " restricted");
                    }
                    return 1;
                }
                return 0;
            case 1:
                return 1;
            default:
                return 2;
        }
    }

    int appServicesRestrictedInBackgroundLocked(int uid, String packageName, int packageTargetSdk) {
        if (this.mPackageManagerInt.isPackagePersistent(packageName)) {
            if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                Slog.i("ActivityManager", "App " + uid + SliceClientPermissions.SliceAuthority.DELIMITER + packageName + " is persistent; not restricted in background");
            }
            return 0;
        } else if (uidOnBackgroundWhitelist(uid)) {
            if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                Slog.i("ActivityManager", "App " + uid + SliceClientPermissions.SliceAuthority.DELIMITER + packageName + " on background whitelist; not restricted in background");
            }
            return 0;
        } else if (isOnDeviceIdleWhitelistLocked(uid, false)) {
            if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                Slog.i("ActivityManager", "App " + uid + SliceClientPermissions.SliceAuthority.DELIMITER + packageName + " on idle whitelist; not restricted in background");
            }
            return 0;
        } else {
            return appRestrictedInBackgroundLocked(uid, packageName, packageTargetSdk);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public int getAppStartModeLocked(int uid, String packageName, int packageTargetSdk, int callingPid, boolean alwaysRestrict, boolean disabledOnly, boolean forcedStandby) {
        boolean ephemeral;
        int startMode;
        ProcessRecord proc;
        UidRecord uidRec = this.mActiveUids.get(uid);
        if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
            StringBuilder sb = new StringBuilder();
            sb.append("checkAllowBackground: uid=");
            sb.append(uid);
            sb.append(" pkg=");
            sb.append(packageName);
            sb.append(" rec=");
            sb.append(uidRec);
            sb.append(" always=");
            sb.append(alwaysRestrict);
            sb.append(" idle=");
            sb.append(uidRec != null ? uidRec.idle : false);
            Slog.d("ActivityManager", sb.toString());
        }
        if (uidRec == null || alwaysRestrict || forcedStandby || uidRec.idle) {
            if (uidRec == null) {
                ephemeral = getPackageManagerInternalLocked().isPackageEphemeral(UserHandle.getUserId(uid), packageName);
            } else {
                ephemeral = uidRec.ephemeral;
            }
            if (ephemeral) {
                return 3;
            }
            if (disabledOnly) {
                return 0;
            }
            if (alwaysRestrict) {
                startMode = appRestrictedInBackgroundLocked(uid, packageName, packageTargetSdk);
            } else {
                startMode = appServicesRestrictedInBackgroundLocked(uid, packageName, packageTargetSdk);
            }
            if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                Slog.d("ActivityManager", "checkAllowBackground: uid=" + uid + " pkg=" + packageName + " startMode=" + startMode + " onwhitelist=" + isOnDeviceIdleWhitelistLocked(uid, false) + " onwhitelist(ei)=" + isOnDeviceIdleWhitelistLocked(uid, true));
            }
            if (startMode == 1 && callingPid >= 0) {
                synchronized (this.mPidsSelfLocked) {
                    proc = this.mPidsSelfLocked.get(callingPid);
                }
                if (proc != null && !ActivityManager.isProcStateBackground(proc.curProcState)) {
                    return 0;
                }
            }
            return startMode;
        }
        return 0;
    }

    boolean isOnDeviceIdleWhitelistLocked(int uid, boolean allowExceptIdleToo) {
        int[] whitelist;
        int appId = UserHandle.getAppId(uid);
        if (allowExceptIdleToo) {
            whitelist = this.mDeviceIdleExceptIdleWhitelist;
        } else {
            whitelist = this.mDeviceIdleWhitelist;
        }
        return Arrays.binarySearch(whitelist, appId) >= 0 || Arrays.binarySearch(this.mDeviceIdleTempWhitelist, appId) >= 0 || this.mPendingTempWhitelist.indexOfKey(uid) >= 0;
    }

    private ProviderInfo getProviderInfoLocked(String authority, int userHandle, int pmFlags) {
        ContentProviderRecord cpr = this.mProviderMap.getProviderByName(authority, userHandle);
        if (cpr != null) {
            ProviderInfo pi = cpr.info;
            return pi;
        }
        try {
            ProviderInfo pi2 = AppGlobals.getPackageManager().resolveContentProvider(authority, 2048 | pmFlags, userHandle);
            return pi2;
        } catch (RemoteException e) {
            return null;
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void grantEphemeralAccessLocked(int userId, Intent intent, int targetAppId, int ephemeralAppId) {
        getPackageManagerInternalLocked().grantEphemeralAccess(userId, intent, targetAppId, ephemeralAppId);
    }

    @GuardedBy("this")
    private UriPermission findUriPermissionLocked(int targetUid, GrantUri grantUri) {
        ArrayMap<GrantUri, UriPermission> targetUris = this.mGrantedUriPermissions.get(targetUid);
        if (targetUris != null) {
            return targetUris.get(grantUri);
        }
        return null;
    }

    @GuardedBy("this")
    private UriPermission findOrCreateUriPermissionLocked(String sourcePkg, String targetPkg, int targetUid, GrantUri grantUri) {
        ArrayMap<GrantUri, UriPermission> targetUris = this.mGrantedUriPermissions.get(targetUid);
        if (targetUris == null) {
            targetUris = Maps.newArrayMap();
            this.mGrantedUriPermissions.put(targetUid, targetUris);
        }
        UriPermission perm = targetUris.get(grantUri);
        if (perm == null) {
            UriPermission perm2 = new UriPermission(sourcePkg, targetPkg, targetUid, grantUri);
            targetUris.put(grantUri, perm2);
            return perm2;
        }
        return perm;
    }

    @GuardedBy("this")
    private final boolean checkUriPermissionLocked(GrantUri grantUri, int uid, int modeFlags) {
        boolean persistable = (modeFlags & 64) != 0;
        int minStrength = persistable ? 3 : 1;
        if (uid == 0) {
            return true;
        }
        ArrayMap<GrantUri, UriPermission> perms = this.mGrantedUriPermissions.get(uid);
        if (perms == null) {
            return false;
        }
        UriPermission exactPerm = perms.get(grantUri);
        if (exactPerm == null || exactPerm.getStrength(modeFlags) < minStrength) {
            int N = perms.size();
            for (int i = 0; i < N; i++) {
                UriPermission perm = perms.valueAt(i);
                if (perm.uri.prefix && grantUri.uri.isPathPrefixMatch(perm.uri.uri) && perm.getStrength(modeFlags) >= minStrength) {
                    return true;
                }
            }
            return false;
        }
        return true;
    }

    public int checkUriPermission(Uri uri, int pid, int uid, int modeFlags, int userId, IBinder callerToken) {
        enforceNotIsolatedCaller("checkUriPermission");
        Identity tlsIdentity = sCallerIdentity.get();
        if (tlsIdentity != null && tlsIdentity.token == callerToken) {
            uid = tlsIdentity.uid;
            pid = tlsIdentity.pid;
        }
        int i = 0;
        if (pid == MY_PID) {
            return 0;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!checkUriPermissionLocked(new GrantUri(userId, uri, false), uid, modeFlags)) {
                    i = -1;
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return i;
    }

    /* JADX WARN: Removed duplicated region for block: B:88:0x0190  */
    @com.android.internal.annotations.GuardedBy("this")
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    int checkGrantUriPermissionLocked(int r21, java.lang.String r22, com.android.server.am.ActivityManagerService.GrantUri r23, int r24, int r25) {
        /*
            Method dump skipped, instructions count: 662
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.checkGrantUriPermissionLocked(int, java.lang.String, com.android.server.am.ActivityManagerService$GrantUri, int, int):int");
    }

    public int checkGrantUriPermission(int callingUid, String targetPkg, Uri uri, int modeFlags, int userId) {
        int checkGrantUriPermissionLocked;
        enforceNotIsolatedCaller("checkGrantUriPermission");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                checkGrantUriPermissionLocked = checkGrantUriPermissionLocked(callingUid, targetPkg, new GrantUri(userId, uri, false), modeFlags, -1);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return checkGrantUriPermissionLocked;
    }

    @GuardedBy("this")
    void grantUriPermissionUncheckedLocked(int targetUid, String targetPkg, GrantUri grantUri, int modeFlags, UriPermissionOwner owner) {
        if (!Intent.isAccessUriMode(modeFlags)) {
            return;
        }
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v("ActivityManager", "Granting " + targetPkg + SliceClientPermissions.SliceAuthority.DELIMITER + targetUid + " permission to " + grantUri);
        }
        String authority = grantUri.uri.getAuthority();
        ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId, 268435456);
        if (pi == null) {
            Slog.w("ActivityManager", "No content provider found for grant: " + grantUri.toSafeString());
            return;
        }
        if ((modeFlags & 128) != 0) {
            grantUri.prefix = true;
        }
        UriPermission perm = findOrCreateUriPermissionLocked(pi.packageName, targetPkg, targetUid, grantUri);
        perm.grantModes(modeFlags, owner);
    }

    @GuardedBy("this")
    void grantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, int modeFlags, UriPermissionOwner owner, int targetUserId) {
        if (targetPkg == null) {
            throw new NullPointerException(ATTR_TARGET_PKG);
        }
        IPackageManager pm = AppGlobals.getPackageManager();
        try {
            int targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, modeFlags, pm.getPackageUid(targetPkg, 268435456, targetUserId));
            if (targetUid < 0) {
                return;
            }
            grantUriPermissionUncheckedLocked(targetUid, targetPkg, grantUri, modeFlags, owner);
        } catch (RemoteException e) {
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public static class NeededUriGrants extends ArrayList<GrantUri> {
        final int flags;
        final String targetPkg;
        final int targetUid;

        NeededUriGrants(String targetPkg, int targetUid, int flags) {
            this.targetPkg = targetPkg;
            this.targetUid = targetUid;
            this.flags = flags;
        }

        /* JADX INFO: Access modifiers changed from: package-private */
        public void writeToProto(ProtoOutputStream proto, long fieldId) {
            long token = proto.start(fieldId);
            proto.write(1138166333441L, this.targetPkg);
            proto.write(1120986464258L, this.targetUid);
            proto.write(1120986464259L, this.flags);
            int N = size();
            for (int i = 0; i < N; i++) {
                get(i).writeToProto(proto, 2246267895812L);
            }
            proto.end(token);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* JADX WARN: Code restructure failed: missing block: B:45:0x00d4, code lost:
        r12 = r0;
        r0 = r7;
        r16 = 0;
     */
    /* JADX WARN: Code restructure failed: missing block: B:46:0x00d8, code lost:
        r7 = r16;
     */
    /* JADX WARN: Code restructure failed: missing block: B:47:0x00de, code lost:
        if (r7 >= r14.getItemCount()) goto L59;
     */
    /* JADX WARN: Code restructure failed: missing block: B:48:0x00e0, code lost:
        r6 = r14.getItemAt(r7).getUri();
     */
    /* JADX WARN: Code restructure failed: missing block: B:49:0x00e8, code lost:
        if (r6 == null) goto L50;
     */
    /* JADX WARN: Code restructure failed: missing block: B:50:0x00ea, code lost:
        r5 = com.android.server.am.ActivityManagerService.GrantUri.resolve(r15, r6);
        r12 = checkGrantUriPermissionLocked(r20, r21, r5, r23, r12);
     */
    /* JADX WARN: Code restructure failed: missing block: B:51:0x00fd, code lost:
        if (r12 <= 0) goto L47;
     */
    /* JADX WARN: Code restructure failed: missing block: B:52:0x00ff, code lost:
        if (r0 != null) goto L46;
     */
    /* JADX WARN: Code restructure failed: missing block: B:53:0x0101, code lost:
        r0 = new com.android.server.am.ActivityManagerService.NeededUriGrants(r21, r12, r23);
     */
    /* JADX WARN: Code restructure failed: missing block: B:54:0x0107, code lost:
        r0.add(r5);
     */
    /* JADX WARN: Code restructure failed: missing block: B:55:0x010a, code lost:
        r18 = r7;
     */
    /* JADX WARN: Code restructure failed: missing block: B:56:0x010e, code lost:
        r9 = r14.getItemAt(r7).getIntent();
     */
    /* JADX WARN: Code restructure failed: missing block: B:57:0x0118, code lost:
        if (r9 == null) goto L57;
     */
    /* JADX WARN: Code restructure failed: missing block: B:58:0x011a, code lost:
        r18 = r7;
        r1 = checkGrantUriPermissionFromIntentLocked(r20, r21, r9, r23, r0, r25);
     */
    /* JADX WARN: Code restructure failed: missing block: B:59:0x0129, code lost:
        if (r1 == null) goto L56;
     */
    /* JADX WARN: Code restructure failed: missing block: B:60:0x012b, code lost:
        r0 = r1;
     */
    /* JADX WARN: Code restructure failed: missing block: B:61:0x012d, code lost:
        r18 = r7;
     */
    /* JADX WARN: Code restructure failed: missing block: B:62:0x012f, code lost:
        r16 = r18 + 1;
     */
    /* JADX WARN: Code restructure failed: missing block: B:78:?, code lost:
        return r0;
     */
    @com.android.internal.annotations.GuardedBy("this")
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public com.android.server.am.ActivityManagerService.NeededUriGrants checkGrantUriPermissionFromIntentLocked(int r20, java.lang.String r21, android.content.Intent r22, int r23, com.android.server.am.ActivityManagerService.NeededUriGrants r24, int r25) {
        /*
            Method dump skipped, instructions count: 326
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.checkGrantUriPermissionFromIntentLocked(int, java.lang.String, android.content.Intent, int, com.android.server.am.ActivityManagerService$NeededUriGrants, int):com.android.server.am.ActivityManagerService$NeededUriGrants");
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public void grantUriPermissionUncheckedFromIntentLocked(NeededUriGrants needed, UriPermissionOwner owner) {
        if (needed != null) {
            for (int i = 0; i < needed.size(); i++) {
                GrantUri grantUri = needed.get(i);
                grantUriPermissionUncheckedLocked(needed.targetUid, needed.targetPkg, grantUri, needed.flags, owner);
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public void grantUriPermissionFromIntentLocked(int callingUid, String targetPkg, Intent intent, UriPermissionOwner owner, int targetUserId) {
        NeededUriGrants needed = checkGrantUriPermissionFromIntentLocked(callingUid, targetPkg, intent, intent != null ? intent.getFlags() : 0, null, targetUserId);
        if (needed == null) {
            return;
        }
        grantUriPermissionUncheckedFromIntentLocked(needed, owner);
    }

    public void grantUriPermission(IApplicationThread caller, String targetPkg, Uri uri, int modeFlags, int userId) {
        enforceNotIsolatedCaller("grantUriPermission");
        GrantUri grantUri = new GrantUri(userId, uri, false);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord r = getRecordForAppLocked(caller);
                if (r == null) {
                    throw new SecurityException("Unable to find app for caller " + caller + " when granting permission to uri " + grantUri);
                } else if (targetPkg == null) {
                    throw new IllegalArgumentException("null target");
                } else {
                    Preconditions.checkFlagsArgument(modeFlags, (int) HdmiCecKeycode.UI_SOUND_PRESENTATION_TREBLE_STEP_MINUS);
                    grantUriPermissionLocked(r.uid, targetPkg, grantUri, modeFlags, null, UserHandle.getUserId(r.uid));
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public void removeUriPermissionIfNeededLocked(UriPermission perm) {
        ArrayMap<GrantUri, UriPermission> perms;
        if (perm.modeFlags == 0 && (perms = this.mGrantedUriPermissions.get(perm.targetUid)) != null) {
            if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                Slog.v("ActivityManager", "Removing " + perm.targetUid + " permission to " + perm.uri);
            }
            perms.remove(perm.uri);
            if (perms.isEmpty()) {
                this.mGrantedUriPermissions.remove(perm.targetUid);
            }
        }
    }

    @GuardedBy("this")
    private void revokeUriPermissionLocked(String targetPackage, int callingUid, GrantUri grantUri, int modeFlags) {
        int targetUid;
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v("ActivityManager", "Revoking all granted permissions to " + grantUri);
        }
        IPackageManager pm = AppGlobals.getPackageManager();
        String authority = grantUri.uri.getAuthority();
        ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId, 786432);
        if (pi == null) {
            Slog.w("ActivityManager", "No content provider found for permission revoke: " + grantUri.toSafeString());
            return;
        }
        int i = 1;
        if (!checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags)) {
            ArrayMap<GrantUri, UriPermission> perms = this.mGrantedUriPermissions.get(callingUid);
            if (perms != null) {
                boolean persistChanged = false;
                int i2 = perms.size() - 1;
                while (true) {
                    int i3 = i2;
                    if (i3 < 0) {
                        break;
                    }
                    UriPermission perm = perms.valueAt(i3);
                    if ((targetPackage == null || targetPackage.equals(perm.targetPkg)) && perm.uri.sourceUserId == grantUri.sourceUserId && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                            Slog.v("ActivityManager", "Revoking non-owned " + perm.targetUid + " permission to " + perm.uri);
                        }
                        persistChanged |= perm.revokeModes(modeFlags | 64, false);
                        if (perm.modeFlags == 0) {
                            perms.removeAt(i3);
                        }
                    }
                    i2 = i3 - 1;
                }
                if (perms.isEmpty()) {
                    this.mGrantedUriPermissions.remove(callingUid);
                }
                if (persistChanged) {
                    schedulePersistUriGrants();
                    return;
                }
                return;
            }
            return;
        }
        boolean persistChanged2 = false;
        int i4 = this.mGrantedUriPermissions.size() - 1;
        while (i4 >= 0) {
            int targetUid2 = this.mGrantedUriPermissions.keyAt(i4);
            ArrayMap<GrantUri, UriPermission> perms2 = this.mGrantedUriPermissions.valueAt(i4);
            int j = perms2.size() - i;
            while (j >= 0) {
                UriPermission perm2 = perms2.valueAt(j);
                if (targetPackage != null && !targetPackage.equals(perm2.targetPkg)) {
                    targetUid = targetUid2;
                } else if (perm2.uri.sourceUserId != grantUri.sourceUserId || !perm2.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                    targetUid = targetUid2;
                } else {
                    if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                        StringBuilder sb = new StringBuilder();
                        targetUid = targetUid2;
                        sb.append("Revoking ");
                        sb.append(perm2.targetUid);
                        sb.append(" permission to ");
                        sb.append(perm2.uri);
                        Slog.v("ActivityManager", sb.toString());
                    } else {
                        targetUid = targetUid2;
                    }
                    persistChanged2 |= perm2.revokeModes(modeFlags | 64, targetPackage == null);
                    if (perm2.modeFlags == 0) {
                        perms2.removeAt(j);
                    }
                }
                j--;
                targetUid2 = targetUid;
            }
            if (perms2.isEmpty()) {
                this.mGrantedUriPermissions.removeAt(i4);
            }
            i4--;
            i = 1;
        }
        if (persistChanged2) {
            schedulePersistUriGrants();
        }
    }

    public void revokeUriPermission(IApplicationThread caller, String targetPackage, Uri uri, int modeFlags, int userId) {
        enforceNotIsolatedCaller("revokeUriPermission");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord r = getRecordForAppLocked(caller);
                if (r == null) {
                    throw new SecurityException("Unable to find app for caller " + caller + " when revoking permission to uri " + uri);
                } else if (uri == null) {
                    Slog.w("ActivityManager", "revokeUriPermission: null uri");
                    resetPriorityAfterLockedSection();
                } else if (!Intent.isAccessUriMode(modeFlags)) {
                    resetPriorityAfterLockedSection();
                } else {
                    String authority = uri.getAuthority();
                    ProviderInfo pi = getProviderInfoLocked(authority, userId, 786432);
                    if (pi == null) {
                        Slog.w("ActivityManager", "No content provider found for permission revoke: " + uri.toSafeString());
                        resetPriorityAfterLockedSection();
                        return;
                    }
                    revokeUriPermissionLocked(targetPackage, r.uid, new GrantUri(userId, uri, false), modeFlags);
                    resetPriorityAfterLockedSection();
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    @GuardedBy("this")
    private void removeUriPermissionsForPackageLocked(String packageName, int userHandle, boolean persistable, boolean targetOnly) {
        if (userHandle == -1 && packageName == null) {
            throw new IllegalArgumentException("Must narrow by either package or user");
        }
        boolean persistChanged = false;
        int N = this.mGrantedUriPermissions.size();
        int i = 0;
        while (i < N) {
            int targetUid = this.mGrantedUriPermissions.keyAt(i);
            ArrayMap<GrantUri, UriPermission> perms = this.mGrantedUriPermissions.valueAt(i);
            if (userHandle == -1 || userHandle == UserHandle.getUserId(targetUid)) {
                Iterator<UriPermission> it = perms.values().iterator();
                while (it.hasNext()) {
                    UriPermission perm = it.next();
                    if (packageName == null || ((!targetOnly && perm.sourcePkg.equals(packageName)) || perm.targetPkg.equals(packageName))) {
                        if (!"downloads".equals(perm.uri.uri.getAuthority()) || persistable) {
                            persistChanged |= perm.revokeModes(persistable ? -1 : -65, true);
                            if (perm.modeFlags == 0) {
                                it.remove();
                            }
                        }
                    }
                }
                if (perms.isEmpty()) {
                    this.mGrantedUriPermissions.remove(targetUid);
                    N--;
                    i--;
                }
            }
            i++;
        }
        if (persistChanged) {
            schedulePersistUriGrants();
        }
    }

    public IBinder newUriPermissionOwner(String name) {
        Binder externalTokenLocked;
        enforceNotIsolatedCaller("newUriPermissionOwner");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UriPermissionOwner owner = new UriPermissionOwner(this, name);
                externalTokenLocked = owner.getExternalTokenLocked();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return externalTokenLocked;
    }

    public IBinder getUriPermissionOwnerForActivity(IBinder activityToken) {
        Binder externalTokenLocked;
        enforceNotIsolatedCaller("getUriPermissionOwnerForActivity");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);
                if (r == null) {
                    throw new IllegalArgumentException("Activity does not exist; token=" + activityToken);
                }
                externalTokenLocked = r.getUriPermissionsLocked().getExternalTokenLocked();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return externalTokenLocked;
    }

    public void grantUriPermissionFromOwner(IBinder token, int fromUid, String targetPkg, Uri uri, int modeFlags, int sourceUserId, int targetUserId) {
        int targetUserId2 = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), targetUserId, false, 2, "grantUriPermissionFromOwner", null);
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    UriPermissionOwner owner = UriPermissionOwner.fromExternalToken(token);
                    try {
                        if (owner == null) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("Unknown owner: ");
                            sb.append(token);
                            throw new IllegalArgumentException(sb.toString());
                        }
                        try {
                            if (fromUid != Binder.getCallingUid()) {
                                try {
                                    if (Binder.getCallingUid() != Process.myUid()) {
                                        throw new SecurityException("nice try");
                                    }
                                } catch (Throwable th) {
                                    th = th;
                                    resetPriorityAfterLockedSection();
                                    throw th;
                                }
                            }
                            if (targetPkg == null) {
                                throw new IllegalArgumentException("null target");
                            }
                            if (uri == null) {
                                throw new IllegalArgumentException("null uri");
                            }
                            try {
                                grantUriPermissionLocked(fromUid, targetPkg, new GrantUri(sourceUserId, uri, false), modeFlags, owner, targetUserId2);
                                resetPriorityAfterLockedSection();
                            } catch (Throwable th2) {
                                th = th2;
                                resetPriorityAfterLockedSection();
                                throw th;
                            }
                        } catch (Throwable th3) {
                            th = th3;
                        }
                    } catch (Throwable th4) {
                        th = th4;
                    }
                } catch (Throwable th5) {
                    th = th5;
                }
            } catch (Throwable th6) {
                th = th6;
            }
        }
    }

    public void revokeUriPermissionFromOwner(IBinder token, Uri uri, int mode, int userId) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UriPermissionOwner owner = UriPermissionOwner.fromExternalToken(token);
                if (owner == null) {
                    throw new IllegalArgumentException("Unknown owner: " + token);
                } else if (uri == null) {
                    owner.removeUriPermissionsLocked(mode);
                } else {
                    boolean prefix = (mode & 128) != 0;
                    owner.removeUriPermissionLocked(new GrantUri(userId, uri, prefix), mode);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    private void schedulePersistUriGrants() {
        if (!this.mHandler.hasMessages(38)) {
            this.mHandler.sendMessageDelayed(this.mHandler.obtainMessage(38), JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY);
        }
    }

    /* JADX INFO: Access modifiers changed from: private */
    public void writeGrantedUriPermissions() {
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v("ActivityManager", "writeGrantedUriPermissions()");
        }
        long startTime = SystemClock.uptimeMillis();
        ArrayList<UriPermission.Snapshot> persist = Lists.newArrayList();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int size = this.mGrantedUriPermissions.size();
                for (int i = 0; i < size; i++) {
                    ArrayMap<GrantUri, UriPermission> perms = this.mGrantedUriPermissions.valueAt(i);
                    for (UriPermission perm : perms.values()) {
                        if (perm.persistedModeFlags != 0) {
                            persist.add(perm.snapshot());
                        }
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        FileOutputStream fos = null;
        try {
            fos = this.mGrantFile.startWrite(startTime);
            FastXmlSerializer fastXmlSerializer = new FastXmlSerializer();
            fastXmlSerializer.setOutput(fos, StandardCharsets.UTF_8.name());
            fastXmlSerializer.startDocument(null, true);
            fastXmlSerializer.startTag(null, TAG_URI_GRANTS);
            Iterator<UriPermission.Snapshot> it = persist.iterator();
            while (it.hasNext()) {
                UriPermission.Snapshot perm2 = it.next();
                fastXmlSerializer.startTag(null, TAG_URI_GRANT);
                XmlUtils.writeIntAttribute(fastXmlSerializer, ATTR_SOURCE_USER_ID, perm2.uri.sourceUserId);
                XmlUtils.writeIntAttribute(fastXmlSerializer, ATTR_TARGET_USER_ID, perm2.targetUserId);
                fastXmlSerializer.attribute(null, ATTR_SOURCE_PKG, perm2.sourcePkg);
                fastXmlSerializer.attribute(null, ATTR_TARGET_PKG, perm2.targetPkg);
                fastXmlSerializer.attribute(null, ATTR_URI, String.valueOf(perm2.uri.uri));
                XmlUtils.writeBooleanAttribute(fastXmlSerializer, ATTR_PREFIX, perm2.uri.prefix);
                XmlUtils.writeIntAttribute(fastXmlSerializer, ATTR_MODE_FLAGS, perm2.persistedModeFlags);
                XmlUtils.writeLongAttribute(fastXmlSerializer, ATTR_CREATED_TIME, perm2.persistedCreateTime);
                fastXmlSerializer.endTag(null, TAG_URI_GRANT);
            }
            fastXmlSerializer.endTag(null, TAG_URI_GRANTS);
            fastXmlSerializer.endDocument();
            this.mGrantFile.finishWrite(fos);
        } catch (IOException e) {
            if (fos != null) {
                this.mGrantFile.failWrite(fos);
            }
        }
    }

    @GuardedBy("this")
    private void readGrantedUriPermissionsLocked() {
        XmlPullParser in;
        long now;
        XmlPullParser in2;
        int sourceUserId;
        int targetUserId;
        ActivityManagerService activityManagerService = this;
        if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
            Slog.v("ActivityManager", "readGrantedUriPermissions()");
        }
        long now2 = System.currentTimeMillis();
        String str = null;
        FileInputStream fis = null;
        try {
            try {
                fis = activityManagerService.mGrantFile.openRead();
                in = Xml.newPullParser();
                in.setInput(fis, StandardCharsets.UTF_8.name());
            } catch (Throwable th) {
                th = th;
                IoUtils.closeQuietly(fis);
                throw th;
            }
        } catch (FileNotFoundException e) {
        } catch (IOException e2) {
            e = e2;
        } catch (XmlPullParserException e3) {
            e = e3;
        } catch (Throwable th2) {
            th = th2;
            IoUtils.closeQuietly(fis);
            throw th;
        }
        while (true) {
            int type = in.next();
            if (type == 1) {
                break;
            }
            String tag = in.getName();
            if (type == 2 && TAG_URI_GRANT.equals(tag)) {
                int userHandle = XmlUtils.readIntAttribute(in, ATTR_USER_HANDLE, -10000);
                if (userHandle != -10000) {
                    sourceUserId = userHandle;
                    targetUserId = userHandle;
                } else {
                    sourceUserId = XmlUtils.readIntAttribute(in, ATTR_SOURCE_USER_ID);
                    targetUserId = XmlUtils.readIntAttribute(in, ATTR_TARGET_USER_ID);
                }
                int sourceUserId2 = sourceUserId;
                String sourcePkg = in.getAttributeValue(str, ATTR_SOURCE_PKG);
                String targetPkg = in.getAttributeValue(str, ATTR_TARGET_PKG);
                Uri uri = Uri.parse(in.getAttributeValue(str, ATTR_URI));
                boolean prefix = XmlUtils.readBooleanAttribute(in, ATTR_PREFIX);
                int modeFlags = XmlUtils.readIntAttribute(in, ATTR_MODE_FLAGS);
                long createdTime = XmlUtils.readLongAttribute(in, ATTR_CREATED_TIME, now2);
                ProviderInfo pi = activityManagerService.getProviderInfoLocked(uri.getAuthority(), sourceUserId2, 786432);
                if (pi == null || !sourcePkg.equals(pi.packageName)) {
                    now = now2;
                    in2 = in;
                    Slog.w("ActivityManager", "Persisted grant for " + uri + " had source " + sourcePkg + " but instead found " + pi);
                } else {
                    now = now2;
                    int targetUid = -1;
                    try {
                        try {
                            targetUid = AppGlobals.getPackageManager().getPackageUid(targetPkg, 8192, targetUserId);
                        } catch (RemoteException e4) {
                        }
                        if (targetUid != -1) {
                            UriPermission perm = activityManagerService.findOrCreateUriPermissionLocked(sourcePkg, targetPkg, targetUid, new GrantUri(sourceUserId2, uri, prefix));
                            in2 = in;
                            perm.initPersistedModes(modeFlags, createdTime);
                        } else {
                            in2 = in;
                        }
                    } catch (FileNotFoundException e5) {
                    } catch (IOException e6) {
                        e = e6;
                        Slog.wtf("ActivityManager", "Failed reading Uri grants", e);
                        IoUtils.closeQuietly(fis);
                    } catch (XmlPullParserException e7) {
                        e = e7;
                        Slog.wtf("ActivityManager", "Failed reading Uri grants", e);
                        IoUtils.closeQuietly(fis);
                    }
                }
            } else {
                now = now2;
                in2 = in;
            }
            now2 = now;
            in = in2;
            activityManagerService = this;
            str = null;
            IoUtils.closeQuietly(fis);
        }
        IoUtils.closeQuietly(fis);
    }

    /* JADX WARN: Code restructure failed: missing block: B:24:0x0075, code lost:
        r2 = false | r4.takePersistableModes(r12);
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public void takePersistableUriPermission(android.net.Uri r11, int r12, java.lang.String r13, int r14) {
        /*
            r10 = this;
            r0 = 0
            if (r13 == 0) goto L12
            java.lang.String r1 = "android.permission.FORCE_PERSISTABLE_URI_PERMISSIONS"
            java.lang.String r2 = "takePersistableUriPermission"
            r10.enforceCallingPermission(r1, r2)
            android.content.pm.PackageManagerInternal r1 = r10.mPackageManagerInt
            int r1 = r1.getPackageUid(r13, r0, r14)
            goto L1c
        L12:
            java.lang.String r1 = "takePersistableUriPermission"
            r10.enforceNotIsolatedCaller(r1)
            int r1 = android.os.Binder.getCallingUid()
        L1c:
            r2 = 3
            com.android.internal.util.Preconditions.checkFlagsArgument(r12, r2)
            monitor-enter(r10)
            boostPriorityForLockedSection()     // Catch: java.lang.Throwable -> L90
            r2 = 0
            com.android.server.am.ActivityManagerService$GrantUri r3 = new com.android.server.am.ActivityManagerService$GrantUri     // Catch: java.lang.Throwable -> L90
            r3.<init>(r14, r11, r0)     // Catch: java.lang.Throwable -> L90
            com.android.server.am.UriPermission r4 = r10.findUriPermissionLocked(r1, r3)     // Catch: java.lang.Throwable -> L90
            com.android.server.am.ActivityManagerService$GrantUri r5 = new com.android.server.am.ActivityManagerService$GrantUri     // Catch: java.lang.Throwable -> L90
            r6 = 1
            r5.<init>(r14, r11, r6)     // Catch: java.lang.Throwable -> L90
            com.android.server.am.UriPermission r5 = r10.findUriPermissionLocked(r1, r5)     // Catch: java.lang.Throwable -> L90
            if (r4 == 0) goto L41
            int r7 = r4.persistableModeFlags     // Catch: java.lang.Throwable -> L90
            r7 = r7 & r12
            if (r7 != r12) goto L41
            r7 = r6
            goto L42
        L41:
            r7 = r0
        L42:
            if (r5 == 0) goto L4b
            int r8 = r5.persistableModeFlags     // Catch: java.lang.Throwable -> L90
            r8 = r8 & r12
            if (r8 != r12) goto L4b
            r0 = r6
        L4b:
            if (r7 != 0) goto L73
            if (r0 == 0) goto L50
            goto L73
        L50:
            java.lang.SecurityException r6 = new java.lang.SecurityException     // Catch: java.lang.Throwable -> L90
            java.lang.StringBuilder r8 = new java.lang.StringBuilder     // Catch: java.lang.Throwable -> L90
            r8.<init>()     // Catch: java.lang.Throwable -> L90
            java.lang.String r9 = "No persistable permission grants found for UID "
            r8.append(r9)     // Catch: java.lang.Throwable -> L90
            r8.append(r1)     // Catch: java.lang.Throwable -> L90
            java.lang.String r9 = " and Uri "
            r8.append(r9)     // Catch: java.lang.Throwable -> L90
            java.lang.String r9 = r3.toSafeString()     // Catch: java.lang.Throwable -> L90
            r8.append(r9)     // Catch: java.lang.Throwable -> L90
            java.lang.String r8 = r8.toString()     // Catch: java.lang.Throwable -> L90
            r6.<init>(r8)     // Catch: java.lang.Throwable -> L90
            throw r6     // Catch: java.lang.Throwable -> L90
        L73:
            if (r7 == 0) goto L7a
            boolean r6 = r4.takePersistableModes(r12)     // Catch: java.lang.Throwable -> L90
            r2 = r2 | r6
        L7a:
            if (r0 == 0) goto L81
            boolean r6 = r5.takePersistableModes(r12)     // Catch: java.lang.Throwable -> L90
            r2 = r2 | r6
        L81:
            boolean r6 = r10.maybePrunePersistedUriGrantsLocked(r1)     // Catch: java.lang.Throwable -> L90
            r2 = r2 | r6
            if (r2 == 0) goto L8b
            r10.schedulePersistUriGrants()     // Catch: java.lang.Throwable -> L90
        L8b:
            monitor-exit(r10)     // Catch: java.lang.Throwable -> L90
            resetPriorityAfterLockedSection()
            return
        L90:
            r0 = move-exception
            monitor-exit(r10)     // Catch: java.lang.Throwable -> L90
            resetPriorityAfterLockedSection()
            throw r0
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.takePersistableUriPermission(android.net.Uri, int, java.lang.String, int):void");
    }

    /* JADX WARN: Code restructure failed: missing block: B:16:0x0064, code lost:
        r2 = false | r0.releasePersistableModes(r9);
        removeUriPermissionIfNeededLocked(r0);
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public void releasePersistableUriPermission(android.net.Uri r8, int r9, java.lang.String r10, int r11) {
        /*
            r7 = this;
            r0 = 0
            if (r10 == 0) goto L12
            java.lang.String r1 = "android.permission.FORCE_PERSISTABLE_URI_PERMISSIONS"
            java.lang.String r2 = "releasePersistableUriPermission"
            r7.enforceCallingPermission(r1, r2)
            android.content.pm.PackageManagerInternal r1 = r7.mPackageManagerInt
            int r1 = r1.getPackageUid(r10, r0, r11)
            goto L1c
        L12:
            java.lang.String r1 = "releasePersistableUriPermission"
            r7.enforceNotIsolatedCaller(r1)
            int r1 = android.os.Binder.getCallingUid()
        L1c:
            r2 = 3
            com.android.internal.util.Preconditions.checkFlagsArgument(r9, r2)
            monitor-enter(r7)
            boostPriorityForLockedSection()     // Catch: java.lang.Throwable -> L80
            r2 = 0
            com.android.server.am.ActivityManagerService$GrantUri r3 = new com.android.server.am.ActivityManagerService$GrantUri     // Catch: java.lang.Throwable -> L80
            r3.<init>(r11, r8, r0)     // Catch: java.lang.Throwable -> L80
            com.android.server.am.UriPermission r0 = r7.findUriPermissionLocked(r1, r3)     // Catch: java.lang.Throwable -> L80
            com.android.server.am.ActivityManagerService$GrantUri r3 = new com.android.server.am.ActivityManagerService$GrantUri     // Catch: java.lang.Throwable -> L80
            r4 = 1
            r3.<init>(r11, r8, r4)     // Catch: java.lang.Throwable -> L80
            com.android.server.am.UriPermission r3 = r7.findUriPermissionLocked(r1, r3)     // Catch: java.lang.Throwable -> L80
            if (r0 != 0) goto L62
            if (r3 != 0) goto L62
            if (r10 == 0) goto L3f
            goto L62
        L3f:
            java.lang.SecurityException r4 = new java.lang.SecurityException     // Catch: java.lang.Throwable -> L80
            java.lang.StringBuilder r5 = new java.lang.StringBuilder     // Catch: java.lang.Throwable -> L80
            r5.<init>()     // Catch: java.lang.Throwable -> L80
            java.lang.String r6 = "No permission grants found for UID "
            r5.append(r6)     // Catch: java.lang.Throwable -> L80
            r5.append(r1)     // Catch: java.lang.Throwable -> L80
            java.lang.String r6 = " and Uri "
            r5.append(r6)     // Catch: java.lang.Throwable -> L80
            java.lang.String r6 = r8.toSafeString()     // Catch: java.lang.Throwable -> L80
            r5.append(r6)     // Catch: java.lang.Throwable -> L80
            java.lang.String r5 = r5.toString()     // Catch: java.lang.Throwable -> L80
            r4.<init>(r5)     // Catch: java.lang.Throwable -> L80
            throw r4     // Catch: java.lang.Throwable -> L80
        L62:
            if (r0 == 0) goto L6c
            boolean r4 = r0.releasePersistableModes(r9)     // Catch: java.lang.Throwable -> L80
            r2 = r2 | r4
            r7.removeUriPermissionIfNeededLocked(r0)     // Catch: java.lang.Throwable -> L80
        L6c:
            if (r3 == 0) goto L76
            boolean r4 = r3.releasePersistableModes(r9)     // Catch: java.lang.Throwable -> L80
            r2 = r2 | r4
            r7.removeUriPermissionIfNeededLocked(r3)     // Catch: java.lang.Throwable -> L80
        L76:
            if (r2 == 0) goto L7b
            r7.schedulePersistUriGrants()     // Catch: java.lang.Throwable -> L80
        L7b:
            monitor-exit(r7)     // Catch: java.lang.Throwable -> L80
            resetPriorityAfterLockedSection()
            return
        L80:
            r0 = move-exception
            monitor-exit(r7)     // Catch: java.lang.Throwable -> L80
            resetPriorityAfterLockedSection()
            throw r0
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.releasePersistableUriPermission(android.net.Uri, int, java.lang.String, int):void");
    }

    @GuardedBy("this")
    private boolean maybePrunePersistedUriGrantsLocked(int uid) {
        ArrayMap<GrantUri, UriPermission> perms = this.mGrantedUriPermissions.get(uid);
        if (perms == null || perms.size() < 128) {
            return false;
        }
        ArrayList<UriPermission> persisted = Lists.newArrayList();
        for (UriPermission perm : perms.values()) {
            if (perm.persistedModeFlags != 0) {
                persisted.add(perm);
            }
        }
        int trimCount = persisted.size() - 128;
        if (trimCount <= 0) {
            return false;
        }
        Collections.sort(persisted, new UriPermission.PersistedTimeComparator());
        for (int i = 0; i < trimCount; i++) {
            UriPermission perm2 = persisted.get(i);
            if (ActivityManagerDebugConfig.DEBUG_URI_PERMISSION) {
                Slog.v("ActivityManager", "Trimming grant created at " + perm2.persistedCreateTime);
            }
            perm2.releasePersistableModes(-1);
            removeUriPermissionIfNeededLocked(perm2);
        }
        return true;
    }

    public ParceledListSlice<android.content.UriPermission> getPersistedUriPermissions(String packageName, boolean incoming) {
        enforceNotIsolatedCaller("getPersistedUriPermissions");
        Preconditions.checkNotNull(packageName, "packageName");
        int callingUid = Binder.getCallingUid();
        int callingUserId = UserHandle.getUserId(callingUid);
        IPackageManager pm = AppGlobals.getPackageManager();
        try {
            int packageUid = pm.getPackageUid(packageName, 786432, callingUserId);
            if (packageUid != callingUid) {
                throw new SecurityException("Package " + packageName + " does not belong to calling UID " + callingUid);
            }
            ArrayList<android.content.UriPermission> result = Lists.newArrayList();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (incoming) {
                        ArrayMap<GrantUri, UriPermission> perms = this.mGrantedUriPermissions.get(callingUid);
                        if (perms == null) {
                            Slog.w("ActivityManager", "No permission grants found for " + packageName);
                        } else {
                            for (int j = 0; j < perms.size(); j++) {
                                UriPermission perm = perms.valueAt(j);
                                if (packageName.equals(perm.targetPkg) && perm.persistedModeFlags != 0) {
                                    result.add(perm.buildPersistedPublicApiObject());
                                }
                            }
                        }
                    } else {
                        int size = this.mGrantedUriPermissions.size();
                        for (int i = 0; i < size; i++) {
                            ArrayMap<GrantUri, UriPermission> perms2 = this.mGrantedUriPermissions.valueAt(i);
                            for (int j2 = 0; j2 < perms2.size(); j2++) {
                                UriPermission perm2 = perms2.valueAt(j2);
                                if (packageName.equals(perm2.sourcePkg) && perm2.persistedModeFlags != 0) {
                                    result.add(perm2.buildPersistedPublicApiObject());
                                }
                            }
                        }
                    }
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            resetPriorityAfterLockedSection();
            return new ParceledListSlice<>(result);
        } catch (RemoteException e) {
            throw new SecurityException("Failed to verify package name ownership");
        }
    }

    public ParceledListSlice<GrantedUriPermission> getGrantedUriPermissions(String packageName, int userId) {
        enforceCallingPermission("android.permission.GET_APP_GRANTED_URI_PERMISSIONS", "getGrantedUriPermissions");
        List<GrantedUriPermission> result = new ArrayList<>();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int size = this.mGrantedUriPermissions.size();
                for (int i = 0; i < size; i++) {
                    ArrayMap<GrantUri, UriPermission> perms = this.mGrantedUriPermissions.valueAt(i);
                    for (int j = 0; j < perms.size(); j++) {
                        UriPermission perm = perms.valueAt(j);
                        if ((packageName == null || packageName.equals(perm.targetPkg)) && perm.targetUserId == userId && perm.persistedModeFlags != 0) {
                            result.add(perm.buildGrantedUriPermission());
                        }
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return new ParceledListSlice<>(result);
    }

    public void clearGrantedUriPermissions(String packageName, int userId) {
        enforceCallingPermission("android.permission.CLEAR_APP_GRANTED_URI_PERMISSIONS", "clearGrantedUriPermissions");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                removeUriPermissionsForPackageLocked(packageName, userId, true, true);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void showWaitingForDebugger(IApplicationThread who, boolean waiting) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord app = who != null ? getRecordForAppLocked(who) : null;
                if (app == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                Message msg = Message.obtain();
                msg.what = 6;
                msg.obj = app;
                msg.arg1 = waiting ? 1 : 0;
                this.mUiHandler.sendMessage(msg);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void getMemoryInfo(ActivityManager.MemoryInfo outInfo) {
        long homeAppMem = this.mProcessList.getMemLevel(600);
        long cachedAppMem = this.mProcessList.getMemLevel(900);
        outInfo.availMem = Process.getFreeMemory();
        outInfo.totalMem = Process.getTotalMemory();
        outInfo.threshold = homeAppMem;
        outInfo.lowMemory = outInfo.availMem < ((cachedAppMem - homeAppMem) / 2) + homeAppMem;
        outInfo.hiddenAppThreshold = cachedAppMem;
        outInfo.secondaryServerThreshold = this.mProcessList.getMemLevel(500);
        outInfo.visibleAppThreshold = this.mProcessList.getMemLevel(100);
        outInfo.foregroundAppThreshold = this.mProcessList.getMemLevel(0);
    }

    public List<IBinder> getAppTasks(String callingPackage) {
        ArrayList<IBinder> appTasksList;
        int callingUid = Binder.getCallingUid();
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                appTasksList = this.mRecentTasks.getAppTasksList(callingUid, callingPackage);
            }
            resetPriorityAfterLockedSection();
            return appTasksList;
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public List<ActivityManager.RunningTaskInfo> getTasks(int maxNum) {
        return getFilteredTasks(maxNum, 0, 0);
    }

    public List<ActivityManager.RunningTaskInfo> getFilteredTasks(int maxNum, @WindowConfiguration.ActivityType int ignoreActivityType, @WindowConfiguration.WindowingMode int ignoreWindowingMode) {
        int callingUid = Binder.getCallingUid();
        ArrayList<ActivityManager.RunningTaskInfo> list = new ArrayList<>();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (ActivityManagerDebugConfig.DEBUG_ALL) {
                    Slog.v("ActivityManager", "getTasks: max=" + maxNum);
                }
                boolean allowed = isGetTasksAllowed("getTasks", Binder.getCallingPid(), callingUid);
                this.mStackSupervisor.getRunningTasks(maxNum, list, ignoreActivityType, ignoreWindowingMode, callingUid, allowed);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return list;
    }

    private boolean isGetTasksAllowed(String caller, int callingPid, int callingUid) {
        if (this.mRecentTasks.isCallerRecents(callingUid)) {
            return true;
        }
        boolean allowed = checkPermission("android.permission.REAL_GET_TASKS", callingPid, callingUid) == 0;
        if (!allowed && checkPermission("android.permission.GET_TASKS", callingPid, callingUid) == 0) {
            try {
                if (AppGlobals.getPackageManager().isUidPrivileged(callingUid)) {
                    allowed = true;
                    if (ActivityManagerDebugConfig.DEBUG_TASKS) {
                        Slog.w("ActivityManager", caller + ": caller " + callingUid + " is using old GET_TASKS but privileged; allowing");
                    }
                }
            } catch (RemoteException e) {
            }
        }
        if (!allowed && ActivityManagerDebugConfig.DEBUG_TASKS) {
            Slog.w("ActivityManager", caller + ": caller " + callingUid + " does not hold REAL_GET_TASKS; limiting output");
        }
        return allowed;
    }

    public ParceledListSlice<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags, int userId) {
        ParceledListSlice<ActivityManager.RecentTaskInfo> recentTasks;
        int callingUid = Binder.getCallingUid();
        int userId2 = this.mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid, userId, false, 2, "getRecentTasks", null);
        boolean allowed = isGetTasksAllowed("getRecentTasks", Binder.getCallingPid(), callingUid);
        boolean detailed = checkCallingPermission("android.permission.GET_DETAILED_TASKS") == 0;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                recentTasks = this.mRecentTasks.getRecentTasks(maxNum, flags, allowed, detailed, userId2, callingUid);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return recentTasks;
    }

    public ActivityManager.TaskDescription getTaskDescription(int id) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getTaskDescription()");
                TaskRecord tr = this.mStackSupervisor.anyTaskForIdLocked(id, 1);
                if (tr != null) {
                    ActivityManager.TaskDescription taskDescription = tr.lastTaskDescription;
                    resetPriorityAfterLockedSection();
                    return taskDescription;
                }
                resetPriorityAfterLockedSection();
                return null;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public int addAppTask(IBinder activityToken, Intent intent, ActivityManager.TaskDescription description, Bitmap thumbnail) throws RemoteException {
        int callingUid = Binder.getCallingUid();
        long callingIdent = Binder.clearCallingIdentity();
        try {
            try {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);
                        try {
                            if (r == null) {
                                StringBuilder sb = new StringBuilder();
                                sb.append("Activity does not exist; token=");
                                sb.append(activityToken);
                                throw new IllegalArgumentException(sb.toString());
                            }
                            try {
                                ComponentName comp = intent.getComponent();
                                if (comp == null) {
                                    throw new IllegalArgumentException("Intent " + intent + " must specify explicit component");
                                } else if (thumbnail.getWidth() != this.mThumbnailWidth || thumbnail.getHeight() != this.mThumbnailHeight) {
                                    throw new IllegalArgumentException("Bad thumbnail size: got " + thumbnail.getWidth() + "x" + thumbnail.getHeight() + ", require " + this.mThumbnailWidth + "x" + this.mThumbnailHeight);
                                } else {
                                    if (intent.getSelector() != null) {
                                        intent.setSelector(null);
                                    }
                                    if (intent.getSourceBounds() != null) {
                                        intent.setSourceBounds(null);
                                    }
                                    if ((intent.getFlags() & DumpState.DUMP_FROZEN) != 0 && (intent.getFlags() & 8192) == 0) {
                                        intent.addFlags(8192);
                                    }
                                    ActivityInfo ainfo = AppGlobals.getPackageManager().getActivityInfo(comp, 1024, UserHandle.getUserId(callingUid));
                                    if (ainfo.applicationInfo.uid != callingUid) {
                                        throw new SecurityException("Can't add task for another application: target uid=" + ainfo.applicationInfo.uid + ", calling uid=" + callingUid);
                                    }
                                    ActivityStack stack = r.getStack();
                                    TaskRecord task = stack.createTaskRecord(this.mStackSupervisor.getNextTaskIdForUserLocked(r.userId), ainfo, intent, null, null, false);
                                    if (!this.mRecentTasks.addToBottom(task)) {
                                        stack.removeTask(task, "addAppTask", 0);
                                        resetPriorityAfterLockedSection();
                                        Binder.restoreCallingIdentity(callingIdent);
                                        return -1;
                                    }
                                    task.lastTaskDescription.copyFrom(description);
                                    int i = task.taskId;
                                    resetPriorityAfterLockedSection();
                                    Binder.restoreCallingIdentity(callingIdent);
                                    return i;
                                }
                            } catch (Throwable th) {
                                th = th;
                                try {
                                    resetPriorityAfterLockedSection();
                                    throw th;
                                } catch (Throwable th2) {
                                    th = th2;
                                    Binder.restoreCallingIdentity(callingIdent);
                                    throw th;
                                }
                            }
                        } catch (Throwable th3) {
                            th = th3;
                        }
                    } catch (Throwable th4) {
                        th = th4;
                    }
                }
            } catch (Throwable th5) {
                th = th5;
            }
        } catch (Throwable th6) {
            th = th6;
            Binder.restoreCallingIdentity(callingIdent);
            throw th;
        }
    }

    public Point getAppTaskThumbnailSize() {
        Point point;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                point = new Point(this.mThumbnailWidth, this.mThumbnailHeight);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return point;
    }

    public void setTaskDescription(IBinder token, ActivityManager.TaskDescription td) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    r.setTaskDescription(td);
                    TaskRecord task = r.getTask();
                    task.updateTaskDescription();
                    this.mTaskChangeNotificationController.notifyTaskDescriptionChanged(task.taskId, td);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void setTaskResizeable(int taskId, int resizeableMode) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, 1);
                if (task == null) {
                    Slog.w("ActivityManager", "setTaskResizeable: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    return;
                }
                task.setResizeMode(resizeableMode);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void resizeTask(int taskId, Rect bounds, int resizeMode) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizeTask()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Slog.w("ActivityManager", "resizeTask: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    return;
                }
                ActivityStack stack = task.getStack();
                if (!task.getWindowConfiguration().canResizeTask()) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                boolean z = true;
                if (bounds == null && stack.getWindowingMode() == 5) {
                    stack = stack.getDisplay().getOrCreateStack(1, stack.getActivityType(), true);
                } else if (bounds != null && stack.getWindowingMode() != 5) {
                    stack = stack.getDisplay().getOrCreateStack(5, stack.getActivityType(), true);
                }
                ActivityStack stack2 = stack;
                if ((resizeMode & 1) == 0) {
                    z = false;
                }
                boolean preserveWindow = z;
                if (stack2 != task.getStack()) {
                    task.reparent(stack2, true, 1, true, true, "resizeTask");
                    preserveWindow = false;
                }
                task.resize(bounds, resizeMode, preserveWindow, false);
                resetPriorityAfterLockedSection();
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public Rect getTaskBounds(int taskId) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getTaskBounds()");
        long ident = Binder.clearCallingIdentity();
        Rect rect = new Rect();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, 1);
                if (task == null) {
                    Slog.w("ActivityManager", "getTaskBounds: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    return rect;
                }
                if (task.getStack() != null) {
                    task.getWindowContainerBounds(rect);
                } else if (!task.matchParentBounds()) {
                    rect.set(task.getBounds());
                } else if (task.mLastNonFullscreenBounds != null) {
                    rect.set(task.mLastNonFullscreenBounds);
                }
                resetPriorityAfterLockedSection();
                return rect;
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void cancelTaskWindowTransition(int taskId) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "cancelTaskWindowTransition()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, 0);
                if (task == null) {
                    Slog.w("ActivityManager", "cancelTaskWindowTransition: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    return;
                }
                task.cancelWindowTransition();
                resetPriorityAfterLockedSection();
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public ActivityManager.TaskSnapshot getTaskSnapshot(int taskId, boolean reducedResolution) {
        enforceCallerIsRecentsOrHasPermission("android.permission.READ_FRAME_BUFFER", "getTaskSnapshot()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId, 1);
                if (task == null) {
                    Slog.w("ActivityManager", "getTaskSnapshot: taskId=" + taskId + " not found");
                    resetPriorityAfterLockedSection();
                    return null;
                }
                resetPriorityAfterLockedSection();
                return task.getSnapshot(reducedResolution);
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public Bitmap getTaskDescriptionIcon(String filePath, int userId) {
        int userId2 = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "getTaskDescriptionIcon", null);
        File passedIconFile = new File(filePath);
        File legitIconFile = new File(TaskPersister.getUserImagesDir(userId2), passedIconFile.getName());
        if (!legitIconFile.getPath().equals(filePath) || !filePath.contains("_activity_icon_")) {
            throw new IllegalArgumentException("Bad file path: " + filePath + " passed for userId " + userId2);
        }
        return this.mRecentTasks.getTaskDescriptionIcon(filePath);
    }

    public void startInPlaceAnimationOnFrontMostApplication(Bundle opts) throws RemoteException {
        ActivityOptions activityOptions;
        SafeActivityOptions safeOptions = SafeActivityOptions.fromBundle(opts);
        if (safeOptions != null) {
            activityOptions = safeOptions.getOptions(this.mStackSupervisor);
        } else {
            activityOptions = null;
        }
        if (activityOptions == null || activityOptions.getAnimationType() != 10 || activityOptions.getCustomInPlaceResId() == 0) {
            throw new IllegalArgumentException("Expected in-place ActivityOption with valid animation");
        }
        this.mWindowManager.prepareAppTransition(17, false);
        this.mWindowManager.overridePendingAppTransitionInPlace(activityOptions.getPackageName(), activityOptions.getCustomInPlaceResId());
        this.mWindowManager.executeAppTransition();
    }

    public void removeStack(int stackId) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "removeStack()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                ActivityStack stack = this.mStackSupervisor.getStack(stackId);
                if (stack == null) {
                    Slog.w("ActivityManager", "removeStack: No stack with id=" + stackId);
                    Binder.restoreCallingIdentity(ident);
                    resetPriorityAfterLockedSection();
                } else if (!stack.isActivityTypeStandardOrUndefined()) {
                    throw new IllegalArgumentException("Removing non-standard stack is not allowed.");
                } else {
                    this.mStackSupervisor.removeStack(stack);
                    Binder.restoreCallingIdentity(ident);
                    resetPriorityAfterLockedSection();
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void removeStacksInWindowingModes(int[] windowingModes) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "removeStacksInWindowingModes()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                this.mStackSupervisor.removeStacksInWindowingModes(windowingModes);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void removeStacksWithActivityTypes(int[] activityTypes) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "removeStacksWithActivityTypes()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                this.mStackSupervisor.removeStacksWithActivityTypes(activityTypes);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String getPendingTempWhitelistTagForUidLocked(int uid) {
        PendingTempWhitelist ptw = this.mPendingTempWhitelist.get(uid);
        if (ptw != null) {
            return ptw.tag;
        }
        return null;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @VisibleForTesting
    public boolean isActivityStartsLoggingEnabled() {
        return this.mConstants.mFlagActivityStartsLoggingEnabled;
    }

    public void moveStackToDisplay(int stackId, int displayId) {
        enforceCallingPermission("android.permission.INTERNAL_SYSTEM_WINDOW", "moveStackToDisplay()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d("ActivityManager", "moveStackToDisplay: moving stackId=" + stackId + " to displayId=" + displayId);
                }
                this.mStackSupervisor.moveStackToDisplayLocked(stackId, displayId, true);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean removeTask(int taskId) {
        boolean removeTaskByIdLocked;
        enforceCallerIsRecentsOrHasPermission("android.permission.REMOVE_TASKS", "removeTask()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                removeTaskByIdLocked = this.mStackSupervisor.removeTaskByIdLocked(taskId, true, true, "remove-task");
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return removeTaskByIdLocked;
    }

    public void moveTaskToFront(int taskId, int flags, Bundle bOptions) {
        enforceCallingPermission("android.permission.REORDER_TASKS", "moveTaskToFront()");
        if (ActivityManagerDebugConfig.DEBUG_STACK) {
            Slog.d("ActivityManager", "moveTaskToFront: moving taskId=" + taskId);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                moveTaskToFrontLocked(taskId, flags, SafeActivityOptions.fromBundle(bOptions), false);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void moveTaskToFrontLocked(int taskId, int flags, SafeActivityOptions options, boolean fromRecents) {
        if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(), Binder.getCallingUid(), -1, -1, "Task to front")) {
            SafeActivityOptions.abort(options);
            return;
        }
        long origId = Binder.clearCallingIdentity();
        try {
            TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
            if (task == null) {
                Slog.d("ActivityManager", "Could not find task for id: " + taskId);
            } else if (this.mLockTaskController.isLockTaskModeViolation(task)) {
                Slog.e("ActivityManager", "moveTaskToFront: Attempt to violate Lock Task Mode");
            } else {
                ActivityOptions realOptions = options != null ? options.getOptions(this.mStackSupervisor) : null;
                this.mStackSupervisor.findTaskToMoveToFront(task, flags, realOptions, "moveTaskToFront", false);
                ActivityRecord topActivity = task.getTopActivity();
                if (topActivity != null) {
                    topActivity.showStartingWindow(null, false, true, fromRecents);
                }
                Binder.restoreCallingIdentity(origId);
                SafeActivityOptions.abort(options);
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean moveActivityTaskToBack(IBinder token, boolean nonRoot) {
        enforceNotIsolatedCaller("moveActivityTaskToBack");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                int taskId = ActivityRecord.getTaskForActivityLocked(token, !nonRoot);
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task != null) {
                    boolean moveTaskToBackLocked = ActivityRecord.getStackLocked(token).moveTaskToBackLocked(taskId);
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return moveTaskToBackLocked;
                }
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return false;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void moveTaskBackwards(int task) {
        enforceCallingPermission("android.permission.REORDER_TASKS", "moveTaskBackwards()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(), Binder.getCallingUid(), -1, -1, "Task backwards")) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                long origId = Binder.clearCallingIdentity();
                moveTaskBackwardsLocked(task);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    private final void moveTaskBackwardsLocked(int task) {
        Slog.e("ActivityManager", "moveTaskBackwards not yet implemented!");
    }

    public int createStackOnDisplay(int displayId) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "createStackOnDisplay()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityDisplay display = this.mStackSupervisor.getActivityDisplayOrCreateLocked(displayId);
                if (display == null) {
                    resetPriorityAfterLockedSection();
                    return -1;
                }
                ActivityStack stack = display.createStack(4, 1, true);
                int i = stack != null ? stack.mStackId : -1;
                resetPriorityAfterLockedSection();
                return i;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public int getActivityDisplayId(IBinder activityToken) throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack stack = ActivityRecord.getStackLocked(activityToken);
                if (stack != null && stack.mDisplayId != -1) {
                    int i = stack.mDisplayId;
                    resetPriorityAfterLockedSection();
                    return i;
                }
                resetPriorityAfterLockedSection();
                return 0;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void exitFreeformMode(IBinder token) throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException("exitFreeformMode: No activity record matching token=" + token);
                }
                ActivityStack stack = r.getStack();
                if (stack == null || !stack.inFreeformWindowingMode()) {
                    throw new IllegalStateException("exitFreeformMode: You can only go fullscreen from freeform.");
                }
                stack.setWindowingMode(1);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void setTaskWindowingMode(int taskId, int windowingMode, boolean toTop) {
        if (windowingMode == 3) {
            setTaskWindowingModeSplitScreenPrimary(taskId, 0, toTop, true, null, true);
            return;
        }
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "setTaskWindowingMode()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Slog.w("ActivityManager", "setTaskWindowingMode: No task for id=" + taskId);
                    Binder.restoreCallingIdentity(ident);
                    resetPriorityAfterLockedSection();
                    return;
                }
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d("ActivityManager", "setTaskWindowingMode: moving task=" + taskId + " to windowingMode=" + windowingMode + " toTop=" + toTop);
                }
                if (!task.isActivityTypeStandardOrUndefined()) {
                    throw new IllegalArgumentException("setTaskWindowingMode: Attempt to move non-standard task " + taskId + " to windowing mode=" + windowingMode);
                }
                ActivityStack stack = task.getStack();
                if (toTop) {
                    stack.moveToFront("setTaskWindowingMode", task);
                }
                stack.setWindowingMode(windowingMode);
                Binder.restoreCallingIdentity(ident);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public boolean setTaskWindowingModeSplitScreenPrimary(int taskId, int createMode, boolean toTop, boolean animate, Rect initialBounds, boolean showRecents) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "setTaskWindowingModeSplitScreenPrimary()");
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    long ident = Binder.clearCallingIdentity();
                    try {
                        TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                        if (task == null) {
                            Slog.w("ActivityManager", "setTaskWindowingModeSplitScreenPrimary: No task for id=" + taskId);
                            Binder.restoreCallingIdentity(ident);
                            resetPriorityAfterLockedSection();
                            return false;
                        }
                        if (ActivityManagerDebugConfig.DEBUG_STACK) {
                            Slog.d("ActivityManager", "setTaskWindowingModeSplitScreenPrimary: moving task=" + taskId + " to createMode=" + createMode + " toTop=" + toTop);
                        }
                        try {
                            if (!task.isActivityTypeStandardOrUndefined()) {
                                throw new IllegalArgumentException("setTaskWindowingMode: Attempt to move non-standard task " + taskId + " to split-screen windowing mode");
                            }
                            this.mWindowManager.setDockedStackCreateState(createMode, initialBounds);
                            int windowingMode = task.getWindowingMode();
                            ActivityStack stack = task.getStack();
                            if (toTop) {
                                stack.moveToFront("setTaskWindowingModeSplitScreenPrimary", task);
                            }
                            stack.setWindowingMode(3, animate, showRecents, false, false);
                            boolean z = windowingMode != task.getWindowingMode();
                            Binder.restoreCallingIdentity(ident);
                            resetPriorityAfterLockedSection();
                            return z;
                        } catch (Throwable th) {
                            th = th;
                            Binder.restoreCallingIdentity(ident);
                            throw th;
                        }
                    } catch (Throwable th2) {
                        th = th2;
                    }
                } catch (Throwable th3) {
                    th = th3;
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            } catch (Throwable th4) {
                th = th4;
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void moveTaskToStack(int taskId, int stackId, boolean toTop) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTaskToStack()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Slog.w("ActivityManager", "moveTaskToStack: No task for id=" + taskId);
                    Binder.restoreCallingIdentity(ident);
                    resetPriorityAfterLockedSection();
                    return;
                }
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d("ActivityManager", "moveTaskToStack: moving task=" + taskId + " to stackId=" + stackId + " toTop=" + toTop);
                }
                ActivityStack stack = this.mStackSupervisor.getStack(stackId);
                if (stack == null) {
                    throw new IllegalStateException("moveTaskToStack: No stack for stackId=" + stackId);
                } else if (!stack.isActivityTypeStandardOrUndefined()) {
                    throw new IllegalArgumentException("moveTaskToStack: Attempt to move task " + taskId + " to stack " + stackId);
                } else {
                    if (stack.inSplitScreenPrimaryWindowingMode()) {
                        this.mWindowManager.setDockedStackCreateState(0, null);
                    }
                    task.reparent(stack, toTop, 1, true, false, "moveTaskToStack");
                    Binder.restoreCallingIdentity(ident);
                    resetPriorityAfterLockedSection();
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void dismissSplitScreenMode(boolean toTop) {
        ActivityStack otherStack;
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "dismissSplitScreenMode()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityStack stack = this.mStackSupervisor.getDefaultDisplay().getSplitScreenPrimaryStack();
                if (stack == null) {
                    Slog.w("ActivityManager", "dismissSplitScreenMode: primary split-screen stack not found.");
                    resetPriorityAfterLockedSection();
                    return;
                }
                if (toTop) {
                    stack.moveToFront("dismissSplitScreenMode");
                } else if (this.mStackSupervisor.isFocusedStack(stack) && (otherStack = stack.getDisplay().getTopStackInWindowingMode(4)) != null) {
                    otherStack.moveToFront("dismissSplitScreenMode_other");
                }
                stack.setWindowingMode(1);
                resetPriorityAfterLockedSection();
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void dismissPip(boolean animate, int animationDuration) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "dismissPip()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                PinnedActivityStack stack = this.mStackSupervisor.getDefaultDisplay().getPinnedStack();
                if (stack == null) {
                    Slog.w("ActivityManager", "dismissPip: pinned stack not found.");
                    resetPriorityAfterLockedSection();
                } else if (stack.getWindowingMode() != 2) {
                    throw new IllegalArgumentException("Stack: " + stack + " doesn't support animated resize.");
                } else {
                    if (animate) {
                        stack.animateResizePinnedStack(null, null, animationDuration, false);
                    } else {
                        this.mStackSupervisor.moveTasksToFullscreenStackLocked(stack, true);
                    }
                    resetPriorityAfterLockedSection();
                }
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public boolean moveTopActivityToPinnedStack(int stackId, Rect bounds) {
        boolean moveTopStackActivityToPinnedStackLocked;
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTopActivityToPinnedStack()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!this.mSupportsPictureInPicture) {
                    throw new IllegalStateException("moveTopActivityToPinnedStack:Device doesn't support picture-in-picture mode");
                }
                long ident = Binder.clearCallingIdentity();
                moveTopStackActivityToPinnedStackLocked = this.mStackSupervisor.moveTopStackActivityToPinnedStackLocked(stackId, bounds);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return moveTopStackActivityToPinnedStackLocked;
    }

    public void resizeStack(int stackId, Rect destBounds, boolean allowResizeInDockedMode, boolean preserveWindows, boolean animate, int animationDuration) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizeStack()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (animate) {
                        try {
                            PinnedActivityStack stack = (PinnedActivityStack) this.mStackSupervisor.getStack(stackId);
                            if (stack == null) {
                                Slog.w("ActivityManager", "resizeStack: stackId " + stackId + " not found.");
                                resetPriorityAfterLockedSection();
                                return;
                            } else if (stack.getWindowingMode() != 2) {
                                throw new IllegalArgumentException("Stack: " + stackId + " doesn't support animated resize.");
                            } else {
                                stack.animateResizePinnedStack(null, destBounds, animationDuration, false);
                            }
                        } catch (Throwable th) {
                            th = th;
                            resetPriorityAfterLockedSection();
                            throw th;
                        }
                    } else {
                        ActivityStack stack2 = this.mStackSupervisor.getStack(stackId);
                        if (stack2 == null) {
                            Slog.w("ActivityManager", "resizeStack: stackId " + stackId + " not found.");
                            resetPriorityAfterLockedSection();
                            return;
                        }
                        this.mStackSupervisor.resizeStackLocked(stack2, destBounds, null, null, preserveWindows, allowResizeInDockedMode, false);
                    }
                    resetPriorityAfterLockedSection();
                } catch (Throwable th2) {
                    th = th2;
                }
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void resizeDockedStack(Rect dockedBounds, Rect tempDockedTaskBounds, Rect tempDockedTaskInsetBounds, Rect tempOtherTaskBounds, Rect tempOtherTaskInsetBounds) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizeDockedStack()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mStackSupervisor.resizeDockedStackLocked(dockedBounds, tempDockedTaskBounds, tempDockedTaskInsetBounds, tempOtherTaskBounds, tempOtherTaskInsetBounds, true);
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void setSplitScreenResizing(boolean resizing) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "setSplitScreenResizing()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mStackSupervisor.setSplitScreenResizing(resizing);
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void resizePinnedStack(Rect pinnedBounds, Rect tempPinnedTaskBounds) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "resizePinnedStack()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mStackSupervisor.resizePinnedStackLocked(pinnedBounds, tempPinnedTaskBounds);
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void positionTaskInStack(int taskId, int stackId, int position) {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "positionTaskInStack()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                if (ActivityManagerDebugConfig.DEBUG_STACK) {
                    Slog.d("ActivityManager", "positionTaskInStack: positioning task=" + taskId + " in stackId=" + stackId + " at position=" + position);
                }
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    throw new IllegalArgumentException("positionTaskInStack: no task for id=" + taskId);
                }
                ActivityStack stack = this.mStackSupervisor.getStack(stackId);
                if (stack == null) {
                    throw new IllegalArgumentException("positionTaskInStack: no stack for id=" + stackId);
                } else if (!stack.isActivityTypeStandardOrUndefined()) {
                    throw new IllegalArgumentException("positionTaskInStack: Attempt to change the position of task " + taskId + " in/to non-standard stack");
                } else {
                    if (task.getStack() == stack) {
                        stack.positionChildAt(task, position);
                    } else {
                        task.reparent(stack, position, 2, false, false, "positionTaskInStack");
                    }
                    Binder.restoreCallingIdentity(ident);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public List<ActivityManager.StackInfo> getAllStackInfos() {
        ArrayList<ActivityManager.StackInfo> allStackInfosLocked;
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getAllStackInfos()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                allStackInfosLocked = this.mStackSupervisor.getAllStackInfosLocked();
            }
            resetPriorityAfterLockedSection();
            return allStackInfosLocked;
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public ActivityManager.StackInfo getStackInfo(int windowingMode, int activityType) {
        ActivityManager.StackInfo stackInfo;
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getStackInfo()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                stackInfo = this.mStackSupervisor.getStackInfo(windowingMode, activityType);
            }
            resetPriorityAfterLockedSection();
            return stackInfo;
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public int getTaskForActivity(IBinder token, boolean onlyRoot) {
        int taskForActivityLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                taskForActivityLocked = ActivityRecord.getTaskForActivityLocked(token, onlyRoot);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return taskForActivityLocked;
    }

    public void updateDeviceOwner(String packageName) {
        int callingUid = Binder.getCallingUid();
        if (callingUid != 0 && callingUid != 1000) {
            throw new SecurityException("updateDeviceOwner called from non-system process");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mDeviceOwnerName = packageName;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void updateLockTaskPackages(int userId, String[] packages) {
        int callingUid = Binder.getCallingUid();
        if (callingUid != 0 && callingUid != 1000) {
            enforceCallingPermission("android.permission.UPDATE_LOCK_TASK_PACKAGES", "updateLockTaskPackages()");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
                    Slog.w("ActivityManager", "Whitelisting " + userId + ":" + Arrays.toString(packages));
                }
                this.mLockTaskController.updateLockTaskPackages(userId, packages);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void updateLockTaskFeatures(int userId, int flags) {
        int callingUid = Binder.getCallingUid();
        if (callingUid != 0 && callingUid != 1000) {
            enforceCallingPermission("android.permission.UPDATE_LOCK_TASK_PACKAGES", "updateLockTaskFeatures()");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
                    Slog.w("ActivityManager", "Allowing features " + userId + ":0x" + Integer.toHexString(flags));
                }
                this.mLockTaskController.updateLockTaskFeatures(userId, flags);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    private void startLockTaskModeLocked(TaskRecord task, boolean isSystemCaller) {
        if (ActivityManagerDebugConfig.DEBUG_LOCKTASK) {
            Slog.w("ActivityManager", "startLockTaskModeLocked: " + task);
        }
        if (task == null || task.mLockTaskAuth == 0) {
            return;
        }
        ActivityStack stack = this.mStackSupervisor.getFocusedStack();
        if (stack == null || task != stack.topTask()) {
            throw new IllegalArgumentException("Invalid task, not in foreground");
        }
        int callingUid = Binder.getCallingUid();
        long ident = Binder.clearCallingIdentity();
        try {
            this.mStackSupervisor.removeStacksInWindowingModes(2);
            this.mLockTaskController.startLockTaskMode(task, isSystemCaller, callingUid);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void startLockTaskModeByToken(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                startLockTaskModeLocked(r.getTask(), false);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void startSystemLockTaskMode(int taskId) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "startSystemLockTaskMode");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                task.getStack().moveToFront("startSystemLockTaskMode");
                startLockTaskModeLocked(task, true);
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void stopLockTaskModeByToken(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                stopLockTaskModeInternal(r.getTask(), false);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void stopSystemLockTaskMode() throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "stopSystemLockTaskMode");
        stopLockTaskModeInternal(null, true);
    }

    private void stopLockTaskModeInternal(TaskRecord task, boolean isSystemCaller) {
        int callingUid = Binder.getCallingUid();
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mLockTaskController.stopLockTaskMode(task, isSystemCaller, callingUid);
            }
            resetPriorityAfterLockedSection();
            TelecomManager tm = (TelecomManager) this.mContext.getSystemService("telecom");
            if (tm != null) {
                tm.showInCallScreen(false);
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public boolean isInLockTaskMode() {
        return getLockTaskModeState() != 0;
    }

    public int getLockTaskModeState() {
        int lockTaskModeState;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                lockTaskModeState = this.mLockTaskController.getLockTaskModeState();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return lockTaskModeState;
    }

    public void showLockTaskEscapeMessage(IBinder token) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                this.mLockTaskController.showLockTaskToast();
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void setDisablePreviewScreenshots(IBinder token, boolean disable) throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    Slog.w("ActivityManager", "setDisablePreviewScreenshots: Unable to find activity for token=" + token);
                    resetPriorityAfterLockedSection();
                    return;
                }
                long origId = Binder.clearCallingIdentity();
                r.setDisablePreviewScreenshots(disable);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    private final List<ProviderInfo> generateApplicationProvidersLocked(ProcessRecord app) {
        List<ProviderInfo> providers;
        try {
            providers = AppGlobals.getPackageManager().queryContentProviders(app.processName, app.uid, 268438528, (String) null).getList();
        } catch (RemoteException e) {
            providers = null;
        }
        if (ActivityManagerDebugConfig.DEBUG_MU) {
            Slog.v(TAG_MU, "generateApplicationProvidersLocked, app.info.uid = " + app.uid);
        }
        int userId = app.userId;
        if (providers != null) {
            int N = providers.size();
            app.pubProviders.ensureCapacity(app.pubProviders.size() + N);
            int i = 0;
            int N2 = N;
            while (true) {
                int i2 = i;
                if (i2 >= N2) {
                    break;
                }
                ProviderInfo cpi = providers.get(i2);
                boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags);
                if (singleton && UserHandle.getUserId(app.uid) != 0) {
                    providers.remove(i2);
                    N2--;
                    i2--;
                } else {
                    ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
                    ContentProviderRecord cpr = this.mProviderMap.getProviderByClass(comp, userId);
                    if (cpr == null) {
                        cpr = new ContentProviderRecord(this, cpi, app.info, comp, singleton);
                        this.mProviderMap.putProviderByClass(comp, cpr);
                    }
                    if (ActivityManagerDebugConfig.DEBUG_MU) {
                        Slog.v(TAG_MU, "generateApplicationProvidersLocked, cpi.uid = " + cpr.uid);
                    }
                    app.pubProviders.put(cpi.name, cpr);
                    if (!cpi.multiprocess || !PackageManagerService.PLATFORM_PACKAGE_NAME.equals(cpi.packageName)) {
                        app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.versionCode, this.mProcessStats);
                    }
                    notifyPackageUse(cpi.applicationInfo.packageName, 4);
                }
                i = i2 + 1;
            }
        }
        return providers;
    }

    public String checkContentProviderAccess(String authority, int userId) {
        ProcessRecord r;
        String checkContentProviderPermissionLocked;
        if (userId == -1) {
            this.mContext.enforceCallingOrSelfPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "ActivityManager");
            userId = UserHandle.getCallingUserId();
        }
        ProviderInfo cpi = null;
        try {
            cpi = AppGlobals.getPackageManager().resolveContentProvider(authority, 790016, userId);
        } catch (RemoteException e) {
        }
        if (cpi == null) {
            return "Failed to find provider " + authority + " for user " + userId + "; expected to find a valid ContentProvider for this authority";
        }
        synchronized (this.mPidsSelfLocked) {
            r = this.mPidsSelfLocked.get(Binder.getCallingPid());
        }
        if (r == null) {
            return "Failed to find PID " + Binder.getCallingPid();
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                checkContentProviderPermissionLocked = checkContentProviderPermissionLocked(cpi, r, userId, true);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return checkContentProviderPermissionLocked;
    }

    private final String checkContentProviderPermissionLocked(ProviderInfo cpi, ProcessRecord r, int userId, boolean checkUser) {
        int userId2;
        String suffix;
        PathPermission[] pps;
        PathPermission pp;
        int callingPid = r != null ? r.pid : Binder.getCallingPid();
        int callingUid = r != null ? r.uid : Binder.getCallingUid();
        boolean checkedGrants = false;
        if (checkUser) {
            int tmpTargetUserId = this.mUserController.unsafeConvertIncomingUser(userId);
            if (tmpTargetUserId != UserHandle.getUserId(callingUid)) {
                if (checkAuthorityGrants(callingUid, cpi, tmpTargetUserId, checkUser)) {
                    return null;
                }
                checkedGrants = true;
            }
            userId2 = this.mUserController.handleIncomingUser(callingPid, callingUid, userId, false, 0, "checkContentProviderPermissionLocked " + cpi.authority, null);
            if (userId2 != tmpTargetUserId) {
                checkedGrants = false;
            }
        } else {
            userId2 = userId;
        }
        boolean checkedGrants2 = checkedGrants;
        int userId3 = userId2;
        if (checkComponentPermission(cpi.readPermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0 || checkComponentPermission(cpi.writePermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
            return null;
        }
        PathPermission[] pps2 = cpi.pathPermissions;
        if (pps2 != null) {
            int i = pps2.length;
            while (i > 0) {
                int i2 = i - 1;
                PathPermission pp2 = pps2[i2];
                String pprperm = pp2.getReadPermission();
                if (pprperm != null) {
                    pps = pps2;
                    pp = pp2;
                    if (checkComponentPermission(pprperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
                        return null;
                    }
                } else {
                    pps = pps2;
                    pp = pp2;
                }
                String ppwperm = pp.getWritePermission();
                if (ppwperm != null && checkComponentPermission(ppwperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == 0) {
                    return null;
                }
                i = i2;
                pps2 = pps;
            }
        }
        if (!checkedGrants2 && checkAuthorityGrants(callingUid, cpi, userId3, checkUser)) {
            return null;
        }
        if (!cpi.exported) {
            suffix = " that is not exported from UID " + cpi.applicationInfo.uid;
        } else if ("android.permission.MANAGE_DOCUMENTS".equals(cpi.readPermission)) {
            suffix = " requires that you obtain access using ACTION_OPEN_DOCUMENT or related APIs";
        } else {
            suffix = " requires " + cpi.readPermission + " or " + cpi.writePermission;
        }
        StringBuilder sb = new StringBuilder();
        sb.append("Permission Denial: opening provider ");
        sb.append(cpi.name);
        sb.append(" from ");
        sb.append(r != null ? r : "(null)");
        sb.append(" (pid=");
        sb.append(callingPid);
        sb.append(", uid=");
        sb.append(callingUid);
        sb.append(")");
        sb.append(suffix);
        String msg = sb.toString();
        Slog.w("ActivityManager", msg);
        return msg;
    }

    boolean checkAuthorityGrants(int callingUid, ProviderInfo cpi, int userId, boolean checkUser) {
        ArrayMap<GrantUri, UriPermission> perms = this.mGrantedUriPermissions.get(callingUid);
        if (perms != null) {
            for (int i = perms.size() - 1; i >= 0; i--) {
                GrantUri grantUri = perms.keyAt(i);
                if ((grantUri.sourceUserId == userId || !checkUser) && matchesProvider(grantUri.uri, cpi)) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }

    boolean matchesProvider(Uri uri, ProviderInfo cpi) {
        String uriAuth = uri.getAuthority();
        String cpiAuth = cpi.authority;
        if (cpiAuth.indexOf(59) == -1) {
            return cpiAuth.equals(uriAuth);
        }
        String[] cpiAuths = cpiAuth.split(";");
        for (String str : cpiAuths) {
            if (str.equals(uriAuth)) {
                return true;
            }
        }
        return false;
    }

    ContentProviderConnection incProviderCountLocked(ProcessRecord r, ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) {
        if (r != null) {
            for (int i = 0; i < r.conProviders.size(); i++) {
                ContentProviderConnection conn = r.conProviders.get(i);
                if (conn.provider == cpr) {
                    if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                        Slog.v("ActivityManager", "Adding provider requested by " + r.processName + " from process " + cpr.info.processName + ": " + cpr.name.flattenToShortString() + " scnt=" + conn.stableCount + " uscnt=" + conn.unstableCount);
                    }
                    if (stable) {
                        conn.stableCount++;
                        conn.numStableIncs++;
                    } else {
                        conn.unstableCount++;
                        conn.numUnstableIncs++;
                    }
                    return conn;
                }
            }
            ContentProviderConnection conn2 = new ContentProviderConnection(cpr, r);
            if (stable) {
                conn2.stableCount = 1;
                conn2.numStableIncs = 1;
            } else {
                conn2.unstableCount = 1;
                conn2.numUnstableIncs = 1;
            }
            cpr.connections.add(conn2);
            r.conProviders.add(conn2);
            startAssociationLocked(r.uid, r.processName, r.curProcState, cpr.uid, cpr.name, cpr.info.processName);
            return conn2;
        }
        cpr.addExternalProcessHandleLocked(externalProcessToken);
        return null;
    }

    boolean decProviderCountLocked(ContentProviderConnection conn, ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) {
        if (conn != null) {
            ContentProviderRecord cpr2 = conn.provider;
            if (ActivityManagerDebugConfig.DEBUG_PROVIDER) {
                Slog.v("ActivityManager", "Removing provider requested by " + conn.client.processName + " from process " + cpr2.info.processName + ": " + cpr2.name.flattenToShortString() + " scnt=" + conn.stableCount + " uscnt=" + conn.unstableCount);
            }
            if (stable) {
                conn.stableCount--;
            } else {
                conn.unstableCount--;
            }
            if (conn.stableCount != 0 || conn.unstableCount != 0) {
                return false;
            }
            cpr2.connections.remove(conn);
            conn.client.conProviders.remove(conn);
            if (conn.client.setProcState < 14 && cpr2.proc != null) {
                cpr2.proc.lastProviderTime = SystemClock.uptimeMillis();
            }
            stopAssociationLocked(conn.client.uid, conn.client.processName, cpr2.uid, cpr2.name);
            return true;
        }
        cpr.removeExternalProcessHandleLocked(externalProcessToken);
        return false;
    }

    private void checkTime(long startTime, String where) {
        long now = SystemClock.uptimeMillis();
        if (now - startTime > 50) {
            Slog.w("ActivityManager", "Slow operation: " + (now - startTime) + "ms so far, now at " + where);
        }
    }

    private boolean isProcessAliveLocked(ProcessRecord proc) {
        if (proc.pid <= 0) {
            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                Slog.d("ActivityManager", "Process hasn't started yet: " + proc);
            }
            return false;
        }
        if (proc.procStatFile == null) {
            proc.procStatFile = "/proc/" + proc.pid + "/stat";
        }
        this.mProcessStateStatsLongs[0] = 0;
        if (!Process.readProcFile(proc.procStatFile, PROCESS_STATE_STATS_FORMAT, null, this.mProcessStateStatsLongs, null)) {
            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                Slog.d("ActivityManager", "UNABLE TO RETRIEVE STATE FOR " + proc.procStatFile);
            }
            return false;
        }
        long state = this.mProcessStateStatsLongs[0];
        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
            Slog.d("ActivityManager", "RETRIEVED STATE FOR " + proc.procStatFile + ": " + ((char) state));
        }
        return (state == 90 || state == 88 || state == 120 || state == 75) ? false : true;
    }

    /* JADX WARN: Code restructure failed: missing block: B:283:0x057b, code lost:
        if (r5 < r0) goto L209;
     */
    /* JADX WARN: Code restructure failed: missing block: B:284:0x057d, code lost:
        r0 = android.os.Binder.clearCallingIdentity();
     */
    /* JADX WARN: Code restructure failed: missing block: B:286:0x0582, code lost:
        checkTime(r5, "getContentProviderImpl: before set stopped state");
        android.app.AppGlobals.getPackageManager().setPackageStoppedState(r14.appInfo.packageName, false, (int) r12);
        checkTime(r5, "getContentProviderImpl: after set stopped state");
     */
    /* JADX WARN: Code restructure failed: missing block: B:288:0x0599, code lost:
        r0 = th;
     */
    /* JADX WARN: Code restructure failed: missing block: B:289:0x059a, code lost:
        r2 = r0;
     */
    /* JADX WARN: Code restructure failed: missing block: B:290:0x05aa, code lost:
        r0 = move-exception;
     */
    /* JADX WARN: Code restructure failed: missing block: B:291:0x05ab, code lost:
        android.util.Slog.w("ActivityManager", "Failed trying to unstop package " + r14.appInfo.packageName + ": " + r0);
     */
    /* JADX WARN: Code restructure failed: missing block: B:301:0x05e7, code lost:
        if (r1.thread != null) goto L284;
     */
    /* JADX WARN: Code restructure failed: missing block: B:305:0x05ef, code lost:
        if (com.android.server.am.ActivityManagerDebugConfig.DEBUG_PROVIDER != false) goto L288;
     */
    /* JADX WARN: Code restructure failed: missing block: B:306:0x05f1, code lost:
        r2 = new java.lang.StringBuilder();
     */
    /* JADX WARN: Code restructure failed: missing block: B:307:0x05f8, code lost:
        r40 = r0;
     */
    /* JADX WARN: Code restructure failed: missing block: B:308:0x05fa, code lost:
        r2.append("Installing in existing process ");
        r2.append(r1);
        android.util.Slog.d("ActivityManager", r2.toString());
     */
    /* JADX WARN: Code restructure failed: missing block: B:309:0x060a, code lost:
        r40 = r0;
     */
    /* JADX WARN: Code restructure failed: missing block: B:311:0x0614, code lost:
        if (r1.pubProviders.containsKey(r15.name) == false) goto L294;
     */
    /* JADX WARN: Code restructure failed: missing block: B:312:0x0616, code lost:
        checkTime(r5, "getContentProviderImpl: scheduling install");
        r1.pubProviders.put(r15.name, r14);
     */
    /* JADX WARN: Code restructure failed: missing block: B:313:0x0622, code lost:
        r1.thread.scheduleInstallProvider(r15);
     */
    /* JADX WARN: Code restructure failed: missing block: B:317:0x062a, code lost:
        r46 = r8;
        r6 = r5;
        r45 = r36;
        r2 = r40;
        r4 = null;
     */
    /* JADX WARN: Code restructure failed: missing block: B:318:0x063a, code lost:
        r0 = th;
     */
    /* JADX WARN: Code restructure failed: missing block: B:319:0x063b, code lost:
        r2 = r40;
     */
    /* JADX WARN: Code restructure failed: missing block: B:320:0x064a, code lost:
        r0 = th;
     */
    /* JADX WARN: Code restructure failed: missing block: B:321:0x064b, code lost:
        r2 = r0;
     */
    /* JADX WARN: Code restructure failed: missing block: B:329:0x06a5, code lost:
        android.util.Slog.w("ActivityManager", "Unable to launch app " + r15.applicationInfo.packageName + com.android.server.slice.SliceClientPermissions.SliceAuthority.DELIMITER + r15.applicationInfo.uid + " for provider " + r52 + ": process is bad");
     */
    /* JADX WARN: Code restructure failed: missing block: B:331:0x06db, code lost:
        android.os.Binder.restoreCallingIdentity(r0);
     */
    /* JADX WARN: Code restructure failed: missing block: B:333:0x06df, code lost:
        resetPriorityAfterLockedSection();
     */
    /* JADX WARN: Code restructure failed: missing block: B:334:0x06e3, code lost:
        return null;
     */
    /* JADX WARN: Code restructure failed: missing block: B:335:0x06e4, code lost:
        r2 = r0;
        r4 = null;
     */
    /* JADX WARN: Code restructure failed: missing block: B:336:0x06e7, code lost:
        r14.launchingApp = r1;
        r50.mLaunchingProviders.add(r14);
     */
    /* JADX WARN: Code restructure failed: missing block: B:337:0x06ee, code lost:
        android.os.Binder.restoreCallingIdentity(r2);
        r15 = r15;
     */
    /* JADX WARN: Code restructure failed: missing block: B:338:0x06f3, code lost:
        r0 = th;
     */
    /* JADX WARN: Code restructure failed: missing block: B:352:0x072f, code lost:
        r0 = th;
     */
    /* JADX WARN: Code restructure failed: missing block: B:354:0x073e, code lost:
        r46 = r8;
        r6 = r5;
        r4 = null;
        r45 = r36;
        r15 = r38;
     */
    /* JADX WARN: Code restructure failed: missing block: B:355:0x074c, code lost:
        checkTime(r6, "getContentProviderImpl: updating data structures");
     */
    /* JADX WARN: Code restructure failed: missing block: B:356:0x0751, code lost:
        if (r19 == false) goto L229;
     */
    /* JADX WARN: Code restructure failed: missing block: B:357:0x0753, code lost:
        r50.mProviderMap.putProviderByClass(r37, r14);
     */
    /* JADX WARN: Code restructure failed: missing block: B:362:0x0766, code lost:
        r50.mProviderMap.putProviderByName(r52, r14);
     */
    /* JADX WARN: Code restructure failed: missing block: B:364:0x0771, code lost:
        r0 = incProviderCountLocked(r46, r14, r53, r54);
     */
    /* JADX WARN: Code restructure failed: missing block: B:366:0x0776, code lost:
        if (r0 == null) goto L227;
     */
    /* JADX WARN: Code restructure failed: missing block: B:367:0x0778, code lost:
        r10 = 1;
     */
    /* JADX WARN: Code restructure failed: missing block: B:368:0x0779, code lost:
        r0.waiting = true;
     */
    /* JADX WARN: Code restructure failed: missing block: B:370:0x077c, code lost:
        r0 = th;
     */
    /* JADX WARN: Code restructure failed: missing block: B:372:0x0781, code lost:
        r10 = 1;
     */
    /* JADX WARN: Code restructure failed: missing block: B:373:0x0782, code lost:
        r1 = r0;
        r3 = r15;
        r12 = r12;
     */
    /* JADX WARN: Code restructure failed: missing block: B:374:0x0786, code lost:
        r0 = th;
     */
    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Not initialized variable reg: 27, insn: 0x0231: MOVE  (r3 I:??[OBJECT, ARRAY]) = (r27 I:??[OBJECT, ARRAY] A[D('cpi' android.content.pm.ProviderInfo)]), block:B:118:0x0230 */
    /* JADX WARN: Not initialized variable reg: 29, insn: 0x0233: MOVE  (r4 I:??[int, float, boolean, short, byte, char, OBJECT, ARRAY]) = (r29 I:??[int, float, boolean, short, byte, char, OBJECT, ARRAY] A[D('providerRunning' boolean)]), block:B:118:0x0230 */
    /* JADX WARN: Not initialized variable reg: 36, insn: 0x0512: MOVE  (r4 I:??[int, float, boolean, short, byte, char, OBJECT, ARRAY]) = (r36 I:??[int, float, boolean, short, byte, char, OBJECT, ARRAY] A[D('providerRunning' boolean)]), block:B:265:0x050f */
    /* JADX WARN: Not initialized variable reg: 38, insn: 0x0514: MOVE  (r3 I:??[OBJECT, ARRAY]) = (r38 I:??[OBJECT, ARRAY] A[D('cpi' android.content.pm.ProviderInfo)]), block:B:265:0x050f */
    /* JADX WARN: Not initialized variable reg: 45, insn: 0x0760: MOVE  (r4 I:??[int, float, boolean, short, byte, char, OBJECT, ARRAY]) = (r45 I:??[int, float, boolean, short, byte, char, OBJECT, ARRAY] A[D('providerRunning' boolean)]), block:B:360:0x075c */
    /* JADX WARN: Removed duplicated region for block: B:105:0x0200 A[Catch: all -> 0x022f, TRY_ENTER, TRY_LEAVE, TryCatch #6 {all -> 0x022f, blocks: (B:96:0x01a6, B:99:0x01bc, B:101:0x01f5, B:105:0x0200, B:115:0x0227, B:116:0x022e), top: B:477:0x00f6 }] */
    /* JADX WARN: Removed duplicated region for block: B:124:0x0245  */
    /* JADX WARN: Removed duplicated region for block: B:148:0x02a1  */
    /* JADX WARN: Removed duplicated region for block: B:149:0x02a4  */
    /* JADX WARN: Removed duplicated region for block: B:152:0x02ba  */
    /* JADX WARN: Removed duplicated region for block: B:153:0x02bc  */
    /* JADX WARN: Removed duplicated region for block: B:156:0x02c4 A[Catch: all -> 0x07b6, TRY_LEAVE, TryCatch #8 {all -> 0x07b6, blocks: (B:150:0x02a6, B:154:0x02bd, B:156:0x02c4, B:165:0x02e4, B:175:0x0320, B:181:0x036a), top: B:478:0x02a6 }] */
    /* JADX WARN: Removed duplicated region for block: B:258:0x04fe A[Catch: all -> 0x050e, TRY_ENTER, TryCatch #59 {all -> 0x050e, blocks: (B:246:0x04c9, B:247:0x04cc, B:250:0x04d9, B:258:0x04fe, B:260:0x0504, B:261:0x0509, B:270:0x051f, B:272:0x052d, B:274:0x0535, B:279:0x056f, B:223:0x0446), top: B:538:0x038d }] */
    /* JADX WARN: Removed duplicated region for block: B:270:0x051f A[Catch: all -> 0x050e, TRY_ENTER, TryCatch #59 {all -> 0x050e, blocks: (B:246:0x04c9, B:247:0x04cc, B:250:0x04d9, B:258:0x04fe, B:260:0x0504, B:261:0x0509, B:270:0x051f, B:272:0x052d, B:274:0x0535, B:279:0x056f, B:223:0x0446), top: B:538:0x038d }] */
    /* JADX WARN: Removed duplicated region for block: B:279:0x056f A[Catch: all -> 0x050e, TRY_ENTER, TRY_LEAVE, TryCatch #59 {all -> 0x050e, blocks: (B:246:0x04c9, B:247:0x04cc, B:250:0x04d9, B:258:0x04fe, B:260:0x0504, B:261:0x0509, B:270:0x051f, B:272:0x052d, B:274:0x0535, B:279:0x056f, B:223:0x0446), top: B:538:0x038d }] */
    /* JADX WARN: Removed duplicated region for block: B:329:0x06a5 A[Catch: all -> 0x06f5, TRY_LEAVE, TryCatch #43 {all -> 0x06f5, blocks: (B:327:0x06a0, B:329:0x06a5), top: B:517:0x06a0 }] */
    /* JADX WARN: Removed duplicated region for block: B:335:0x06e4  */
    /* JADX WARN: Removed duplicated region for block: B:357:0x0753 A[Catch: all -> 0x075b, TRY_ENTER, TRY_LEAVE, TryCatch #30 {all -> 0x075b, blocks: (B:337:0x06ee, B:357:0x0753, B:350:0x072b, B:351:0x072e, B:331:0x06db, B:332:0x06de), top: B:501:0x057b }] */
    /* JADX WARN: Removed duplicated region for block: B:361:0x0764  */
    /* JADX WARN: Removed duplicated region for block: B:367:0x0778  */
    /* JADX WARN: Removed duplicated region for block: B:372:0x0781  */
    /* JADX WARN: Removed duplicated region for block: B:379:0x0799  */
    /* JADX WARN: Removed duplicated region for block: B:391:0x07dd  */
    /* JADX WARN: Removed duplicated region for block: B:442:0x092b A[Catch: all -> 0x094e, TryCatch #20 {all -> 0x094e, blocks: (B:427:0x0913, B:428:0x0915, B:456:0x094c, B:442:0x092b, B:443:0x092d, B:436:0x091f, B:450:0x093f), top: B:493:0x091f }] */
    /* JADX WARN: Removed duplicated region for block: B:447:0x0934  */
    /* JADX WARN: Removed duplicated region for block: B:485:0x00e6 A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:489:0x080f A[EXC_TOP_SPLITTER, LOOP:0: B:489:0x080f->B:448:0x0935, LOOP_START, PHI: r10 r45 
      PHI: (r10v5 char) = (r10v4 char), (r10v10 char) binds: [B:395:0x080e, B:448:0x0935] A[DONT_GENERATE, DONT_INLINE]
      PHI: (r45v21 'providerRunning' boolean) = (r45v20 'providerRunning' boolean), (r45v22 'providerRunning' boolean) binds: [B:395:0x080e, B:448:0x0935] A[DONT_GENERATE, DONT_INLINE], SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:491:0x05e5 A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:509:0x024f A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:575:0x0935 A[SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:89:0x0183  */
    /* JADX WARN: Removed duplicated region for block: B:94:0x019b A[Catch: all -> 0x021c, TRY_LEAVE, TryCatch #67 {all -> 0x021c, blocks: (B:83:0x0163, B:92:0x018b, B:94:0x019b), top: B:548:0x0163 }] */
    /* JADX WARN: Removed duplicated region for block: B:97:0x01b6  */
    /* JADX WARN: Removed duplicated region for block: B:99:0x01bc A[Catch: all -> 0x022f, TryCatch #6 {all -> 0x022f, blocks: (B:96:0x01a6, B:99:0x01bc, B:101:0x01f5, B:105:0x0200, B:115:0x0227, B:116:0x022e), top: B:477:0x00f6 }] */
    /* JADX WARN: Type inference failed for: r12v0, types: [java.lang.Object] */
    /* JADX WARN: Type inference failed for: r12v2 */
    /* JADX WARN: Type inference failed for: r12v21, types: [int] */
    /* JADX WARN: Type inference failed for: r12v28 */
    /* JADX WARN: Type inference failed for: r12v29 */
    /* JADX WARN: Type inference failed for: r15v0, types: [boolean] */
    /* JADX WARN: Type inference failed for: r15v16 */
    /* JADX WARN: Type inference failed for: r15v17 */
    /* JADX WARN: Type inference failed for: r15v18 */
    /* JADX WARN: Type inference failed for: r15v4 */
    /* JADX WARN: Type inference failed for: r50v0, types: [com.android.server.am.ActivityManagerService] */
    /* JADX WARN: Type inference failed for: r6v0, types: [java.lang.StringBuilder] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    private android.app.ContentProviderHolder getContentProviderImpl(android.app.IApplicationThread r51, java.lang.String r52, android.os.IBinder r53, boolean r54, int r55) {
        /*
            Method dump skipped, instructions count: 2404
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.getContentProviderImpl(android.app.IApplicationThread, java.lang.String, android.os.IBinder, boolean, int):android.app.ContentProviderHolder");
    }

    private boolean requestTargetProviderPermissionsReviewIfNeededLocked(ProviderInfo cpi, ProcessRecord r, int userId) {
        boolean callerForeground = true;
        if (getPackageManagerInternalLocked().isPermissionsReviewRequired(cpi.packageName, userId)) {
            if (r != null && r.setSchedGroup == 0) {
                callerForeground = false;
            }
            if (!callerForeground) {
                Slog.w("ActivityManager", "u" + userId + " Instantiating a provider in package" + cpi.packageName + " requires a permissions review");
                return false;
            }
            final Intent intent = new Intent("android.intent.action.REVIEW_PERMISSIONS");
            intent.addFlags(276824064);
            intent.putExtra("android.intent.extra.PACKAGE_NAME", cpi.packageName);
            if (ActivityManagerDebugConfig.DEBUG_PERMISSIONS_REVIEW) {
                Slog.i("ActivityManager", "u" + userId + " Launching permission review for package " + cpi.packageName);
            }
            final UserHandle userHandle = new UserHandle(userId);
            this.mHandler.post(new Runnable() { // from class: com.android.server.am.ActivityManagerService.15
                @Override // java.lang.Runnable
                public void run() {
                    ActivityManagerService.this.mContext.startActivityAsUser(intent, userHandle);
                }
            });
            return false;
        }
        return true;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public IPackageManager getPackageManager() {
        return AppGlobals.getPackageManager();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public ActivityStartController getActivityStartController() {
        return this.mActivityStartController;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public LockTaskController getLockTaskController() {
        return this.mLockTaskController;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public ClientLifecycleManager getLifecycleManager() {
        return this.mLifecycleManager;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public PackageManagerInternal getPackageManagerInternalLocked() {
        if (this.mPackageManagerInt == null) {
            this.mPackageManagerInt = (PackageManagerInternal) LocalServices.getService(PackageManagerInternal.class);
        }
        return this.mPackageManagerInt;
    }

    public final ContentProviderHolder getContentProvider(IApplicationThread caller, String name, int userId, boolean stable) {
        enforceNotIsolatedCaller("getContentProvider");
        if (caller == null) {
            String msg = "null IApplicationThread when getting content provider " + name;
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        return getContentProviderImpl(caller, name, null, stable, userId);
    }

    public ContentProviderHolder getContentProviderExternal(String name, int userId, IBinder token) {
        enforceCallingPermission("android.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY", "Do not have permission in call getContentProviderExternal()");
        return getContentProviderExternalUnchecked(name, token, this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "getContentProvider", null));
    }

    private ContentProviderHolder getContentProviderExternalUnchecked(String name, IBinder token, int userId) {
        return getContentProviderImpl(null, name, token, true, userId);
    }

    public void removeContentProvider(IBinder connection, boolean stable) {
        enforceNotIsolatedCaller("removeContentProvider");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    ContentProviderConnection conn = (ContentProviderConnection) connection;
                    if (conn == null) {
                        throw new NullPointerException("connection is null");
                    }
                    if (decProviderCountLocked(conn, null, null, stable)) {
                        updateOomAdjLocked();
                    }
                } catch (ClassCastException e) {
                    String msg = "removeContentProvider: " + connection + " not a ContentProviderConnection";
                    Slog.w("ActivityManager", msg);
                    throw new IllegalArgumentException(msg);
                }
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void removeContentProviderExternal(String name, IBinder token) {
        enforceCallingPermission("android.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY", "Do not have permission in call removeContentProviderExternal()");
        int userId = UserHandle.getCallingUserId();
        long ident = Binder.clearCallingIdentity();
        try {
            removeContentProviderExternalUnchecked(name, token, userId);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    private void removeContentProviderExternalUnchecked(String name, IBinder token, int userId) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ContentProviderRecord cpr = this.mProviderMap.getProviderByName(name, userId);
                if (cpr == null) {
                    if (ActivityManagerDebugConfig.DEBUG_ALL) {
                        Slog.v("ActivityManager", name + " content provider not found in providers list");
                    }
                    resetPriorityAfterLockedSection();
                    return;
                }
                ComponentName comp = new ComponentName(cpr.info.packageName, cpr.info.name);
                ContentProviderRecord localCpr = this.mProviderMap.getProviderByClass(comp, userId);
                if (localCpr.hasExternalProcessHandles()) {
                    if (localCpr.removeExternalProcessHandleLocked(token)) {
                        updateOomAdjLocked();
                    } else {
                        Slog.e("ActivityManager", "Attmpt to remove content provider " + localCpr + " with no external reference for token: " + token + ".");
                    }
                } else {
                    Slog.e("ActivityManager", "Attmpt to remove content provider: " + localCpr + " with no external references.");
                }
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public final void publishContentProviders(IApplicationThread caller, List<ContentProviderHolder> providers) {
        if (providers == null) {
            return;
        }
        enforceNotIsolatedCaller("publishContentProviders");
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    ProcessRecord r = getRecordForAppLocked(caller);
                    if (ActivityManagerDebugConfig.DEBUG_MU) {
                        Slog.v(TAG_MU, "ProcessRecord uid = " + r.uid);
                    }
                    if (r == null) {
                        StringBuilder sb = new StringBuilder();
                        sb.append("Unable to find app for caller ");
                        sb.append(caller);
                        sb.append(" (pid=");
                        sb.append(Binder.getCallingPid());
                        sb.append(") when publishing content providers");
                        throw new SecurityException(sb.toString());
                    }
                    long origId = Binder.clearCallingIdentity();
                    int N = providers.size();
                    for (int i = 0; i < N; i++) {
                        ContentProviderHolder src = providers.get(i);
                        if (src != null && src.info != null && src.provider != null) {
                            ContentProviderRecord dst = r.pubProviders.get(src.info.name);
                            if (ActivityManagerDebugConfig.DEBUG_MU) {
                                Slog.v(TAG_MU, "ContentProviderRecord uid = " + dst.uid);
                            }
                            if (dst != null) {
                                ComponentName comp = new ComponentName(dst.info.packageName, dst.info.name);
                                this.mProviderMap.putProviderByClass(comp, dst);
                                String[] names = dst.info.authority.split(";");
                                for (String str : names) {
                                    this.mProviderMap.putProviderByName(str, dst);
                                }
                                int launchingCount = this.mLaunchingProviders.size();
                                boolean wasInLaunchingProviders = false;
                                int launchingCount2 = launchingCount;
                                int j = 0;
                                while (j < launchingCount2) {
                                    if (this.mLaunchingProviders.get(j) == dst) {
                                        this.mLaunchingProviders.remove(j);
                                        j--;
                                        launchingCount2--;
                                        wasInLaunchingProviders = true;
                                    }
                                    j++;
                                }
                                if (wasInLaunchingProviders) {
                                    this.mHandler.removeMessages(57, r);
                                }
                                synchronized (dst) {
                                    dst.provider = src.provider;
                                    dst.proc = r;
                                    dst.notifyAll();
                                }
                                updateOomAdjLocked(r, true);
                                maybeUpdateProviderUsageStatsLocked(r, src.info.packageName, src.info.authority);
                            }
                        }
                    }
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                } catch (Throwable th) {
                    th = th;
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            } catch (Throwable th2) {
                th = th2;
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public boolean refContentProvider(IBinder connection, int stable, int unstable) {
        boolean z;
        try {
            ContentProviderConnection conn = (ContentProviderConnection) connection;
            if (conn == null) {
                throw new NullPointerException("connection is null");
            }
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (stable > 0) {
                        conn.numStableIncs += stable;
                    }
                    int stable2 = stable + conn.stableCount;
                    if (stable2 < 0) {
                        throw new IllegalStateException("stableCount < 0: " + stable2);
                    }
                    if (unstable > 0) {
                        conn.numUnstableIncs += unstable;
                    }
                    int unstable2 = unstable + conn.unstableCount;
                    if (unstable2 < 0) {
                        throw new IllegalStateException("unstableCount < 0: " + unstable2);
                    } else if (stable2 + unstable2 <= 0) {
                        throw new IllegalStateException("ref counts can't go to zero here: stable=" + stable2 + " unstable=" + unstable2);
                    } else {
                        conn.stableCount = stable2;
                        conn.unstableCount = unstable2;
                        z = !conn.dead;
                    }
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            resetPriorityAfterLockedSection();
            return z;
        } catch (ClassCastException e) {
            String msg = "refContentProvider: " + connection + " not a ContentProviderConnection";
            Slog.w("ActivityManager", msg);
            throw new IllegalArgumentException(msg);
        }
    }

    public void unstableProviderDied(IBinder connection) {
        IContentProvider provider;
        try {
            ContentProviderConnection conn = (ContentProviderConnection) connection;
            if (conn == null) {
                throw new NullPointerException("connection is null");
            }
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    provider = conn.provider.provider;
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
            resetPriorityAfterLockedSection();
            if (provider == null) {
                return;
            }
            if (provider.asBinder().pingBinder()) {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        Slog.w("ActivityManager", "unstableProviderDied: caller " + Binder.getCallingUid() + " says " + conn + " died, but we don't agree");
                    } finally {
                    }
                }
                resetPriorityAfterLockedSection();
                return;
            }
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (conn.provider.provider != provider) {
                        return;
                    }
                    ProcessRecord proc = conn.provider.proc;
                    if (proc != null && proc.thread != null) {
                        reportUidInfoMessageLocked("ActivityManager", "Process " + proc.processName + " (pid " + proc.pid + ") early provider death", proc.info.uid);
                        long ident = Binder.clearCallingIdentity();
                        appDiedLocked(proc);
                        Binder.restoreCallingIdentity(ident);
                        resetPriorityAfterLockedSection();
                        return;
                    }
                    resetPriorityAfterLockedSection();
                } finally {
                    resetPriorityAfterLockedSection();
                }
            }
        } catch (ClassCastException e) {
            String msg = "refContentProvider: " + connection + " not a ContentProviderConnection";
            Slog.w("ActivityManager", msg);
            throw new IllegalArgumentException(msg);
        }
    }

    public void appNotRespondingViaProvider(IBinder connection) {
        enforceCallingPermission("android.permission.REMOVE_TASKS", "appNotRespondingViaProvider()");
        ContentProviderConnection conn = (ContentProviderConnection) connection;
        if (conn == null) {
            Slog.w("ActivityManager", "ContentProviderConnection is null");
            return;
        }
        final ProcessRecord host = conn.provider.proc;
        if (host == null) {
            Slog.w("ActivityManager", "Failed to find hosting ProcessRecord");
        } else {
            this.mHandler.post(new Runnable() { // from class: com.android.server.am.ActivityManagerService.16
                @Override // java.lang.Runnable
                public void run() {
                    ActivityManagerService.this.mAppErrors.appNotResponding(host, null, null, false, "ContentProvider not responding");
                }
            });
        }
    }

    public final void installSystemProviders() {
        List<ProviderInfo> providers;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord app = (ProcessRecord) this.mProcessNames.get("system", 1000);
                providers = generateApplicationProvidersLocked(app);
                if (providers != null) {
                    for (int i = providers.size() - 1; i >= 0; i--) {
                        ProviderInfo pi = providers.get(i);
                        if ((pi.applicationInfo.flags & 1) == 0) {
                            Slog.w("ActivityManager", "Not installing system proc provider " + pi.name + ": not system .apk");
                            providers.remove(i);
                        }
                    }
                }
            } finally {
            }
        }
        resetPriorityAfterLockedSection();
        if (providers != null) {
            this.mSystemThread.installSystemProviders(providers);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mSystemProvidersInstalled = true;
            } finally {
            }
        }
        resetPriorityAfterLockedSection();
        this.mConstants.start(this.mContext.getContentResolver());
        this.mCoreSettingsObserver = new CoreSettingsObserver(this);
        this.mFontScaleSettingObserver = new FontScaleSettingObserver();
        this.mDevelopmentSettingsObserver = new DevelopmentSettingsObserver();
        GlobalSettingsToPropertiesMapper.start(this.mContext.getContentResolver());
        RescueParty.onSettingsProviderPublished(this.mContext);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void startPersistentApps(int matchFlags) {
        if (this.mFactoryTest == 1) {
            return;
        }
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    List<ApplicationInfo> apps = AppGlobals.getPackageManager().getPersistentApplications(1024 | matchFlags).getList();
                    for (ApplicationInfo app : apps) {
                        if (!PackageManagerService.PLATFORM_PACKAGE_NAME.equals(app.packageName)) {
                            addAppLocked(app, null, false, null);
                        }
                    }
                } catch (RemoteException e) {
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* JADX WARN: Removed duplicated region for block: B:53:0x00c2 A[ADDED_TO_REGION] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public void installEncryptionUnawareProviders(int r25) {
        /*
            Method dump skipped, instructions count: 363
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.installEncryptionUnawareProviders(int):void");
    }

    public String getProviderMimeType(Uri uri, int userId) {
        enforceNotIsolatedCaller("getProviderMimeType");
        String name = uri.getAuthority();
        int callingUid = Binder.getCallingUid();
        int callingPid = Binder.getCallingPid();
        long ident = 0;
        boolean clearedIdentity = false;
        int userId2 = this.mUserController.unsafeConvertIncomingUser(userId);
        if (canClearIdentity(callingPid, callingUid, userId2)) {
            clearedIdentity = true;
            ident = Binder.clearCallingIdentity();
        }
        ContentProviderHolder holder = null;
        try {
            try {
                holder = getContentProviderExternalUnchecked(name, null, userId2);
                if (holder == null) {
                    if (!clearedIdentity) {
                        ident = Binder.clearCallingIdentity();
                    }
                    if (holder != null) {
                        try {
                            removeContentProviderExternalUnchecked(name, null, userId2);
                        } finally {
                        }
                    }
                    return null;
                }
                String type = holder.provider.getType(uri);
                if (!clearedIdentity) {
                    ident = Binder.clearCallingIdentity();
                }
                if (holder != null) {
                    try {
                        removeContentProviderExternalUnchecked(name, null, userId2);
                    } finally {
                    }
                }
                return type;
            } catch (Throwable th) {
                if (!clearedIdentity) {
                    ident = Binder.clearCallingIdentity();
                }
                if (holder != null) {
                    try {
                        removeContentProviderExternalUnchecked(name, null, userId2);
                    } finally {
                    }
                }
                throw th;
            }
        } catch (RemoteException e) {
            Log.w("ActivityManager", "Content provider dead retrieving " + uri, e);
            if (!clearedIdentity) {
                ident = Binder.clearCallingIdentity();
            }
            if (holder != null) {
                try {
                    removeContentProviderExternalUnchecked(name, null, userId2);
                } finally {
                }
            }
            return null;
        } catch (Exception e2) {
            Log.w("ActivityManager", "Exception while determining type of " + uri, e2);
            if (!clearedIdentity) {
                ident = Binder.clearCallingIdentity();
            }
            if (holder != null) {
                try {
                    removeContentProviderExternalUnchecked(name, null, userId2);
                } finally {
                }
            }
            return null;
        }
    }

    private boolean canClearIdentity(int callingPid, int callingUid, int userId) {
        return UserHandle.getUserId(callingUid) == userId || checkComponentPermission("android.permission.INTERACT_ACROSS_USERS", callingPid, callingUid, -1, true) == 0 || checkComponentPermission("android.permission.INTERACT_ACROSS_USERS_FULL", callingPid, callingUid, -1, true) == 0;
    }

    @GuardedBy("this")
    final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) {
        String proc = customProcess != null ? customProcess : info.processName;
        BatteryStatsImpl stats = this.mBatteryStatsService.getActiveStatistics();
        int userId = UserHandle.getUserId(info.uid);
        int uid = info.uid;
        if (isolated) {
            if (isolatedUid == 0) {
                int stepsLeft = 1000;
                do {
                    if (this.mNextIsolatedProcessUid < 99000 || this.mNextIsolatedProcessUid > 99999) {
                        this.mNextIsolatedProcessUid = 99000;
                    }
                    uid = UserHandle.getUid(userId, this.mNextIsolatedProcessUid);
                    this.mNextIsolatedProcessUid++;
                    if (this.mIsolatedProcesses.indexOfKey(uid) >= 0) {
                        stepsLeft--;
                    }
                } while (stepsLeft > 0);
                return null;
            }
            uid = isolatedUid;
            getPackageManagerInternalLocked().addIsolatedUid(uid, info.uid);
            this.mBatteryStatsService.addIsolatedUid(uid, info.uid);
        }
        ProcessRecord r = new ProcessRecord(this, stats, info, proc, uid);
        if (!this.mBooted && !this.mBooting && userId == 0 && ProcessManagerPolicy.isPersistent(info.packageName) && (info.flags & 9) == 9) {
            r.curSchedGroup = 2;
            r.setSchedGroup = 2;
            r.persistent = true;
            r.maxAdj = -800;
        }
        if (isolated && isolatedUid != 0) {
            r.maxAdj = -700;
        }
        addProcessNameLocked(r);
        return r;
    }

    private boolean uidOnBackgroundWhitelist(int uid) {
        int appId = UserHandle.getAppId(uid);
        int[] whitelist = this.mBackgroundAppIdWhitelist;
        for (int i : whitelist) {
            if (appId == i) {
                return true;
            }
        }
        return false;
    }

    public boolean isBackgroundRestricted(String packageName) {
        int packageUid;
        int callingUid = Binder.getCallingUid();
        IPackageManager pm = AppGlobals.getPackageManager();
        try {
            packageUid = pm.getPackageUid(packageName, 268435456, UserHandle.getUserId(callingUid));
        } catch (RemoteException e) {
        }
        if (packageUid != callingUid) {
            throw new IllegalArgumentException("Uid " + callingUid + " cannot query restriction state for package " + packageName);
        }
        return isBackgroundRestrictedNoCheck(callingUid, packageName);
    }

    boolean isBackgroundRestrictedNoCheck(int uid, String packageName) {
        int mode = this.mAppOpsService.checkOperation(70, uid, packageName);
        return mode != 0;
    }

    public void backgroundWhitelistUid(int uid) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("Only the OS may call backgroundWhitelistUid()");
        }
        if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
            Slog.i("ActivityManager", "Adding uid " + uid + " to bg uid whitelist");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int N = this.mBackgroundAppIdWhitelist.length;
                int[] newList = new int[N + 1];
                System.arraycopy(this.mBackgroundAppIdWhitelist, 0, newList, 0, N);
                newList[N] = UserHandle.getAppId(uid);
                this.mBackgroundAppIdWhitelist = newList;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    @GuardedBy("this")
    final ProcessRecord addAppLocked(ApplicationInfo info, String customProcess, boolean isolated, String abiOverride) {
        return addAppLocked(info, customProcess, isolated, false, abiOverride);
    }

    final ProcessRecord addAppLocked(ApplicationInfo info, String customProcess, boolean isolated, boolean disableHiddenApiChecks, String abiOverride) {
        ProcessRecord app;
        String str;
        if (!isolated) {
            app = getProcessRecordLocked(customProcess != null ? customProcess : info.processName, info.uid, true);
        } else {
            app = null;
        }
        if (app == null) {
            app = newProcessRecordLocked(info, customProcess, isolated, 0);
            updateLruProcessLocked(app, false, null);
            updateOomAdjLocked();
        }
        try {
            AppGlobals.getPackageManager().setPackageStoppedState(info.packageName, false, UserHandle.getUserId(app.uid));
        } catch (RemoteException e) {
        } catch (IllegalArgumentException e2) {
            Slog.w("ActivityManager", "Failed trying to unstop package " + info.packageName + ": " + e2);
        }
        if ((info.flags & 9) == 9 && ProcessManagerPolicy.isPersistent(info.packageName)) {
            app.persistent = true;
            app.maxAdj = -800;
        }
        if (app.thread == null && this.mPersistentStartingProcesses.indexOf(app) < 0) {
            this.mPersistentStartingProcesses.add(app);
            if (customProcess != null) {
                str = customProcess;
            } else {
                str = app.processName;
            }
            startProcessLocked(app, "added application", str, disableHiddenApiChecks, abiOverride);
        }
        return app;
    }

    public void unhandledBack() {
        enforceCallingPermission("android.permission.FORCE_BACK", "unhandledBack()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                getFocusedStack().unhandledBackLocked();
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public ParcelFileDescriptor openContentUri(String uriString) throws RemoteException {
        enforceNotIsolatedCaller("openContentUri");
        int userId = UserHandle.getCallingUserId();
        Uri uri = Uri.parse(uriString);
        String name = uri.getAuthority();
        ContentProviderHolder cph = getContentProviderExternalUnchecked(name, null, userId);
        if (cph != null) {
            Binder token = new Binder();
            sCallerIdentity.set(new Identity(token, Binder.getCallingPid(), Binder.getCallingUid()));
            try {
                ParcelFileDescriptor pfd = cph.provider.openFile((String) null, uri, "r", (ICancellationSignal) null, token);
                return pfd;
            } catch (FileNotFoundException e) {
                return null;
            } finally {
                sCallerIdentity.remove();
                removeContentProviderExternalUnchecked(name, null, userId);
            }
        }
        Slog.d("ActivityManager", "Failed to get provider for authority '" + name + "'");
        return null;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean isSleepingOrShuttingDownLocked() {
        return isSleepingLocked() || this.mShuttingDown;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean isShuttingDownLocked() {
        return this.mShuttingDown;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean isSleepingLocked() {
        return this.mSleeping;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void reportGlobalUsageEventLocked(int event) {
        this.mUsageStatsService.reportEvent(PackageManagerService.PLATFORM_PACKAGE_NAME, this.mUserController.getCurrentUserId(), event);
        int[] profiles = this.mUserController.getCurrentProfileIds();
        if (profiles != null) {
            for (int i = profiles.length - 1; i >= 0; i--) {
                this.mUsageStatsService.reportEvent((String) null, profiles[i], event);
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void reportCurWakefulnessUsageEventLocked() {
        int i;
        if (this.mWakefulness == 1) {
            i = 15;
        } else {
            i = 16;
        }
        reportGlobalUsageEventLocked(i);
    }

    void reportCurKeyguardUsageEventLocked() {
        int i;
        if (this.mKeyguardShown) {
            i = 17;
        } else {
            i = 18;
        }
        reportGlobalUsageEventLocked(i);
    }

    void onWakefulnessChanged(int wakefulness) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int i = 1;
                boolean wasAwake = this.mWakefulness == 1;
                boolean isAwake = wakefulness == 1;
                this.mWakefulness = wakefulness;
                if (wasAwake != isAwake) {
                    this.mServices.updateScreenStateLocked(isAwake);
                    reportCurWakefulnessUsageEventLocked();
                    MainHandler mainHandler = this.mHandler;
                    if (!isAwake) {
                        i = 0;
                    }
                    mainHandler.obtainMessage(64, i, 0).sendToTarget();
                }
                updateOomAdjLocked();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public void finishRunningVoiceLocked() {
        if (this.mRunningVoice != null) {
            this.mRunningVoice = null;
            this.mVoiceWakeLock.release();
            updateSleepIfNeededLocked();
        }
    }

    void startTimeTrackingFocusedActivityLocked() {
        ActivityRecord resumedActivity = this.mStackSupervisor.getResumedActivityLocked();
        if (!this.mSleeping && this.mCurAppTimeTracker != null && resumedActivity != null) {
            this.mCurAppTimeTracker.start(resumedActivity.packageName);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public void updateSleepIfNeededLocked() {
        boolean shouldSleep = !this.mStackSupervisor.hasAwakeDisplay();
        boolean wasSleeping = this.mSleeping;
        if (!shouldSleep) {
            if (wasSleeping) {
                this.mSleeping = false;
                startTimeTrackingFocusedActivityLocked();
                this.mTopProcessState = 2;
                this.mStackSupervisor.comeOutOfSleepIfNeededLocked();
            }
            this.mStackSupervisor.applySleepTokensLocked(true);
            if (wasSleeping) {
                updateOomAdjLocked();
            }
        } else if (!this.mSleeping && shouldSleep) {
            this.mSleeping = true;
            if (this.mCurAppTimeTracker != null) {
                this.mCurAppTimeTracker.stop();
            }
            this.mTopProcessState = 11;
            this.mStackSupervisor.goingToSleepLocked();
            updateResumedAppTrace(null);
            updateOomAdjLocked();
        }
        xpLogger.i("ActivityManager", "updateSleepIfNeededLocked shouldSleep=" + shouldSleep + " wasSleeping=" + wasSleeping + " sleeping=" + this.mSleeping + " state=" + this.mTopProcessState);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void notifyTaskPersisterLocked(TaskRecord task, boolean flush) {
        this.mRecentTasks.notifyTaskPersisterLocked(task, flush);
    }

    public void notifyPinnedStackAnimationStarted() {
        this.mTaskChangeNotificationController.notifyPinnedStackAnimationStarted();
    }

    public void notifyPinnedStackAnimationEnded() {
        this.mTaskChangeNotificationController.notifyPinnedStackAnimationEnded();
    }

    public void notifyCleartextNetwork(int uid, byte[] firstPacket) {
        this.mHandler.obtainMessage(49, uid, 0, firstPacket).sendToTarget();
    }

    public boolean shutdown(int timeout) {
        boolean timedout;
        if (checkCallingPermission("android.permission.SHUTDOWN") != 0) {
            throw new SecurityException("Requires permission android.permission.SHUTDOWN");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mShuttingDown = true;
                this.mStackSupervisor.prepareForShutdownLocked();
                updateEventDispatchingLocked();
                timedout = this.mStackSupervisor.shutdownLocked(timeout);
            } finally {
            }
        }
        resetPriorityAfterLockedSection();
        this.mAppOpsService.shutdown();
        if (this.mUsageStatsService != null) {
            this.mUsageStatsService.prepareShutdown();
        }
        this.mBatteryStatsService.shutdown();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mProcessStats.shutdownLocked();
                notifyTaskPersisterLocked(null, true);
            } finally {
            }
        }
        resetPriorityAfterLockedSection();
        return timedout;
    }

    public final void activitySlept(IBinder token) {
        if (ActivityManagerDebugConfig.DEBUG_ALL) {
            Slog.v("ActivityManager", "Activity slept: token=" + token);
        }
        long origId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    this.mStackSupervisor.activitySleptLocked(r);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        Binder.restoreCallingIdentity(origId);
    }

    @GuardedBy("this")
    void startRunningVoiceLocked(IVoiceInteractionSession session, int targetUid) {
        Slog.d("ActivityManager", "<<<  startRunningVoiceLocked()");
        this.mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
        if (this.mRunningVoice == null || this.mRunningVoice.asBinder() != session.asBinder()) {
            boolean wasRunningVoice = this.mRunningVoice != null;
            this.mRunningVoice = session;
            if (!wasRunningVoice) {
                this.mVoiceWakeLock.acquire();
                updateSleepIfNeededLocked();
            }
        }
    }

    private void updateEventDispatchingLocked() {
        this.mWindowManager.setEventDispatching(this.mBooted && !this.mShuttingDown);
    }

    public void setLockScreenShown(boolean keyguardShowing, boolean aodShowing, int secondaryDisplayShowing) {
        if (checkCallingPermission("android.permission.DEVICE_POWER") != 0) {
            throw new SecurityException("Requires permission android.permission.DEVICE_POWER");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                if (this.mKeyguardShown != keyguardShowing) {
                    this.mKeyguardShown = keyguardShowing;
                    reportCurKeyguardUsageEventLocked();
                }
                this.mKeyguardController.setKeyguardShown(keyguardShowing, aodShowing, secondaryDisplayShowing);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        this.mHandler.obtainMessage(65, keyguardShowing ? 1 : 0, 0).sendToTarget();
    }

    public void notifyLockedProfile(int userId) {
        try {
            if (!AppGlobals.getPackageManager().isUidPrivileged(Binder.getCallingUid())) {
                throw new SecurityException("Only privileged app can call notifyLockedProfile");
            }
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    long ident = Binder.clearCallingIdentity();
                    if (this.mUserController.shouldConfirmCredentials(userId)) {
                        if (this.mKeyguardController.isKeyguardLocked()) {
                            int currentUserId = this.mUserController.getCurrentUserId();
                            startHomeActivityLocked(currentUserId, "notifyLockedProfile");
                        }
                        this.mStackSupervisor.lockAllProfileTasks(userId);
                    }
                    Binder.restoreCallingIdentity(ident);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            resetPriorityAfterLockedSection();
        } catch (RemoteException ex) {
            throw new SecurityException("Fail to check is caller a privileged app", ex);
        }
    }

    public void startConfirmDeviceCredentialIntent(Intent intent, Bundle options) {
        ActivityOptions activityOptions;
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "startConfirmDeviceCredentialIntent");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long ident = Binder.clearCallingIdentity();
                intent.addFlags(276840448);
                if (options != null) {
                    activityOptions = new ActivityOptions(options);
                } else {
                    activityOptions = ActivityOptions.makeBasic();
                }
                activityOptions.setLaunchTaskId(this.mStackSupervisor.getHomeActivity().getTask().taskId);
                this.mContext.startActivityAsUser(intent, activityOptions.toBundle(), UserHandle.CURRENT);
                Binder.restoreCallingIdentity(ident);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void stopAppSwitches() {
        enforceCallerIsRecentsOrHasPermission("android.permission.STOP_APP_SWITCHES", "stopAppSwitches");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + 5000;
                this.mDidAppSwitch = false;
                this.mActivityStartController.schedulePendingActivityLaunches(5000L);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void resumeAppSwitches() {
        enforceCallerIsRecentsOrHasPermission("android.permission.STOP_APP_SWITCHES", "resumeAppSwitches");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mAppSwitchesAllowedTime = 0L;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    boolean checkAllowAppSwitchUid(int uid) {
        ArrayMap<String, Integer> types = this.mAllowAppSwitchUids.get(UserHandle.getUserId(uid));
        if (types != null) {
            for (int i = types.size() - 1; i >= 0; i--) {
                if (types.valueAt(i).intValue() == uid) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean checkAppSwitchAllowedLocked(int sourcePid, int sourceUid, int callingPid, int callingUid, String name) {
        if (this.mAppSwitchesAllowedTime >= SystemClock.uptimeMillis() && !this.mRecentTasks.isCallerRecents(sourceUid)) {
            int perm = checkComponentPermission("android.permission.STOP_APP_SWITCHES", sourcePid, sourceUid, -1, true);
            if (perm == 0 || checkAllowAppSwitchUid(sourceUid)) {
                return true;
            }
            if (callingUid != -1 && callingUid != sourceUid) {
                int perm2 = checkComponentPermission("android.permission.STOP_APP_SWITCHES", callingPid, callingUid, -1, true);
                if (perm2 == 0 || checkAllowAppSwitchUid(callingUid)) {
                    return true;
                }
            }
            Slog.w("ActivityManager", name + " request from " + sourceUid + " stopped");
            return false;
        }
        return true;
    }

    /*  JADX ERROR: JadxRuntimeException in pass: BlockProcessor
        jadx.core.utils.exceptions.JadxRuntimeException: Unreachable block: B:24:0x005e
        	at jadx.core.dex.visitors.blocks.BlockProcessor.checkForUnreachableBlocks(BlockProcessor.java:81)
        	at jadx.core.dex.visitors.blocks.BlockProcessor.processBlocksTree(BlockProcessor.java:47)
        	at jadx.core.dex.visitors.blocks.BlockProcessor.visit(BlockProcessor.java:39)
        */
    public void setDebugApp(java.lang.String r18, boolean r19, boolean r20) {
        /*
            r17 = this;
            r11 = r17
            r12 = r18
            r13 = r19
            java.lang.String r0 = "android.permission.SET_DEBUG_APP"
            java.lang.String r1 = "setDebugApp()"
            r11.enforceCallingPermission(r0, r1)
            long r0 = android.os.Binder.clearCallingIdentity()
            r9 = r0
            if (r20 == 0) goto L2c
            android.content.Context r0 = r11.mContext     // Catch: java.lang.Throwable -> L28
            android.content.ContentResolver r0 = r0.getContentResolver()     // Catch: java.lang.Throwable -> L28
            java.lang.String r1 = "debug_app"
            android.provider.Settings.Global.putString(r0, r1, r12)     // Catch: java.lang.Throwable -> L28
            java.lang.String r1 = "wait_for_debugger"
            android.provider.Settings.Global.putInt(r0, r1, r13)     // Catch: java.lang.Throwable -> L28
            goto L2c
        L28:
            r0 = move-exception
            r1 = r9
            goto L7f
        L2c:
            monitor-enter(r17)     // Catch: java.lang.Throwable -> L7d
            boostPriorityForLockedSection()     // Catch: java.lang.Throwable -> L72
            if (r20 != 0) goto L3e
            java.lang.String r0 = r11.mDebugApp     // Catch: java.lang.Throwable -> L3b
            r11.mOrigDebugApp = r0     // Catch: java.lang.Throwable -> L3b
            boolean r0 = r11.mWaitForDebugger     // Catch: java.lang.Throwable -> L3b
            r11.mOrigWaitForDebugger = r0     // Catch: java.lang.Throwable -> L3b
            goto L3e
        L3b:
            r0 = move-exception
            r1 = r9
            goto L74
        L3e:
            r11.mDebugApp = r12     // Catch: java.lang.Throwable -> L72
            r11.mWaitForDebugger = r13     // Catch: java.lang.Throwable -> L72
            r0 = r20 ^ 1
            r11.mDebugTransient = r0     // Catch: java.lang.Throwable -> L72
            if (r12 == 0) goto L61
            r3 = -1
            r4 = 0
            r5 = 0
            r6 = 1
            r7 = 1
            r8 = 0
            r0 = -1
            java.lang.String r14 = "set debug app"
            r1 = r11
            r2 = r12
            r15 = r9
            r9 = r0
            r10 = r14
            r1.forceStopPackageLocked(r2, r3, r4, r5, r6, r7, r8, r9, r10)     // Catch: java.lang.Throwable -> L5b
            goto L62
        L5b:
            r0 = move-exception
            r1 = r15
            goto L74
        L5e:
            r0 = move-exception
            r1 = r9
            goto L74
        L61:
            r15 = r9
        L62:
            monitor-exit(r17)     // Catch: java.lang.Throwable -> L6f
            resetPriorityAfterLockedSection()     // Catch: java.lang.Throwable -> L6c
            r1 = r15
            android.os.Binder.restoreCallingIdentity(r1)
            return
        L6c:
            r0 = move-exception
            r1 = r15
            goto L7f
        L6f:
            r0 = move-exception
            r1 = r15
            goto L74
        L72:
            r0 = move-exception
            r1 = r9
        L74:
            monitor-exit(r17)     // Catch: java.lang.Throwable -> L7b
            resetPriorityAfterLockedSection()     // Catch: java.lang.Throwable -> L79
            throw r0     // Catch: java.lang.Throwable -> L79
        L79:
            r0 = move-exception
            goto L7f
        L7b:
            r0 = move-exception
            goto L74
        L7d:
            r0 = move-exception
            r1 = r9
        L7f:
            android.os.Binder.restoreCallingIdentity(r1)
            throw r0
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.setDebugApp(java.lang.String, boolean, boolean):void");
    }

    public void setAgentApp(String packageName, String agent) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                }
                if (agent == null) {
                    if (this.mAppAgentMap != null) {
                        this.mAppAgentMap.remove(packageName);
                        if (this.mAppAgentMap.isEmpty()) {
                            this.mAppAgentMap = null;
                        }
                    }
                } else {
                    if (this.mAppAgentMap == null) {
                        this.mAppAgentMap = new HashMap();
                    }
                    if (this.mAppAgentMap.size() >= 100) {
                        Slog.e("ActivityManager", "App agent map has too many entries, cannot add " + packageName + SliceClientPermissions.SliceAuthority.DELIMITER + agent);
                        resetPriorityAfterLockedSection();
                        return;
                    }
                    this.mAppAgentMap.put(packageName, agent);
                }
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void setTrackAllocationApp(ApplicationInfo app, String processName) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
                if (!isDebuggable && (app.flags & 2) == 0) {
                    throw new SecurityException("Process not debuggable: " + app.packageName);
                }
                this.mTrackAllocationApp = processName;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void setProfileApp(ApplicationInfo app, String processName, ProfilerInfo profilerInfo) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
                if (!isDebuggable && (app.flags & 2) == 0) {
                    throw new SecurityException("Process not debuggable: " + app.packageName);
                }
                this.mProfileApp = processName;
                if (this.mProfilerInfo != null && this.mProfilerInfo.profileFd != null) {
                    try {
                        this.mProfilerInfo.profileFd.close();
                    } catch (IOException e) {
                    }
                }
                this.mProfilerInfo = new ProfilerInfo(profilerInfo);
                this.mProfileType = 0;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void setNativeDebuggingAppLocked(ApplicationInfo app, String processName) {
        boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
        if (!isDebuggable && (app.flags & 2) == 0) {
            throw new SecurityException("Process not debuggable: " + app.packageName);
        }
        this.mNativeDebuggingApp = processName;
    }

    public void setAlwaysFinish(boolean enabled) {
        enforceCallingPermission("android.permission.SET_ALWAYS_FINISH", "setAlwaysFinish()");
        long ident = Binder.clearCallingIdentity();
        try {
            Settings.Global.putInt(this.mContext.getContentResolver(), "always_finish_activities", enabled ? 1 : 0);
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mAlwaysFinishActivities = enabled;
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public void setActivityController(IActivityController controller, boolean imAMonkey) {
        enforceCallingPermission("android.permission.SET_ACTIVITY_WATCHER", "setActivityController()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mController = controller;
                this.mControllerIsAMonkey = imAMonkey;
                Watchdog.getInstance().setActivityController(controller);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void setUserIsMonkey(boolean userIsMonkey) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    int callingPid = Binder.getCallingPid();
                    ProcessRecord proc = this.mPidsSelfLocked.get(callingPid);
                    if (proc == null) {
                        throw new SecurityException("Unknown process: " + callingPid);
                    } else if (proc.instr == null || proc.instr.mUiAutomationConnection == null) {
                        throw new SecurityException("Only an instrumentation process with a UiAutomation can call setUserIsMonkey");
                    }
                }
                this.mUserIsMonkey = userIsMonkey;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean isUserAMonkey() {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                z = this.mUserIsMonkey || (this.mController != null && this.mControllerIsAMonkey);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return z;
    }

    @Deprecated
    public void requestBugReport(int bugreportType) {
        String extraOptions = null;
        switch (bugreportType) {
            case 0:
                break;
            case 1:
                extraOptions = "bugreportplus";
                break;
            case 2:
                extraOptions = "bugreportremote";
                break;
            case 3:
                extraOptions = "bugreportwear";
                break;
            case 4:
                extraOptions = "bugreporttelephony";
                break;
            case 5:
                extraOptions = "bugreportwifi";
                break;
            default:
                throw new IllegalArgumentException("Provided bugreport type is not correct, value: " + bugreportType);
        }
        String type = extraOptions == null ? "bugreport" : extraOptions;
        Slog.i("ActivityManager", type + " requested by UID " + Binder.getCallingUid());
        enforceCallingPermission("android.permission.DUMP", "requestBugReport");
        if (extraOptions != null) {
            SystemProperties.set("dumpstate.options", extraOptions);
        }
        SystemProperties.set("ctl.start", "bugreport");
    }

    @Deprecated
    private void requestBugReportWithDescription(String shareTitle, String shareDescription, int bugreportType) {
        if (!TextUtils.isEmpty(shareTitle)) {
            if (shareTitle.length() > 50) {
                throw new IllegalArgumentException("shareTitle should be less than 50 characters");
            }
            if (!TextUtils.isEmpty(shareDescription)) {
                try {
                    int length = shareDescription.getBytes("UTF-8").length;
                    if (length > 91) {
                        throw new IllegalArgumentException("shareTitle should be less than 91 bytes");
                    }
                    SystemProperties.set("dumpstate.options.description", shareDescription);
                } catch (UnsupportedEncodingException e) {
                    throw new IllegalArgumentException("shareDescription: UnsupportedEncodingException");
                }
            }
            SystemProperties.set("dumpstate.options.title", shareTitle);
        }
        Slog.d("ActivityManager", "Bugreport notification title " + shareTitle + " description " + shareDescription);
        requestBugReport(bugreportType);
    }

    @Deprecated
    public void requestTelephonyBugReport(String shareTitle, String shareDescription) {
        requestBugReportWithDescription(shareTitle, shareDescription, 4);
    }

    @Deprecated
    public void requestWifiBugReport(String shareTitle, String shareDescription) {
        requestBugReportWithDescription(shareTitle, shareDescription, 5);
    }

    public static long getInputDispatchingTimeoutLocked(ActivityRecord r) {
        if (r != null) {
            return getInputDispatchingTimeoutLocked(r.app);
        }
        return 5000L;
    }

    public static long getInputDispatchingTimeoutLocked(ProcessRecord r) {
        if (r != null) {
            if (r.instr != null || r.usingWrapper) {
                return 60000L;
            }
            return 5000L;
        }
        return 5000L;
    }

    public long inputDispatchingTimedOut(int pid, boolean aboveSystem, String reason) {
        ProcessRecord proc;
        long timeout;
        if (checkCallingPermission("android.permission.FILTER_EVENTS") != 0) {
            throw new SecurityException("Requires permission android.permission.FILTER_EVENTS");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    proc = this.mPidsSelfLocked.get(pid);
                }
                timeout = getInputDispatchingTimeoutLocked(proc);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (inputDispatchingTimedOut(proc, null, null, aboveSystem, reason)) {
            return -1L;
        }
        return timeout;
    }

    public boolean inputDispatchingTimedOut(final ProcessRecord proc, final ActivityRecord activity, final ActivityRecord parent, final boolean aboveSystem, String reason) {
        String annotation;
        if (checkCallingPermission("android.permission.FILTER_EVENTS") != 0) {
            throw new SecurityException("Requires permission android.permission.FILTER_EVENTS");
        }
        if (reason == null) {
            annotation = "Input dispatching timed out";
        } else {
            annotation = "Input dispatching timed out (" + reason + ")";
        }
        final String annotation2 = annotation;
        if (proc != null) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    if (proc.debugging) {
                        resetPriorityAfterLockedSection();
                        return false;
                    } else if (proc.instr != null) {
                        Bundle info = new Bundle();
                        info.putString("shortMsg", "keyDispatchingTimedOut");
                        info.putString("longMsg", annotation2);
                        finishInstrumentationLocked(proc, 0, info);
                        resetPriorityAfterLockedSection();
                        return true;
                    } else {
                        resetPriorityAfterLockedSection();
                        this.mHandler.post(new Runnable() { // from class: com.android.server.am.ActivityManagerService.17
                            @Override // java.lang.Runnable
                            public void run() {
                                ActivityManagerService.this.mAppErrors.appNotResponding(proc, activity, parent, aboveSystem, annotation2);
                            }
                        });
                    }
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
        }
        return true;
    }

    public Bundle getAssistContextExtras(int requestType) {
        PendingAssistExtras pae = enqueueAssistContext(requestType, null, null, null, null, null, true, true, UserHandle.getCallingUserId(), null, 500L, 0);
        if (pae == null) {
            return null;
        }
        synchronized (pae) {
            while (!pae.haveResult) {
                try {
                    pae.wait();
                } catch (InterruptedException e) {
                }
            }
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                buildAssistBundleLocked(pae, pae.result);
                this.mPendingAssistExtras.remove(pae);
                this.mUiHandler.removeCallbacks(pae);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return pae.extras;
    }

    public boolean isAssistDataAllowedOnCurrentActivity() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityStack focusedStack = getFocusedStack();
                if (focusedStack != null && !focusedStack.isActivityTypeAssistant()) {
                    ActivityRecord activity = focusedStack.getTopActivity();
                    if (activity == null) {
                        resetPriorityAfterLockedSection();
                        return false;
                    }
                    int userId = activity.userId;
                    resetPriorityAfterLockedSection();
                    return !DevicePolicyCache.getInstance().getScreenCaptureDisabled(userId);
                }
                resetPriorityAfterLockedSection();
                return false;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public boolean showAssistFromActivity(IBinder token, Bundle args) {
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord caller = ActivityRecord.forTokenLocked(token);
                ActivityRecord top = getFocusedStack().getTopActivity();
                if (top != caller) {
                    Slog.w("ActivityManager", "showAssistFromActivity failed: caller " + caller + " is not current top " + top);
                    resetPriorityAfterLockedSection();
                    return false;
                } else if (top.nowVisible) {
                    resetPriorityAfterLockedSection();
                    return this.mAssistUtils.showSessionForActiveService(args, 8, (IVoiceInteractionSessionShowCallback) null, token);
                } else {
                    Slog.w("ActivityManager", "showAssistFromActivity failed: caller " + caller + " is not visible");
                    resetPriorityAfterLockedSection();
                    return false;
                }
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public boolean requestAssistContextExtras(int requestType, IAssistDataReceiver receiver, Bundle receiverExtras, IBinder activityToken, boolean focused, boolean newSessionId) {
        return enqueueAssistContext(requestType, null, null, receiver, receiverExtras, activityToken, focused, newSessionId, UserHandle.getCallingUserId(), null, 2000L, 0) != null;
    }

    public boolean requestAutofillData(IAssistDataReceiver receiver, Bundle receiverExtras, IBinder activityToken, int flags) {
        return enqueueAssistContext(2, null, null, receiver, receiverExtras, activityToken, true, true, UserHandle.getCallingUserId(), null, 2000L, flags) != null;
    }

    private PendingAssistExtras enqueueAssistContext(int requestType, Intent intent, String hint, IAssistDataReceiver receiver, Bundle receiverExtras, IBinder activityToken, boolean focused, boolean newSessionId, int userHandle, Bundle args, long timeout, int flags) {
        ActivityRecord caller;
        enforceCallingPermission("android.permission.GET_TOP_ACTIVITY_INFO", "enqueueAssistContext()");
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    ActivityRecord activity = getFocusedStack().getTopActivity();
                    if (activity == null) {
                        Slog.w("ActivityManager", "getAssistContextExtras failed: no top activity");
                        resetPriorityAfterLockedSection();
                        return null;
                    }
                    if (activity.app != null && activity.app.thread != null) {
                        if (focused) {
                            if (activityToken != null && activity != (caller = ActivityRecord.forTokenLocked(activityToken))) {
                                Slog.w("ActivityManager", "enqueueAssistContext failed: caller " + caller + " is not current top " + activity);
                                resetPriorityAfterLockedSection();
                                return null;
                            }
                        } else {
                            activity = ActivityRecord.forTokenLocked(activityToken);
                            if (activity == null) {
                                Slog.w("ActivityManager", "enqueueAssistContext failed: activity for token=" + activityToken + " couldn't be found");
                                resetPriorityAfterLockedSection();
                                return null;
                            }
                            if (activity.app != null) {
                                if (activity.app.thread == null) {
                                }
                            }
                            Slog.w("ActivityManager", "enqueueAssistContext failed: no process for " + activity);
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                        ActivityRecord activity2 = activity;
                        Bundle extras = new Bundle();
                        if (args != null) {
                            extras.putAll(args);
                        }
                        extras.putString("android.intent.extra.ASSIST_PACKAGE", activity2.packageName);
                        extras.putInt("android.intent.extra.ASSIST_UID", activity2.app.uid);
                        PendingAssistExtras pae = new PendingAssistExtras(activity2, extras, intent, hint, receiver, receiverExtras, userHandle);
                        pae.isHome = activity2.isActivityTypeHome();
                        if (newSessionId) {
                            this.mViSessionId++;
                        }
                        try {
                            activity2.app.thread.requestAssistContextExtras(activity2.appToken, pae, requestType, this.mViSessionId, flags);
                            this.mPendingAssistExtras.add(pae);
                        } catch (RemoteException e) {
                        }
                        try {
                            this.mUiHandler.postDelayed(pae, timeout);
                            resetPriorityAfterLockedSection();
                            return pae;
                        } catch (RemoteException e2) {
                            Slog.w("ActivityManager", "getAssistContextExtras failed: crash calling " + activity2);
                            resetPriorityAfterLockedSection();
                            return null;
                        }
                    }
                    Slog.w("ActivityManager", "getAssistContextExtras failed: no process for " + activity);
                    resetPriorityAfterLockedSection();
                    return null;
                } catch (Throwable th) {
                    th = th;
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            } catch (Throwable th2) {
                th = th2;
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    void pendingAssistExtrasTimedOut(PendingAssistExtras pae) {
        IAssistDataReceiver receiver;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mPendingAssistExtras.remove(pae);
                receiver = pae.receiver;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (receiver != null) {
            Bundle sendBundle = new Bundle();
            sendBundle.putBundle("receiverExtras", pae.receiverExtras);
            try {
                pae.receiver.onHandleAssistData(sendBundle);
            } catch (RemoteException e) {
            }
        }
    }

    private void buildAssistBundleLocked(PendingAssistExtras pae, Bundle result) {
        if (result != null) {
            pae.extras.putBundle("android.intent.extra.ASSIST_CONTEXT", result);
        }
        if (pae.hint != null) {
            pae.extras.putBoolean(pae.hint, true);
        }
    }

    public void reportAssistContextExtras(IBinder token, Bundle extras, AssistStructure structure, AssistContent content, Uri referrer) {
        PendingAssistExtras pae = (PendingAssistExtras) token;
        synchronized (pae) {
            pae.result = extras;
            pae.structure = structure;
            pae.content = content;
            if (referrer != null) {
                pae.extras.putParcelable("android.intent.extra.REFERRER", referrer);
            }
            if (structure != null) {
                structure.setHomeActivity(pae.isHome);
            }
            pae.haveResult = true;
            pae.notifyAll();
            if (pae.intent == null && pae.receiver == null) {
                return;
            }
            Bundle sendBundle = null;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    buildAssistBundleLocked(pae, extras);
                    boolean exists = this.mPendingAssistExtras.remove(pae);
                    this.mUiHandler.removeCallbacks(pae);
                    if (!exists) {
                        resetPriorityAfterLockedSection();
                        return;
                    }
                    IAssistDataReceiver sendReceiver = pae.receiver;
                    if (sendReceiver != null) {
                        sendBundle = new Bundle();
                        sendBundle.putBundle("data", pae.extras);
                        sendBundle.putParcelable("structure", pae.structure);
                        sendBundle.putParcelable("content", pae.content);
                        sendBundle.putBundle("receiverExtras", pae.receiverExtras);
                    }
                    resetPriorityAfterLockedSection();
                    if (sendReceiver != null) {
                        try {
                            sendReceiver.onHandleAssistData(sendBundle);
                            return;
                        } catch (RemoteException e) {
                            return;
                        }
                    }
                    long ident = Binder.clearCallingIdentity();
                    try {
                        if (TextUtils.equals(pae.intent.getAction(), "android.service.voice.VoiceInteractionService")) {
                            pae.intent.putExtras(pae.extras);
                            this.mContext.startServiceAsUser(pae.intent, new UserHandle(pae.userHandle));
                        } else {
                            pae.intent.replaceExtras(pae.extras);
                            pae.intent.setFlags(872415232);
                            closeSystemDialogs(PhoneWindowManager.SYSTEM_DIALOG_REASON_ASSIST);
                            try {
                                this.mContext.startActivityAsUser(pae.intent, new UserHandle(pae.userHandle));
                            } catch (ActivityNotFoundException e2) {
                                Slog.w("ActivityManager", "No activity to handle assist action.", e2);
                            }
                        }
                    } finally {
                        Binder.restoreCallingIdentity(ident);
                    }
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
        }
    }

    public boolean launchAssistIntent(Intent intent, int requestType, String hint, int userHandle, Bundle args) {
        return enqueueAssistContext(requestType, intent, hint, null, null, null, true, true, userHandle, args, 500L, 0) != null;
    }

    public void registerProcessObserver(IProcessObserver observer) {
        enforceCallingPermission("android.permission.SET_ACTIVITY_WATCHER", "registerProcessObserver()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mProcessObservers.register(observer);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void unregisterProcessObserver(IProcessObserver observer) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mProcessObservers.unregister(observer);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public int getUidProcessState(int uid, String callingPackage) {
        int i;
        if (!hasUsageStatsPermission(callingPackage)) {
            enforceCallingPermission("android.permission.PACKAGE_USAGE_STATS", "getUidProcessState");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord uidRec = this.mActiveUids.get(uid);
                i = uidRec != null ? uidRec.curProcState : 19;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return i;
    }

    public void registerUidObserver(IUidObserver observer, int which, int cutpoint, String callingPackage) {
        if (!hasUsageStatsPermission(callingPackage)) {
            enforceCallingPermission("android.permission.PACKAGE_USAGE_STATS", "registerUidObserver");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mUidObservers.register(observer, new UidObserverRegistration(Binder.getCallingUid(), callingPackage, which, cutpoint));
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void unregisterUidObserver(IUidObserver observer) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mUidObservers.unregister(observer);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean isUidActive(int uid, String callingPackage) {
        boolean isUidActiveLocked;
        if (!hasUsageStatsPermission(callingPackage)) {
            enforceCallingPermission("android.permission.PACKAGE_USAGE_STATS", "isUidActive");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                isUidActiveLocked = isUidActiveLocked(uid);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return isUidActiveLocked;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean isUidActiveLocked(int uid) {
        UidRecord uidRecord = this.mActiveUids.get(uid);
        return (uidRecord == null || uidRecord.setIdle) ? false : true;
    }

    public boolean convertFromTranslucent(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    boolean translucentChanged = r.changeWindowTranslucency(true);
                    if (translucentChanged) {
                        this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                    }
                    this.mWindowManager.setAppFullscreen(token, true);
                    resetPriorityAfterLockedSection();
                    return translucentChanged;
                }
                resetPriorityAfterLockedSection();
                return false;
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean convertToTranslucent(IBinder token, Bundle options) {
        SafeActivityOptions safeOptions = SafeActivityOptions.fromBundle(options);
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r != null) {
                    TaskRecord task = r.getTask();
                    int index = task.mActivities.lastIndexOf(r);
                    if (index > 0) {
                        ActivityRecord under = task.mActivities.get(index - 1);
                        under.returningOptions = safeOptions != null ? safeOptions.getOptions(r) : null;
                    }
                    boolean translucentChanged = r.changeWindowTranslucency(false);
                    if (translucentChanged) {
                        r.getStack().convertActivityToTranslucent(r);
                    }
                    this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                    this.mWindowManager.setAppFullscreen(token, false);
                    resetPriorityAfterLockedSection();
                    return translucentChanged;
                }
                resetPriorityAfterLockedSection();
                return false;
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public Bundle getActivityOptions(IBinder token) {
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                Bundle bundle = null;
                if (r != null) {
                    ActivityOptions activityOptions = r.takeOptionsLocked();
                    if (activityOptions != null) {
                        bundle = activityOptions.toBundle();
                    }
                    resetPriorityAfterLockedSection();
                    return bundle;
                }
                resetPriorityAfterLockedSection();
                return null;
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public void setImmersive(IBinder token, boolean immersive) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException();
                }
                r.immersive = immersive;
                if (r == this.mStackSupervisor.getResumedActivityLocked()) {
                    if (ActivityManagerDebugConfig.DEBUG_IMMERSIVE) {
                        Slog.d("ActivityManager", "Frontmost changed immersion: " + r);
                    }
                    applyUpdateLockStateLocked(r);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean isImmersive(IBinder token) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException();
                }
                z = r.immersive;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return z;
    }

    public void setVrThread(int tid) {
        enforceSystemHasVrFeature();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    int pid = Binder.getCallingPid();
                    ProcessRecord proc = this.mPidsSelfLocked.get(pid);
                    this.mVrController.setVrThreadLocked(tid, pid, proc);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void setPersistentVrThread(int tid) {
        if (checkCallingPermission("android.permission.RESTRICTED_VR_ACCESS") != 0) {
            String msg = "Permission Denial: setPersistentVrThread() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.RESTRICTED_VR_ACCESS";
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        enforceSystemHasVrFeature();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    int pid = Binder.getCallingPid();
                    ProcessRecord proc = this.mPidsSelfLocked.get(pid);
                    this.mVrController.setPersistentVrThreadLocked(tid, pid, proc);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public static boolean scheduleAsRegularPriority(int tid, boolean suppressLogs) {
        try {
            Process.setThreadScheduler(tid, 0, 0);
            return true;
        } catch (IllegalArgumentException e) {
            if (!suppressLogs) {
                Slog.w("ActivityManager", "Failed to set scheduling policy, thread does not exist:\n" + e);
            }
            return false;
        } catch (SecurityException e2) {
            if (!suppressLogs) {
                Slog.w("ActivityManager", "Failed to set scheduling policy, not allowed:\n" + e2);
            }
            return false;
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public static boolean scheduleAsFifoPriority(int tid, boolean suppressLogs) {
        try {
            Process.setThreadScheduler(tid, WindowManagerPolicy.COLOR_FADE_LAYER, 1);
            return true;
        } catch (IllegalArgumentException e) {
            if (!suppressLogs) {
                Slog.w("ActivityManager", "Failed to set scheduling policy, thread does not exist:\n" + e);
                return false;
            }
            return false;
        } catch (SecurityException e2) {
            if (!suppressLogs) {
                Slog.w("ActivityManager", "Failed to set scheduling policy, not allowed:\n" + e2);
                return false;
            }
            return false;
        }
    }

    private void enforceSystemHasVrFeature() {
        if (!this.mContext.getPackageManager().hasSystemFeature("android.hardware.vr.high_performance")) {
            throw new UnsupportedOperationException("VR mode not supported on this device!");
        }
    }

    public void setRenderThread(int tid) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int pid = Binder.getCallingPid();
                if (pid == Process.myPid()) {
                    demoteSystemServerRenderThread(tid);
                    resetPriorityAfterLockedSection();
                    return;
                }
                synchronized (this.mPidsSelfLocked) {
                    ProcessRecord proc = this.mPidsSelfLocked.get(pid);
                    if (proc != null && proc.renderThreadTid == 0 && tid > 0) {
                        if (!Process.isThreadInProcess(pid, tid)) {
                            throw new IllegalArgumentException("Render thread does not belong to process");
                        }
                        proc.renderThreadTid = tid;
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                            Slog.d("UI_FIFO", "Set RenderThread tid " + tid + " for pid " + pid);
                        }
                        if (proc.curSchedGroup == 3) {
                            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.d("UI_FIFO", "Promoting " + tid + "out of band");
                            }
                            if (this.mUseFifoUiScheduling) {
                                Process.setThreadScheduler(proc.renderThreadTid, WindowManagerPolicy.COLOR_FADE_LAYER, 1);
                            } else {
                                Process.setThreadPriority(proc.renderThreadTid, -10);
                            }
                        }
                    } else if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                        Slog.d("UI_FIFO", "Didn't set thread from setRenderThread? PID: " + pid + ", TID: " + tid + " FIFO: " + this.mUseFifoUiScheduling);
                    }
                }
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    private void demoteSystemServerRenderThread(int tid) {
        Process.setThreadPriority(tid, 10);
    }

    public int setVrMode(IBinder token, boolean enabled, ComponentName packageName) {
        ActivityRecord r;
        enforceSystemHasVrFeature();
        VrManagerInternal vrService = (VrManagerInternal) LocalServices.getService(VrManagerInternal.class);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                r = ActivityRecord.isInStackLocked(token);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (r == null) {
            throw new IllegalArgumentException();
        }
        int err = vrService.hasVrPackage(packageName, r.userId);
        if (err != 0) {
            return err;
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                r.requestedVrComponent = enabled ? packageName : null;
                if (r == this.mStackSupervisor.getResumedActivityLocked()) {
                    applyUpdateVrModeLocked(r);
                }
            }
            resetPriorityAfterLockedSection();
            return 0;
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public boolean isVrModePackageEnabled(ComponentName packageName) {
        enforceSystemHasVrFeature();
        VrManagerInternal vrService = (VrManagerInternal) LocalServices.getService(VrManagerInternal.class);
        return vrService.hasVrPackage(packageName, UserHandle.getCallingUserId()) == 0;
    }

    public boolean isTopActivityImmersive() {
        boolean z;
        enforceNotIsolatedCaller("startActivity");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = getFocusedStack().topRunningActivityLocked();
                z = r != null ? r.immersive : false;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return z;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean shouldDisableNonVrUiLocked() {
        return this.mVrController.shouldDisableNonVrUiLocked();
    }

    public boolean isTopOfTask(IBinder token) {
        boolean z;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    throw new IllegalArgumentException();
                }
                z = r.getTask().getTopActivity() == r;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return z;
    }

    public void setHasTopUi(boolean hasTopUi) throws RemoteException {
        if (checkCallingPermission("android.permission.INTERNAL_SYSTEM_WINDOW") != 0) {
            String msg = "Permission Denial: setHasTopUi() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.INTERNAL_SYSTEM_WINDOW";
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        int pid = Binder.getCallingPid();
        long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                boolean changed = false;
                synchronized (this.mPidsSelfLocked) {
                    ProcessRecord pr = this.mPidsSelfLocked.get(pid);
                    if (pr == null) {
                        Slog.w("ActivityManager", "setHasTopUi called on unknown pid: " + pid);
                        resetPriorityAfterLockedSection();
                        return;
                    }
                    if (pr.hasTopUi != hasTopUi) {
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                            Slog.d("ActivityManager", "Setting hasTopUi=" + hasTopUi + " for pid=" + pid);
                        }
                        pr.hasTopUi = hasTopUi;
                        changed = true;
                    }
                    if (changed) {
                        updateOomAdjLocked(pr, true);
                    }
                    resetPriorityAfterLockedSection();
                }
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void setRunningRemoteAnimation(int pid, boolean runningRemoteAnimation) {
        if (pid == Process.myPid()) {
            Slog.wtf("ActivityManager", "system can't run remote animation");
            return;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    ProcessRecord pr = this.mPidsSelfLocked.get(pid);
                    if (pr == null) {
                        Slog.w("ActivityManager", "setRunningRemoteAnimation called on unknown pid: " + pid);
                        resetPriorityAfterLockedSection();
                    } else if (pr.runningRemoteAnimation == runningRemoteAnimation) {
                        resetPriorityAfterLockedSection();
                    } else {
                        pr.runningRemoteAnimation = runningRemoteAnimation;
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                            Slog.i("ActivityManager", "Setting runningRemoteAnimation=" + pr.runningRemoteAnimation + " for pid=" + pid);
                        }
                        updateOomAdjLocked(pr, true);
                        resetPriorityAfterLockedSection();
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public final void enterSafeMode() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!this.mSystemReady) {
                    try {
                        AppGlobals.getPackageManager().enterSafeMode();
                    } catch (RemoteException e) {
                    }
                }
                this.mSafeMode = true;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public final void showSafeModeOverlay() {
        View v = LayoutInflater.from(this.mContext).inflate(17367256, (ViewGroup) null);
        WindowManager.LayoutParams lp = new WindowManager.LayoutParams();
        lp.type = 2015;
        lp.width = -2;
        lp.height = -2;
        lp.gravity = 8388691;
        lp.format = v.getBackground().getOpacity();
        lp.flags = 24;
        lp.privateFlags |= 16;
        ((WindowManager) this.mContext.getSystemService("window")).addView(v, lp);
    }

    public void noteWakeupAlarm(IIntentSender sender, WorkSource workSource, int sourceUid, String sourcePkg, String tag) {
        if (workSource != null && workSource.isEmpty()) {
            workSource = null;
        }
        if (sourceUid <= 0 && workSource == null) {
            if (sender == null || !(sender instanceof PendingIntentRecord)) {
                return;
            }
            PendingIntentRecord rec = (PendingIntentRecord) sender;
            int callerUid = Binder.getCallingUid();
            sourceUid = rec.uid == callerUid ? 1000 : rec.uid;
        }
        if (ActivityManagerDebugConfig.DEBUG_POWER) {
            Slog.w("ActivityManager", "noteWakupAlarm[ sourcePkg=" + sourcePkg + ", sourceUid=" + sourceUid + ", workSource=" + workSource + ", tag=" + tag + "]");
        }
        this.mBatteryStatsService.noteWakupAlarm(sourcePkg, sourceUid, workSource, tag);
    }

    public void noteAlarmStart(IIntentSender sender, WorkSource workSource, int sourceUid, String tag) {
        if (workSource != null && workSource.isEmpty()) {
            workSource = null;
        }
        if (sourceUid <= 0 && workSource == null) {
            if (sender == null || !(sender instanceof PendingIntentRecord)) {
                return;
            }
            PendingIntentRecord rec = (PendingIntentRecord) sender;
            int callerUid = Binder.getCallingUid();
            sourceUid = rec.uid == callerUid ? 1000 : rec.uid;
        }
        if (ActivityManagerDebugConfig.DEBUG_POWER) {
            Slog.w("ActivityManager", "noteAlarmStart[sourceUid=" + sourceUid + ", workSource=" + workSource + ", tag=" + tag + "]");
        }
        this.mBatteryStatsService.noteAlarmStart(tag, workSource, sourceUid);
    }

    public void noteAlarmFinish(IIntentSender sender, WorkSource workSource, int sourceUid, String tag) {
        if (workSource != null && workSource.isEmpty()) {
            workSource = null;
        }
        if (sourceUid <= 0 && workSource == null) {
            if (sender == null || !(sender instanceof PendingIntentRecord)) {
                return;
            }
            PendingIntentRecord rec = (PendingIntentRecord) sender;
            int callerUid = Binder.getCallingUid();
            sourceUid = rec.uid == callerUid ? 1000 : rec.uid;
        }
        if (ActivityManagerDebugConfig.DEBUG_POWER) {
            Slog.w("ActivityManager", "noteAlarmFinish[sourceUid=" + sourceUid + ", workSource=" + workSource + ", tag=" + tag + "]");
        }
        this.mBatteryStatsService.noteAlarmFinish(tag, workSource, sourceUid);
    }

    public boolean killPids(int[] pids, String pReason, boolean secure) {
        int type;
        if (Binder.getCallingUid() == 1000) {
            String reason = pReason == null ? "Unknown" : pReason;
            boolean killed = false;
            synchronized (this.mPidsSelfLocked) {
                int i = 0;
                int worstType = 0;
                for (int i2 : pids) {
                    ProcessRecord proc = this.mPidsSelfLocked.get(i2);
                    if (proc != null && (type = proc.setAdj) > worstType) {
                        worstType = type;
                    }
                }
                if (worstType < 906 && worstType > 900) {
                    worstType = 900;
                }
                if (!secure && worstType < 500) {
                    worstType = 500;
                }
                Slog.w("ActivityManager", "Killing processes " + reason + " at adjustment " + worstType);
                while (true) {
                    int i3 = i;
                    int i4 = pids.length;
                    if (i3 < i4) {
                        ProcessRecord proc2 = this.mPidsSelfLocked.get(pids[i3]);
                        if (proc2 != null) {
                            int adj = proc2.setAdj;
                            if (adj >= worstType && !proc2.killedByAm) {
                                proc2.kill(reason, true);
                                killed = true;
                            }
                        }
                        i = i3 + 1;
                    }
                }
            }
            return killed;
        }
        throw new SecurityException("killPids only available to the system");
    }

    public void killUid(int appId, int userId, String reason) {
        String str;
        enforceCallingPermission("android.permission.KILL_UID", "killUid");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long identity = Binder.clearCallingIdentity();
                if (reason != null) {
                    str = reason;
                } else {
                    str = "kill uid";
                }
                killPackageProcessesLocked(null, appId, userId, -800, false, true, true, true, str);
                Binder.restoreCallingIdentity(identity);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean killProcessesBelowForeground(String reason) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("killProcessesBelowForeground() only available to system");
        }
        return killProcessesBelowAdj(0, reason);
    }

    private boolean killProcessesBelowAdj(int belowAdj, String reason) {
        if (Binder.getCallingUid() != 1000) {
            throw new SecurityException("killProcessesBelowAdj() only available to system");
        }
        boolean killed = false;
        synchronized (this.mPidsSelfLocked) {
            int size = this.mPidsSelfLocked.size();
            for (int i = 0; i < size; i++) {
                this.mPidsSelfLocked.keyAt(i);
                ProcessRecord proc = this.mPidsSelfLocked.valueAt(i);
                if (proc != null) {
                    int adj = proc.setAdj;
                    if (adj > belowAdj && !proc.killedByAm) {
                        proc.kill(reason, true);
                        killed = true;
                    }
                }
            }
        }
        return killed;
    }

    public void hang(IBinder who, boolean allowRestart) {
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        IBinder.DeathRecipient death = new IBinder.DeathRecipient() { // from class: com.android.server.am.ActivityManagerService.18
            @Override // android.os.IBinder.DeathRecipient
            public void binderDied() {
                synchronized (this) {
                    notifyAll();
                }
            }
        };
        try {
            who.linkToDeath(death, 0);
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    Watchdog.getInstance().setAllowRestart(allowRestart);
                    Slog.i("ActivityManager", "Hanging system process at request of pid " + Binder.getCallingPid());
                    synchronized (death) {
                        while (who.isBinderAlive()) {
                            try {
                                death.wait();
                            } catch (InterruptedException e) {
                            }
                        }
                    }
                    Watchdog.getInstance().setAllowRestart(true);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            resetPriorityAfterLockedSection();
        } catch (RemoteException e2) {
            Slog.w("ActivityManager", "hang: given caller IBinder is already dead.");
        }
    }

    public void restart() {
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        Log.i("ActivityManager", "Sending shutdown broadcast...");
        BroadcastReceiver br = new BroadcastReceiver() { // from class: com.android.server.am.ActivityManagerService.19
            @Override // android.content.BroadcastReceiver
            public void onReceive(Context context, Intent intent) {
                Log.i("ActivityManager", "Shutting down activity manager...");
                ActivityManagerService.this.shutdown(10000);
                Log.i("ActivityManager", "Shutdown complete, restarting!");
                Process.killProcess(Process.myPid());
                System.exit(10);
            }
        };
        Intent intent = new Intent("android.intent.action.ACTION_SHUTDOWN");
        intent.addFlags(268435456);
        intent.putExtra("android.intent.extra.SHUTDOWN_USERSPACE_ONLY", true);
        br.onReceive(this.mContext, intent);
    }

    private long getLowRamTimeSinceIdle(long now) {
        return this.mLowRamTimeSinceLastIdle + (this.mLowRamStartTime > 0 ? now - this.mLowRamStartTime : 0L);
    }

    public void performIdleMaintenance() {
        boolean z;
        int i;
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long now = SystemClock.uptimeMillis();
                long timeSinceLastIdle = now - this.mLastIdleTime;
                long lowRamSinceLastIdle = getLowRamTimeSinceIdle(now);
                this.mLastIdleTime = now;
                long j = 0;
                this.mLowRamTimeSinceLastIdle = 0L;
                if (this.mLowRamStartTime != 0) {
                    this.mLowRamStartTime = now;
                }
                StringBuilder sb = new StringBuilder(128);
                sb.append("Idle maintenance over ");
                TimeUtils.formatDuration(timeSinceLastIdle, sb);
                sb.append(" low RAM for ");
                TimeUtils.formatDuration(lowRamSinceLastIdle, sb);
                Slog.i("ActivityManager", sb.toString());
                boolean z2 = true;
                boolean z3 = lowRamSinceLastIdle > timeSinceLastIdle / 3;
                int i2 = this.mLruProcesses.size() - 1;
                while (true) {
                    int i3 = i2;
                    if (i3 >= 0) {
                        ProcessRecord proc = this.mLruProcesses.get(i3);
                        if (proc.notCachedSinceIdle) {
                            z = z2;
                            i = i3;
                        } else if (proc.setProcState >= 13 || proc.setProcState < 0) {
                            z = z2;
                            i = i3;
                        } else {
                            proc.notCachedSinceIdle = z2;
                            proc.initialIdlePss = j;
                            z = z2;
                            i = i3;
                            proc.nextPssTime = ProcessList.computeNextPssTime(proc.setProcState, null, this.mTestPssMode, isSleepingLocked(), now);
                        }
                        i2 = i - 1;
                        z2 = z;
                        j = 0;
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void sendIdleJobTrigger() {
        long ident;
        Intent intent;
        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
        }
        long ident2 = Binder.clearCallingIdentity();
        try {
            intent = new Intent(ACTION_TRIGGER_IDLE).setPackage(PackageManagerService.PLATFORM_PACKAGE_NAME).addFlags(1073741824);
        } catch (Throwable th) {
            th = th;
            ident = ident2;
        }
        try {
            broadcastIntent(null, intent, null, null, 0, null, null, null, -1, null, false, false, -1);
            Binder.restoreCallingIdentity(ident2);
        } catch (Throwable th2) {
            th = th2;
            ident = ident2;
            Binder.restoreCallingIdentity(ident);
            throw th;
        }
    }

    /*  JADX ERROR: JadxRuntimeException in pass: BlockProcessor
        jadx.core.utils.exceptions.JadxRuntimeException: Unreachable block: B:78:0x0156
        	at jadx.core.dex.visitors.blocks.BlockProcessor.checkForUnreachableBlocks(BlockProcessor.java:81)
        	at jadx.core.dex.visitors.blocks.BlockProcessor.processBlocksTree(BlockProcessor.java:47)
        	at jadx.core.dex.visitors.blocks.BlockProcessor.visit(BlockProcessor.java:39)
        */
    private void retrieveSettings() {
        /*
            Method dump skipped, instructions count: 486
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.retrieveSettings():void");
    }

    /*  JADX ERROR: JadxRuntimeException in pass: BlockProcessor
        jadx.core.utils.exceptions.JadxRuntimeException: Found unreachable blocks
        	at jadx.core.dex.visitors.blocks.DominatorTree.sortBlocks(DominatorTree.java:35)
        	at jadx.core.dex.visitors.blocks.DominatorTree.compute(DominatorTree.java:25)
        	at jadx.core.dex.visitors.blocks.BlockProcessor.computeDominators(BlockProcessor.java:202)
        	at jadx.core.dex.visitors.blocks.BlockProcessor.processBlocksTree(BlockProcessor.java:45)
        	at jadx.core.dex.visitors.blocks.BlockProcessor.visit(BlockProcessor.java:39)
        */
    public void systemReady(java.lang.Runnable r31, android.util.TimingsTraceLog r32) {
        /*
            Method dump skipped, instructions count: 1010
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.systemReady(java.lang.Runnable, android.util.TimingsTraceLog):void");
    }

    /* JADX INFO: Access modifiers changed from: private */
    public void updateForceBackgroundCheck(boolean enabled) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mForceBackgroundCheck != enabled) {
                    this.mForceBackgroundCheck = enabled;
                    if (ActivityManagerDebugConfig.DEBUG_BACKGROUND_CHECK) {
                        StringBuilder sb = new StringBuilder();
                        sb.append("Force background check ");
                        sb.append(enabled ? "enabled" : "disabled");
                        Slog.i("ActivityManager", sb.toString());
                    }
                    if (this.mForceBackgroundCheck) {
                        doStopUidForIdleUidsLocked();
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void killAppAtUsersRequest(ProcessRecord app, Dialog fromDialog) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mAppErrors.killAppAtUserRequestLocked(app, fromDialog);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void skipCurrentReceiverLocked(ProcessRecord app) {
        BroadcastQueue[] broadcastQueueArr;
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            queue.skipCurrentReceiverLocked(app);
        }
    }

    public void handleApplicationCrash(IBinder app, ApplicationErrorReport.ParcelableCrashInfo crashInfo) {
        String processName;
        ProcessRecord r = findAppProcess(app, "Crash");
        if (app == null) {
            processName = "system_server";
        } else {
            processName = r == null ? UiModeManagerService.Shell.NIGHT_MODE_STR_UNKNOWN : r.processName;
        }
        handleApplicationCrashInner("crash", r, processName, crashInfo);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, ApplicationErrorReport.CrashInfo crashInfo) {
        Object[] objArr = new Object[8];
        objArr[0] = Integer.valueOf(Binder.getCallingPid());
        objArr[1] = Integer.valueOf(UserHandle.getUserId(Binder.getCallingUid()));
        objArr[2] = processName;
        objArr[3] = Integer.valueOf(r == null ? -1 : r.info.flags);
        objArr[4] = crashInfo.exceptionClassName;
        objArr[5] = crashInfo.exceptionMessage;
        objArr[6] = crashInfo.throwFileName;
        objArr[7] = Integer.valueOf(crashInfo.throwLineNumber);
        EventLog.writeEvent((int) EventLogTags.AM_CRASH, objArr);
        StatsLog.write(78, Binder.getCallingUid(), eventType, processName, Binder.getCallingPid(), (r == null || r.info == null) ? BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS : r.info.packageName, (r == null || r.info == null) ? 0 : r.info.isInstantApp() ? 2 : 1, r != null ? r.isInterestingToUserLocked() ? 2 : 1 : 0);
        long time = System.currentTimeMillis();
        StringBuilder builder = new StringBuilder();
        builder.append("xiaopengbughunter_");
        builder.append(processName);
        builder.append("_");
        builder.append(eventType);
        builder.append("_" + time);
        addErrorToDropBox(builder.toString(), r, processName, null, null, null, null, null, crashInfo);
        this.mAppErrors.crashApplication(r, crashInfo, time);
    }

    public void handleApplicationStrictModeViolation(IBinder app, int violationMask, StrictMode.ViolationInfo info) {
        ProcessRecord r = findAppProcess(app, "StrictMode");
        if ((2097152 & violationMask) != 0) {
            Integer stackFingerprint = Integer.valueOf(info.hashCode());
            boolean logIt = true;
            synchronized (this.mAlreadyLoggedViolatedStacks) {
                if (this.mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
                    logIt = false;
                } else {
                    if (this.mAlreadyLoggedViolatedStacks.size() >= 5000) {
                        this.mAlreadyLoggedViolatedStacks.clear();
                    }
                    this.mAlreadyLoggedViolatedStacks.add(stackFingerprint);
                }
            }
            if (logIt) {
                logStrictModeViolationToDropBox(r, info);
            }
        }
        if ((131072 & violationMask) != 0) {
            AppErrorResult result = new AppErrorResult();
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    long origId = Binder.clearCallingIdentity();
                    Message msg = Message.obtain();
                    msg.what = 26;
                    HashMap<String, Object> data = new HashMap<>();
                    data.put("result", result);
                    data.put("app", r);
                    data.put("violationMask", Integer.valueOf(violationMask));
                    data.put("info", info);
                    msg.obj = data;
                    this.mUiHandler.sendMessage(msg);
                    Binder.restoreCallingIdentity(origId);
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            resetPriorityAfterLockedSection();
            int res = result.get();
            Slog.w("ActivityManager", "handleApplicationStrictModeViolation; res=" + res);
        }
    }

    private void logStrictModeViolationToDropBox(ProcessRecord process, StrictMode.ViolationInfo info) {
        String[] strArr;
        if (info == null) {
            return;
        }
        boolean isSystemApp = process == null || (process.info.flags & NetworkConstants.ICMPV6_ECHO_REPLY_TYPE) != 0;
        String processName = process == null ? UiModeManagerService.Shell.NIGHT_MODE_STR_UNKNOWN : process.processName;
        final DropBoxManager dbox = (DropBoxManager) this.mContext.getSystemService("dropbox");
        final String dropboxTag = processClass(process) + "_strictmode";
        if (dbox == null || !dbox.isTagEnabled(dropboxTag)) {
            return;
        }
        StringBuilder sb = new StringBuilder(1024);
        synchronized (sb) {
            appendDropBoxProcessHeaders(process, processName, sb);
            sb.append("Build: ");
            sb.append(Build.FINGERPRINT);
            sb.append("\n");
            sb.append("System-App: ");
            sb.append(isSystemApp);
            sb.append("\n");
            sb.append("Uptime-Millis: ");
            sb.append(info.violationUptimeMillis);
            sb.append("\n");
            if (info.violationNumThisLoop != 0) {
                sb.append("Loop-Violation-Number: ");
                sb.append(info.violationNumThisLoop);
                sb.append("\n");
            }
            if (info.numAnimationsRunning != 0) {
                sb.append("Animations-Running: ");
                sb.append(info.numAnimationsRunning);
                sb.append("\n");
            }
            if (info.broadcastIntentAction != null) {
                sb.append("Broadcast-Intent-Action: ");
                sb.append(info.broadcastIntentAction);
                sb.append("\n");
            }
            if (info.durationMillis != -1) {
                sb.append("Duration-Millis: ");
                sb.append(info.durationMillis);
                sb.append("\n");
            }
            if (info.numInstances != -1) {
                sb.append("Instance-Count: ");
                sb.append(info.numInstances);
                sb.append("\n");
            }
            if (info.tags != null) {
                for (String tag : info.tags) {
                    sb.append("Span-Tag: ");
                    sb.append(tag);
                    sb.append("\n");
                }
            }
            sb.append("\n");
            sb.append(info.getStackTrace());
            sb.append("\n");
            if (info.getViolationDetails() != null) {
                sb.append(info.getViolationDetails());
                sb.append("\n");
            }
        }
        final String res = sb.toString();
        IoThread.getHandler().post(new Runnable() { // from class: com.android.server.am.-$$Lambda$ActivityManagerService$w5jCshLsk1jfv4UDTmEfq_HU0OQ
            @Override // java.lang.Runnable
            public final void run() {
                dbox.addText(dropboxTag, res);
            }
        });
    }

    public boolean handleApplicationWtf(final IBinder app, final String tag, boolean system, final ApplicationErrorReport.ParcelableCrashInfo crashInfo) {
        final int callingUid = Binder.getCallingUid();
        final int callingPid = Binder.getCallingPid();
        if (system) {
            this.mHandler.post(new Runnable() { // from class: com.android.server.am.ActivityManagerService.22
                @Override // java.lang.Runnable
                public void run() {
                    ActivityManagerService.this.handleApplicationWtfInner(callingUid, callingPid, app, tag, crashInfo);
                }
            });
            return false;
        }
        ProcessRecord r = handleApplicationWtfInner(callingUid, callingPid, app, tag, crashInfo);
        boolean isFatal = Build.IS_ENG || Settings.Global.getInt(this.mContext.getContentResolver(), "wtf_is_fatal", 0) != 0;
        boolean isSystem = r == null || r.persistent;
        if (!isFatal || isSystem) {
            return false;
        }
        this.mAppErrors.crashApplication(r, crashInfo, 0L);
        return true;
    }

    ProcessRecord handleApplicationWtfInner(int callingUid, int callingPid, IBinder app, String tag, ApplicationErrorReport.CrashInfo crashInfo) {
        String str;
        ProcessRecord r = findAppProcess(app, "WTF");
        if (app == null) {
            str = "system_server";
        } else {
            str = r == null ? UiModeManagerService.Shell.NIGHT_MODE_STR_UNKNOWN : r.processName;
        }
        String processName = str;
        Object[] objArr = new Object[6];
        objArr[0] = Integer.valueOf(UserHandle.getUserId(callingUid));
        objArr[1] = Integer.valueOf(callingPid);
        objArr[2] = processName;
        objArr[3] = Integer.valueOf(r == null ? -1 : r.info.flags);
        objArr[4] = tag;
        objArr[5] = crashInfo.exceptionMessage;
        EventLog.writeEvent((int) EventLogTags.AM_WTF, objArr);
        StatsLog.write(80, callingUid, tag, processName, callingPid);
        addErrorToDropBox("wtf", r, processName, null, null, tag, null, null, crashInfo);
        return r;
    }

    private ProcessRecord findAppProcess(IBinder app, String reason) {
        if (app == null) {
            return null;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int NP = this.mProcessNames.getMap().size();
                for (int ip = 0; ip < NP; ip++) {
                    SparseArray<ProcessRecord> apps = (SparseArray) this.mProcessNames.getMap().valueAt(ip);
                    int NA = apps.size();
                    for (int ia = 0; ia < NA; ia++) {
                        ProcessRecord p = apps.valueAt(ia);
                        if (p.thread != null && p.thread.asBinder() == app) {
                            resetPriorityAfterLockedSection();
                            return p;
                        }
                    }
                }
                Slog.w("ActivityManager", "Can't find mystery application for " + reason + " from pid=" + Binder.getCallingPid() + " uid=" + Binder.getCallingUid() + ": " + app);
                resetPriorityAfterLockedSection();
                return null;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    private void appendDropBoxProcessHeaders(ProcessRecord process, String processName, StringBuilder sb) {
        if (process == null) {
            sb.append("Process: ");
            sb.append(processName);
            sb.append("\n");
            return;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                sb.append("Process: ");
                sb.append(processName);
                sb.append("\n");
                sb.append("PID: ");
                sb.append(process.pid);
                sb.append("\n");
                int flags = process.info.flags;
                IPackageManager pm = AppGlobals.getPackageManager();
                sb.append("Flags: 0x");
                sb.append(Integer.toHexString(flags));
                sb.append("\n");
                for (int ip = 0; ip < process.pkgList.size(); ip++) {
                    String pkg = process.pkgList.keyAt(ip);
                    sb.append("Package: ");
                    sb.append(pkg);
                    try {
                        PackageInfo pi = pm.getPackageInfo(pkg, 0, UserHandle.getCallingUserId());
                        if (pi != null) {
                            sb.append(" v");
                            sb.append(pi.getLongVersionCode());
                            if (pi.versionName != null) {
                                sb.append(" (");
                                sb.append(pi.versionName);
                                sb.append(")");
                            }
                        }
                    } catch (RemoteException e) {
                        Slog.e("ActivityManager", "Error getting package info: " + pkg, e);
                    }
                    sb.append("\n");
                }
                if (process.info.isInstantApp()) {
                    sb.append("Instant-App: true\n");
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    private static String processClass(ProcessRecord process) {
        if (process == null || process.pid == MY_PID) {
            return "system_server";
        }
        return "app";
    }

    public void addErrorToDropBox(String eventType, ProcessRecord process, String processName, ActivityRecord activity, ActivityRecord parent, String subject, final String report, final File dataFile, final ApplicationErrorReport.CrashInfo crashInfo) {
        if (ServiceManager.getService("dropbox") == null) {
            return;
        }
        final DropBoxManager dbox = (DropBoxManager) this.mContext.getSystemService(DropBoxManager.class);
        final String dropboxTag = processClass(process) + "_" + eventType;
        if (dbox != null && dbox.isTagEnabled(dropboxTag)) {
            long now = SystemClock.elapsedRealtime();
            if (now - this.mWtfClusterStart > JobStatus.DEFAULT_TRIGGER_UPDATE_DELAY) {
                this.mWtfClusterStart = now;
                this.mWtfClusterCount = 1;
            } else {
                int i = this.mWtfClusterCount;
                this.mWtfClusterCount = i + 1;
                if (i >= 5) {
                    return;
                }
            }
            final StringBuilder sb = new StringBuilder(1024);
            appendDropBoxProcessHeaders(process, processName, sb);
            if (process != null) {
                sb.append("Foreground: ");
                sb.append(process.isInterestingToUserLocked() ? "Yes" : "No");
                sb.append("\n");
            }
            if (activity != null) {
                sb.append("Activity: ");
                sb.append(activity.shortComponentName);
                sb.append("\n");
            }
            if (parent != null && parent.app != null && parent.app.pid != process.pid) {
                sb.append("Parent-Process: ");
                sb.append(parent.app.processName);
                sb.append("\n");
            }
            if (parent != null && parent != activity) {
                sb.append("Parent-Activity: ");
                sb.append(parent.shortComponentName);
                sb.append("\n");
            }
            if (subject != null) {
                sb.append("Subject: ");
                sb.append(subject);
                sb.append("\n");
            }
            sb.append("Build: ");
            sb.append(Build.FINGERPRINT);
            sb.append("\n");
            if (Debug.isDebuggerConnected()) {
                sb.append("Debugger: Connected\n");
            }
            sb.append("\n");
            Thread worker = new Thread("Error dump: " + dropboxTag) { // from class: com.android.server.am.ActivityManagerService.23
                /* JADX WARN: Code restructure failed: missing block: B:39:0x0132, code lost:
                    if (r4 == null) goto L50;
                 */
                @Override // java.lang.Thread, java.lang.Runnable
                /*
                    Code decompiled incorrectly, please refer to instructions dump.
                    To view partially-correct add '--show-bad-code' argument
                */
                public void run() {
                    /*
                        Method dump skipped, instructions count: 331
                        To view this dump add '--comments-level debug' option
                    */
                    throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.AnonymousClass23.run():void");
                }
            };
            if (process == null) {
                int oldMask = StrictMode.allowThreadDiskWritesMask();
                try {
                    worker.run();
                    return;
                } finally {
                    StrictMode.setThreadPolicyMask(oldMask);
                }
            }
            worker.start();
        }
    }

    public List<ActivityManager.ProcessErrorStateInfo> getProcessesInErrorState() {
        enforceNotIsolatedCaller("getProcessesInErrorState");
        List<ActivityManager.ProcessErrorStateInfo> errList = null;
        boolean allUsers = ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", Binder.getCallingUid()) == 0;
        int userId = UserHandle.getUserId(Binder.getCallingUid());
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord app = this.mLruProcesses.get(i);
                    if ((allUsers || app.userId == userId) && app.thread != null && (app.crashing || app.notResponding)) {
                        ActivityManager.ProcessErrorStateInfo report = null;
                        if (app.crashing) {
                            report = app.crashingReport;
                        } else if (app.notResponding) {
                            report = app.notRespondingReport;
                        }
                        if (report != null) {
                            if (errList == null) {
                                errList = new ArrayList<>(1);
                            }
                            errList.add(report);
                        } else {
                            Slog.w("ActivityManager", "Missing app error report, app = " + app.processName + " crashing = " + app.crashing + " notResponding = " + app.notResponding);
                        }
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return errList;
    }

    static int procStateToImportance(int procState, int memAdj, ActivityManager.RunningAppProcessInfo currApp, int clientTargetSdk) {
        int imp = ActivityManager.RunningAppProcessInfo.procStateToImportanceForTargetSdk(procState, clientTargetSdk);
        if (imp == 400) {
            currApp.lru = memAdj;
        } else {
            currApp.lru = 0;
        }
        return imp;
    }

    private void fillInProcMemInfo(ProcessRecord app, ActivityManager.RunningAppProcessInfo outInfo, int clientTargetSdk) {
        outInfo.pid = app.pid;
        outInfo.uid = app.info.uid;
        if (this.mHeavyWeightProcess == app) {
            outInfo.flags |= 1;
        }
        if (app.persistent) {
            outInfo.flags |= 2;
        }
        if (app.activities.size() > 0) {
            outInfo.flags |= 4;
        }
        outInfo.lastTrimLevel = app.trimMemoryLevel;
        int adj = app.curAdj;
        int procState = app.curProcState;
        outInfo.importance = procStateToImportance(procState, adj, outInfo, clientTargetSdk);
        outInfo.importanceReasonCode = app.adjTypeCode;
        outInfo.processState = app.curProcState;
    }

    public List<ActivityManager.RunningAppProcessInfo> getRunningAppProcesses() {
        enforceNotIsolatedCaller("getRunningAppProcesses");
        int callingUid = Binder.getCallingUid();
        int clientTargetSdk = this.mPackageManagerInt.getUidTargetSdkVersion(callingUid);
        List<ActivityManager.RunningAppProcessInfo> runList = null;
        boolean allUsers = ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", callingUid) == 0;
        int userId = UserHandle.getUserId(callingUid);
        boolean allUids = isGetTasksAllowed("getRunningAppProcesses", Binder.getCallingPid(), callingUid);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int i = this.mLruProcesses.size() - 1;
                while (true) {
                    int i2 = i;
                    if (i2 >= 0) {
                        ProcessRecord app = this.mLruProcesses.get(i2);
                        if ((allUsers || app.userId == userId) && ((allUids || app.uid == callingUid) && app.thread != null && !app.crashing && !app.notResponding)) {
                            ActivityManager.RunningAppProcessInfo currApp = new ActivityManager.RunningAppProcessInfo(app.processName, app.pid, app.getPackageList());
                            fillInProcMemInfo(app, currApp, clientTargetSdk);
                            if (app.adjSource instanceof ProcessRecord) {
                                currApp.importanceReasonPid = ((ProcessRecord) app.adjSource).pid;
                                currApp.importanceReasonImportance = ActivityManager.RunningAppProcessInfo.procStateToImportance(app.adjSourceProcState);
                            } else if (app.adjSource instanceof ActivityRecord) {
                                ActivityRecord r = (ActivityRecord) app.adjSource;
                                if (r.app != null) {
                                    currApp.importanceReasonPid = r.app.pid;
                                }
                            }
                            if (app.adjTarget instanceof ComponentName) {
                                currApp.importanceReasonComponent = (ComponentName) app.adjTarget;
                            }
                            if (runList == null) {
                                runList = new ArrayList<>();
                            }
                            runList.add(currApp);
                        }
                        i = i2 - 1;
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return runList;
    }

    public List<ApplicationInfo> getRunningExternalApplications() {
        String[] strArr;
        enforceNotIsolatedCaller("getRunningExternalApplications");
        List<ActivityManager.RunningAppProcessInfo> runningApps = getRunningAppProcesses();
        List<ApplicationInfo> retList = new ArrayList<>();
        if (runningApps != null && runningApps.size() > 0) {
            Set<String> extList = new HashSet<>();
            Iterator<ActivityManager.RunningAppProcessInfo> it = runningApps.iterator();
            while (true) {
                if (!it.hasNext()) {
                    break;
                }
                ActivityManager.RunningAppProcessInfo app = it.next();
                if (app.pkgList != null) {
                    for (String pkg : app.pkgList) {
                        extList.add(pkg);
                    }
                }
            }
            IPackageManager pm = AppGlobals.getPackageManager();
            for (String pkg2 : extList) {
                try {
                    ApplicationInfo info = pm.getApplicationInfo(pkg2, 0, UserHandle.getCallingUserId());
                    if ((info.flags & DumpState.DUMP_DOMAIN_PREFERRED) != 0) {
                        retList.add(info);
                    }
                } catch (RemoteException e) {
                }
            }
        }
        return retList;
    }

    public void getMyMemoryState(ActivityManager.RunningAppProcessInfo outState) {
        ProcessRecord proc;
        if (outState == null) {
            throw new IllegalArgumentException("outState is null");
        }
        enforceNotIsolatedCaller("getMyMemoryState");
        int callingUid = Binder.getCallingUid();
        int clientTargetSdk = this.mPackageManagerInt.getUidTargetSdkVersion(callingUid);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                synchronized (this.mPidsSelfLocked) {
                    proc = this.mPidsSelfLocked.get(Binder.getCallingPid());
                }
                if (proc != null) {
                    fillInProcMemInfo(proc, outState, clientTargetSdk);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public int getMemoryTrimLevel() {
        int i;
        enforceNotIsolatedCaller("getMyMemoryState");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                i = this.mLastMemoryLevel;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return i;
    }

    /* JADX WARN: Multi-variable type inference failed */
    public void onShellCommand(FileDescriptor in, FileDescriptor out, FileDescriptor err, String[] args, ShellCallback callback, ResultReceiver resultReceiver) {
        new ActivityManagerShellCommand(this, false).exec(this, in, out, err, args, callback, resultReceiver);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public ActivityManagerInternal.SleepToken acquireSleepToken(String tag, int displayId) {
        ActivityManagerInternal.SleepToken token;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                token = this.mStackSupervisor.createSleepTokenLocked(tag, displayId);
                updateSleepIfNeededLocked();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return token;
    }

    protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        PriorityDump.dump(this.mPriorityDumper, fd, pw, args);
    }

    /* JADX INFO: Access modifiers changed from: private */
    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Removed duplicated region for block: B:407:0x06e1  */
    /* JADX WARN: Removed duplicated region for block: B:409:0x06e7  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public void doDump(java.io.FileDescriptor r38, java.io.PrintWriter r39, java.lang.String[] r40, boolean r41) {
        /*
            Method dump skipped, instructions count: 2488
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.doDump(java.io.FileDescriptor, java.io.PrintWriter, java.lang.String[], boolean):void");
    }

    private void writeActivitiesToProtoLocked(ProtoOutputStream proto) {
        this.mStackSupervisor.writeToProto(proto, 1146756268033L);
    }

    private void dumpLastANRLocked(PrintWriter pw) {
        pw.println("ACTIVITY MANAGER LAST ANR (dumpsys activity lastanr)");
        if (this.mLastANRState == null) {
            pw.println("  <no ANR has occurred since boot>");
        } else {
            pw.println(this.mLastANRState);
        }
    }

    private void dumpActivityContainersLocked(PrintWriter pw) {
        pw.println("ACTIVITY MANAGER STARTER (dumpsys activity containers)");
        this.mStackSupervisor.dumpChildrenNames(pw, " ");
        pw.println(" ");
    }

    private void dumpActivityStarterLocked(PrintWriter pw, String dumpPackage) {
        pw.println("ACTIVITY MANAGER STARTER (dumpsys activity starter)");
        this.mActivityStartController.dump(pw, BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS, dumpPackage);
    }

    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {
        dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage, "ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)");
    }

    void dumpActivitiesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, boolean dumpClient, String dumpPackage, String header) {
        pw.println(header);
        boolean printedAnything = this.mStackSupervisor.dumpActivitiesLocked(fd, pw, dumpAll, dumpClient, dumpPackage);
        boolean needSep = printedAnything;
        boolean printed = ActivityStackSupervisor.printThisActivity(pw, this.mStackSupervisor.getResumedActivityLocked(), dumpPackage, needSep, "  ResumedActivity: ");
        if (printed) {
            printedAnything = true;
            needSep = false;
        }
        if (dumpPackage == null) {
            if (needSep) {
                pw.println();
            }
            printedAnything = true;
            this.mStackSupervisor.dump(pw, "  ");
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    void dumpAssociationsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {
        ArrayMap<String, Association> sourceProcesses;
        int dumpUid;
        int N1;
        ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> targetComponents;
        ActivityManagerService activityManagerService = this;
        String str = dumpPackage;
        pw.println("ACTIVITY MANAGER ASSOCIATIONS (dumpsys activity associations)");
        int dumpUid2 = 0;
        boolean z = false;
        if (str != null) {
            IPackageManager pm = AppGlobals.getPackageManager();
            try {
                dumpUid2 = pm.getPackageUid(str, (int) DumpState.DUMP_CHANGES, 0);
            } catch (RemoteException e) {
            }
        }
        int printedAnything = 0;
        long now = SystemClock.uptimeMillis();
        int i1 = 0;
        int N12 = activityManagerService.mAssociations.size();
        while (i1 < N12) {
            ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> targetComponents2 = activityManagerService.mAssociations.valueAt(i1);
            int i2 = 0;
            int N2 = targetComponents2.size();
            while (i2 < N2) {
                SparseArray<ArrayMap<String, Association>> sourceUids = targetComponents2.valueAt(i2);
                int i3 = 0;
                int N3 = sourceUids.size();
                while (i3 < N3) {
                    ArrayMap<String, Association> sourceProcesses2 = sourceUids.valueAt(i3);
                    int N4 = sourceProcesses2.size();
                    int i4 = printedAnything;
                    int i42 = 0;
                    while (true) {
                        int N42 = N4;
                        if (i42 < N42) {
                            Association ass = sourceProcesses2.valueAt(i42);
                            if (str != null) {
                                sourceProcesses = sourceProcesses2;
                                if (!ass.mTargetComponent.getPackageName().equals(str) && UserHandle.getAppId(ass.mSourceUid) != dumpUid2) {
                                    dumpUid = dumpUid2;
                                    N1 = N12;
                                    targetComponents = targetComponents2;
                                    i42++;
                                    N4 = N42;
                                    sourceProcesses2 = sourceProcesses;
                                    dumpUid2 = dumpUid;
                                    N12 = N1;
                                    targetComponents2 = targetComponents;
                                    str = dumpPackage;
                                }
                            } else {
                                sourceProcesses = sourceProcesses2;
                            }
                            i4 = 1;
                            pw.print("  ");
                            pw.print(ass.mTargetProcess);
                            pw.print(SliceClientPermissions.SliceAuthority.DELIMITER);
                            UserHandle.formatUid(pw, ass.mTargetUid);
                            pw.print(" <- ");
                            pw.print(ass.mSourceProcess);
                            pw.print(SliceClientPermissions.SliceAuthority.DELIMITER);
                            UserHandle.formatUid(pw, ass.mSourceUid);
                            pw.println();
                            pw.print("    via ");
                            pw.print(ass.mTargetComponent.flattenToShortString());
                            pw.println();
                            pw.print("    ");
                            dumpUid = dumpUid2;
                            long dur = ass.mTime;
                            if (ass.mNesting > 0) {
                                N1 = N12;
                                targetComponents = targetComponents2;
                                dur += now - ass.mStartTime;
                            } else {
                                N1 = N12;
                                targetComponents = targetComponents2;
                            }
                            TimeUtils.formatDuration(dur, pw);
                            pw.print(" (");
                            pw.print(ass.mCount);
                            pw.print(" times)");
                            pw.print("  ");
                            int i = 0;
                            while (i < ass.mStateTimes.length) {
                                long amt = ass.mStateTimes[i];
                                long dur2 = dur;
                                if (ass.mLastState - 0 == i) {
                                    amt += now - ass.mLastStateUptime;
                                }
                                if (amt != 0) {
                                    pw.print(" ");
                                    pw.print(ProcessList.makeProcStateString(i + 0));
                                    pw.print("=");
                                    TimeUtils.formatDuration(amt, pw);
                                    if (ass.mLastState - 0 == i) {
                                        pw.print("*");
                                    }
                                }
                                i++;
                                dur = dur2;
                            }
                            pw.println();
                            if (ass.mNesting > 0) {
                                pw.print("    Currently active: ");
                                TimeUtils.formatDuration(now - ass.mStartTime, pw);
                                pw.println();
                            }
                            i42++;
                            N4 = N42;
                            sourceProcesses2 = sourceProcesses;
                            dumpUid2 = dumpUid;
                            N12 = N1;
                            targetComponents2 = targetComponents;
                            str = dumpPackage;
                        }
                    }
                    i3++;
                    z = false;
                    printedAnything = i4;
                    dumpUid2 = dumpUid2;
                    str = dumpPackage;
                }
                i2++;
                dumpUid2 = dumpUid2;
                str = dumpPackage;
            }
            i1++;
            dumpUid2 = dumpUid2;
            activityManagerService = this;
            str = dumpPackage;
        }
        if (printedAnything == 0) {
            pw.println("  (nothing)");
        }
    }

    private int getAppId(String dumpPackage) {
        if (dumpPackage != null) {
            try {
                ApplicationInfo info = this.mContext.getPackageManager().getApplicationInfo(dumpPackage, 0);
                return UserHandle.getAppId(info.uid);
            } catch (PackageManager.NameNotFoundException e) {
                e.printStackTrace();
                return -1;
            }
        }
        return -1;
    }

    boolean dumpUids(PrintWriter pw, String dumpPackage, int dumpAppId, SparseArray<UidRecord> uids, String header, boolean needSep) {
        boolean printed = false;
        for (int i = 0; i < uids.size(); i++) {
            UidRecord uidRec = uids.valueAt(i);
            if (dumpPackage == null || UserHandle.getAppId(uidRec.uid) == dumpAppId) {
                if (!printed) {
                    printed = true;
                    if (needSep) {
                        pw.println();
                    }
                    pw.print("  ");
                    pw.println(header);
                    needSep = true;
                }
                pw.print("    UID ");
                UserHandle.formatUid(pw, uidRec.uid);
                pw.print(": ");
                pw.println(uidRec);
            }
        }
        return printed;
    }

    boolean dumpBinderProxiesCounts(PrintWriter pw, SparseIntArray counts, String header) {
        if (counts == null) {
            return false;
        }
        pw.println(header);
        for (int i = 0; i < counts.size(); i++) {
            int uid = counts.keyAt(i);
            int binderCount = counts.valueAt(i);
            pw.print("    UID ");
            pw.print(uid);
            pw.print(", binder count = ");
            pw.print(binderCount);
            pw.print(", package(s)= ");
            String[] pkgNames = this.mContext.getPackageManager().getPackagesForUid(uid);
            if (pkgNames != null) {
                for (String str : pkgNames) {
                    pw.print(str);
                    pw.print("; ");
                }
            } else {
                pw.print("NO PACKAGE NAME FOUND");
            }
            pw.println();
        }
        pw.println();
        return true;
    }

    /* JADX WARN: Code restructure failed: missing block: B:321:0x08cb, code lost:
        r20.println();
        r5 = false;
     */
    @com.android.internal.annotations.GuardedBy("this")
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    void dumpProcessesLocked(java.io.FileDescriptor r19, java.io.PrintWriter r20, java.lang.String[] r21, int r22, boolean r23, java.lang.String r24, int r25) {
        /*
            Method dump skipped, instructions count: 2895
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.dumpProcessesLocked(java.io.FileDescriptor, java.io.PrintWriter, java.lang.String[], int, boolean, java.lang.String, int):void");
    }

    @GuardedBy("this")
    void writeProcessesToProtoLocked(ProtoOutputStream proto, String dumpPackage) {
        int[] iArr;
        int[] iArr2;
        String str;
        int NP = this.mProcessNames.getMap().size();
        int numPers = 0;
        for (int numPers2 = 0; numPers2 < NP; numPers2++) {
            SparseArray<ProcessRecord> procs = (SparseArray) this.mProcessNames.getMap().valueAt(numPers2);
            int NA = procs.size();
            for (int ia = 0; ia < NA; ia++) {
                ProcessRecord r = procs.valueAt(ia);
                if (dumpPackage == null || r.pkgList.containsKey(dumpPackage)) {
                    r.writeToProto(proto, 2246267895809L);
                    if (r.persistent) {
                        numPers++;
                    }
                }
            }
        }
        for (int i = 0; i < this.mIsolatedProcesses.size(); i++) {
            ProcessRecord r2 = this.mIsolatedProcesses.valueAt(i);
            if (dumpPackage == null || r2.pkgList.containsKey(dumpPackage)) {
                r2.writeToProto(proto, 2246267895810L);
            }
        }
        for (int i2 = 0; i2 < this.mActiveInstrumentation.size(); i2++) {
            ActiveInstrumentation ai = this.mActiveInstrumentation.get(i2);
            if (dumpPackage == null || ai.mClass.getPackageName().equals(dumpPackage) || ai.mTargetInfo.packageName.equals(dumpPackage)) {
                ai.writeToProto(proto, 2246267895811L);
            }
        }
        int whichAppId = getAppId(dumpPackage);
        for (int i3 = 0; i3 < this.mActiveUids.size(); i3++) {
            UidRecord uidRec = this.mActiveUids.valueAt(i3);
            if (dumpPackage == null || UserHandle.getAppId(uidRec.uid) == whichAppId) {
                uidRec.writeToProto(proto, 2246267895812L);
            }
        }
        for (int i4 = 0; i4 < this.mValidateUids.size(); i4++) {
            UidRecord uidRec2 = this.mValidateUids.valueAt(i4);
            if (dumpPackage == null || UserHandle.getAppId(uidRec2.uid) == whichAppId) {
                uidRec2.writeToProto(proto, 2246267895813L);
            }
        }
        int numPers3 = numPers;
        if (this.mLruProcesses.size() > 0) {
            long lruToken = proto.start(1146756268038L);
            int total = this.mLruProcesses.size();
            proto.write(1120986464257L, total);
            proto.write(1120986464258L, total - this.mLruProcessActivityStart);
            proto.write(1120986464259L, total - this.mLruProcessServiceStart);
            writeProcessOomListToProto(proto, 2246267895812L, this, this.mLruProcesses, false, dumpPackage);
            proto.end(lruToken);
        }
        if (dumpPackage != null) {
            synchronized (this.mPidsSelfLocked) {
                for (int i5 = 0; i5 < this.mPidsSelfLocked.size(); i5++) {
                    ProcessRecord r3 = this.mPidsSelfLocked.valueAt(i5);
                    if (r3.pkgList.containsKey(dumpPackage)) {
                        r3.writeToProto(proto, 2246267895815L);
                    }
                }
            }
        }
        if (this.mImportantProcesses.size() > 0) {
            synchronized (this.mPidsSelfLocked) {
                for (int i6 = 0; i6 < this.mImportantProcesses.size(); i6++) {
                    ImportanceToken it = this.mImportantProcesses.valueAt(i6);
                    ProcessRecord r4 = this.mPidsSelfLocked.get(it.pid);
                    if (dumpPackage == null || (r4 != null && r4.pkgList.containsKey(dumpPackage))) {
                        it.writeToProto(proto, 2246267895816L);
                    }
                }
            }
        }
        for (int i7 = 0; i7 < this.mPersistentStartingProcesses.size(); i7++) {
            ProcessRecord r5 = this.mPersistentStartingProcesses.get(i7);
            if (dumpPackage == null || dumpPackage.equals(r5.info.packageName)) {
                r5.writeToProto(proto, 2246267895817L);
            }
        }
        for (int i8 = 0; i8 < this.mRemovedProcesses.size(); i8++) {
            ProcessRecord r6 = this.mRemovedProcesses.get(i8);
            if (dumpPackage == null || dumpPackage.equals(r6.info.packageName)) {
                r6.writeToProto(proto, 2246267895818L);
            }
        }
        for (int i9 = 0; i9 < this.mProcessesOnHold.size(); i9++) {
            ProcessRecord r7 = this.mProcessesOnHold.get(i9);
            if (dumpPackage == null || dumpPackage.equals(r7.info.packageName)) {
                r7.writeToProto(proto, 2246267895819L);
            }
        }
        writeProcessesToGcToProto(proto, 2246267895820L, dumpPackage);
        this.mAppErrors.writeToProto(proto, 1146756268045L, dumpPackage);
        if (dumpPackage == null) {
            this.mUserController.writeToProto(proto, 1146756268046L);
            getGlobalConfiguration().writeToProto(proto, 1146756268051L);
            proto.write(1133871366165L, getFocusedStack().mConfigWillChange);
        }
        if (this.mHomeProcess != null && (dumpPackage == null || this.mHomeProcess.pkgList.containsKey(dumpPackage))) {
            this.mHomeProcess.writeToProto(proto, 1146756268047L);
        }
        if (this.mPreviousProcess != null && (dumpPackage == null || this.mPreviousProcess.pkgList.containsKey(dumpPackage))) {
            this.mPreviousProcess.writeToProto(proto, 1146756268048L);
            proto.write(1112396529681L, this.mPreviousProcessVisibleTime);
        }
        if (this.mHeavyWeightProcess != null && (dumpPackage == null || this.mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
            this.mHeavyWeightProcess.writeToProto(proto, 1146756268050L);
        }
        for (Map.Entry<String, Integer> entry : this.mCompatModePackages.getPackages().entrySet()) {
            String pkg = entry.getKey();
            int mode = entry.getValue().intValue();
            if (dumpPackage == null || dumpPackage.equals(pkg)) {
                long compatToken = proto.start(2246267895830L);
                proto.write(1138166333441L, pkg);
                proto.write(1120986464258L, mode);
                proto.end(compatToken);
            }
        }
        int NI = this.mUidObservers.getRegisteredCallbackCount();
        for (int i10 = 0; i10 < NI; i10++) {
            UidObserverRegistration reg = (UidObserverRegistration) this.mUidObservers.getRegisteredCallbackCookie(i10);
            if (dumpPackage == null || dumpPackage.equals(reg.pkg)) {
                reg.writeToProto(proto, 2246267895831L);
            }
        }
        for (int v : this.mDeviceIdleWhitelist) {
            proto.write(2220498092056L, v);
        }
        for (int v2 : this.mDeviceIdleTempWhitelist) {
            proto.write(2220498092057L, v2);
        }
        if (this.mPendingTempWhitelist.size() > 0) {
            for (int i11 = 0; i11 < this.mPendingTempWhitelist.size(); i11++) {
                this.mPendingTempWhitelist.valueAt(i11).writeToProto(proto, 2246267895834L);
            }
        }
        if (dumpPackage == null) {
            long sleepToken = proto.start(1146756268059L);
            proto.write(1159641169921L, PowerManagerInternal.wakefulnessToProtoEnum(this.mWakefulness));
            Iterator<ActivityManagerInternal.SleepToken> it2 = this.mStackSupervisor.mSleepTokens.iterator();
            while (it2.hasNext()) {
                ActivityManagerInternal.SleepToken st = it2.next();
                proto.write(2237677961218L, st.toString());
            }
            proto.write(1133871366147L, this.mSleeping);
            proto.write(1133871366148L, this.mShuttingDown);
            proto.write(1133871366149L, this.mTestPssMode);
            proto.end(sleepToken);
            if (this.mRunningVoice != null) {
                long vrToken = proto.start(1146756268060L);
                proto.write(1138166333441L, this.mRunningVoice.toString());
                this.mVoiceWakeLock.writeToProto(proto, 1146756268034L);
                proto.end(vrToken);
            }
            this.mVrController.writeToProto(proto, 1146756268061L);
        }
        if ((this.mDebugApp != null || this.mOrigDebugApp != null || this.mDebugTransient || this.mOrigWaitForDebugger) && (dumpPackage == null || dumpPackage.equals(this.mDebugApp) || dumpPackage.equals(this.mOrigDebugApp))) {
            long debugAppToken = proto.start(1146756268062L);
            proto.write(1138166333441L, this.mDebugApp);
            proto.write(1138166333442L, this.mOrigDebugApp);
            proto.write(1133871366147L, this.mDebugTransient);
            proto.write(1133871366148L, this.mOrigWaitForDebugger);
            proto.end(debugAppToken);
        }
        if (this.mCurAppTimeTracker != null) {
            this.mCurAppTimeTracker.writeToProto(proto, 1146756268063L, true);
        }
        if (this.mMemWatchProcesses.getMap().size() > 0) {
            long token = proto.start(1146756268064L);
            ArrayMap<String, SparseArray<Pair<Long, String>>> procs2 = this.mMemWatchProcesses.getMap();
            for (int i12 = 0; i12 < procs2.size(); i12++) {
                String proc = procs2.keyAt(i12);
                long ptoken = proto.start(2246267895809L);
                proto.write(1138166333441L, proc);
                int j = 0;
                for (SparseArray<Pair<Long, String>> uids = procs2.valueAt(i12); j < uids.size(); uids = uids) {
                    long utoken = proto.start(2246267895810L);
                    Pair<Long, String> val = uids.valueAt(j);
                    proto.write(1120986464257L, uids.keyAt(j));
                    proto.write(1138166333442L, DebugUtils.sizeValueToString(((Long) val.first).longValue(), new StringBuilder()));
                    proto.write(1138166333443L, (String) val.second);
                    proto.end(utoken);
                    j++;
                    NI = NI;
                    procs2 = procs2;
                    NP = NP;
                    proc = proc;
                }
                proto.end(ptoken);
            }
            long dtoken = proto.start(1146756268034L);
            proto.write(1138166333441L, this.mMemWatchDumpProcName);
            proto.write(1138166333442L, this.mMemWatchDumpFile);
            proto.write(1120986464259L, this.mMemWatchDumpPid);
            proto.write(1120986464260L, this.mMemWatchDumpUid);
            proto.end(dtoken);
            proto.end(token);
        }
        if (this.mTrackAllocationApp != null) {
            str = dumpPackage;
            if (str == null || str.equals(this.mTrackAllocationApp)) {
                proto.write(1138166333473L, this.mTrackAllocationApp);
            }
        } else {
            str = dumpPackage;
        }
        if ((this.mProfileApp != null || this.mProfileProc != null || (this.mProfilerInfo != null && (this.mProfilerInfo.profileFile != null || this.mProfilerInfo.profileFd != null))) && (str == null || str.equals(this.mProfileApp))) {
            long token2 = proto.start(1146756268066L);
            proto.write(1138166333441L, this.mProfileApp);
            this.mProfileProc.writeToProto(proto, 1146756268034L);
            if (this.mProfilerInfo != null) {
                this.mProfilerInfo.writeToProto(proto, 1146756268035L);
                proto.write(1120986464260L, this.mProfileType);
            }
            proto.end(token2);
        }
        if (str == null || str.equals(this.mNativeDebuggingApp)) {
            proto.write(1138166333475L, this.mNativeDebuggingApp);
        }
        if (str == null) {
            proto.write(1133871366180L, this.mAlwaysFinishActivities);
            if (this.mController != null) {
                long token3 = proto.start(1146756268069L);
                proto.write(1138166333441L, this.mController.toString());
                proto.write(1133871366146L, this.mControllerIsAMonkey);
                proto.end(token3);
            }
            proto.write(1120986464294L, numPers3);
            proto.write(1133871366183L, this.mProcessesReady);
            proto.write(1133871366184L, this.mSystemReady);
            proto.write(1133871366185L, this.mBooted);
            proto.write(1120986464298L, this.mFactoryTest);
            proto.write(1133871366187L, this.mBooting);
            proto.write(1133871366188L, this.mCallFinishBooting);
            proto.write(1133871366189L, this.mBootAnimationComplete);
            proto.write(1112396529710L, this.mLastPowerCheckUptime);
            this.mStackSupervisor.mGoingToSleep.writeToProto(proto, 1146756268079L);
            this.mStackSupervisor.mLaunchingActivity.writeToProto(proto, 1146756268080L);
            proto.write(1120986464305L, this.mAdjSeq);
            proto.write(1120986464306L, this.mLruSeq);
            proto.write(1120986464307L, this.mNumNonCachedProcs);
            proto.write(1120986464309L, this.mNumServiceProcs);
            proto.write(1120986464310L, this.mNewNumServiceProcs);
            proto.write(1133871366199L, this.mAllowLowerMemLevel);
            proto.write(1120986464312L, this.mLastMemoryLevel);
            proto.write(1120986464313L, this.mLastNumProcesses);
            long now = SystemClock.uptimeMillis();
            ProtoUtils.toDuration(proto, 1146756268090L, this.mLastIdleTime, now);
            proto.write(1112396529723L, getLowRamTimeSinceIdle(now));
        }
    }

    void writeProcessesToGcToProto(ProtoOutputStream proto, long fieldId, String dumpPackage) {
        if (this.mProcessesToGc.size() > 0) {
            long now = SystemClock.uptimeMillis();
            for (int i = 0; i < this.mProcessesToGc.size(); i++) {
                ProcessRecord r = this.mProcessesToGc.get(i);
                if (dumpPackage == null || dumpPackage.equals(r.info.packageName)) {
                    long token = proto.start(fieldId);
                    r.writeToProto(proto, 1146756268033L);
                    proto.write(1133871366146L, r.reportLowMemory);
                    proto.write(1112396529667L, now);
                    proto.write(1112396529668L, r.lastRequestedGc);
                    proto.write(1112396529669L, r.lastLowMemory);
                    proto.end(token);
                }
            }
        }
    }

    boolean dumpProcessesToGc(PrintWriter pw, boolean needSep, String dumpPackage) {
        if (this.mProcessesToGc.size() > 0) {
            boolean printed = false;
            long now = SystemClock.uptimeMillis();
            for (int i = 0; i < this.mProcessesToGc.size(); i++) {
                ProcessRecord proc = this.mProcessesToGc.get(i);
                if (dumpPackage == null || dumpPackage.equals(proc.info.packageName)) {
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        needSep = true;
                        pw.println("  Processes that are waiting to GC:");
                        printed = true;
                    }
                    pw.print("    Process ");
                    pw.println(proc);
                    pw.print("      lowMem=");
                    pw.print(proc.reportLowMemory);
                    pw.print(", last gced=");
                    pw.print(now - proc.lastRequestedGc);
                    pw.print(" ms ago, last lowMem=");
                    pw.print(now - proc.lastLowMemory);
                    pw.println(" ms ago");
                }
            }
        }
        return needSep;
    }

    void printOomLevel(PrintWriter pw, String name, int adj) {
        pw.print("    ");
        if (adj >= 0) {
            pw.print(' ');
            if (adj < 10) {
                pw.print(' ');
            }
        } else if (adj > -10) {
            pw.print(' ');
        }
        pw.print(adj);
        pw.print(": ");
        pw.print(name);
        pw.print(" (");
        pw.print(stringifySize(this.mProcessList.getMemLevel(adj), 1024));
        pw.println(")");
    }

    boolean dumpOomLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll) {
        boolean needSep = false;
        if (this.mLruProcesses.size() > 0) {
            if (0 != 0) {
                pw.println();
            }
            pw.println("  OOM levels:");
            printOomLevel(pw, "SYSTEM_ADJ", -900);
            printOomLevel(pw, "PERSISTENT_PROC_ADJ", -800);
            printOomLevel(pw, "PERSISTENT_SERVICE_ADJ", -700);
            printOomLevel(pw, "FOREGROUND_APP_ADJ", 0);
            printOomLevel(pw, "VISIBLE_APP_ADJ", 100);
            printOomLevel(pw, "PERCEPTIBLE_APP_ADJ", 200);
            printOomLevel(pw, "BACKUP_APP_ADJ", 300);
            printOomLevel(pw, "HEAVY_WEIGHT_APP_ADJ", 400);
            printOomLevel(pw, "SERVICE_ADJ", 500);
            printOomLevel(pw, "HOME_APP_ADJ", 600);
            printOomLevel(pw, "PREVIOUS_APP_ADJ", 700);
            printOomLevel(pw, "SERVICE_B_ADJ", 800);
            printOomLevel(pw, "CACHED_APP_MIN_ADJ", 900);
            printOomLevel(pw, "CACHED_APP_MAX_ADJ", 906);
            if (1 != 0) {
                pw.println();
            }
            pw.print("  Process OOM control (");
            pw.print(this.mLruProcesses.size());
            pw.print(" total, non-act at ");
            pw.print(this.mLruProcesses.size() - this.mLruProcessActivityStart);
            pw.print(", non-svc at ");
            pw.print(this.mLruProcesses.size() - this.mLruProcessServiceStart);
            pw.println("):");
            dumpProcessOomList(pw, this, this.mLruProcesses, "    ", "Proc", "PERS", true, null);
            needSep = true;
        }
        dumpProcessesToGc(pw, needSep, null);
        pw.println();
        pw.println("  mHomeProcess: " + this.mHomeProcess);
        pw.println("  mPreviousProcess: " + this.mPreviousProcess);
        if (this.mHeavyWeightProcess != null) {
            pw.println("  mHeavyWeightProcess: " + this.mHeavyWeightProcess);
            return true;
        }
        return true;
    }

    protected boolean dumpProvider(FileDescriptor fd, PrintWriter pw, String name, String[] args, int opti, boolean dumpAll) {
        return this.mProviderMap.dumpProvider(fd, pw, name, args, opti, dumpAll);
    }

    protected boolean dumpProviderProto(FileDescriptor fd, PrintWriter pw, String name, String[] args) {
        return this.mProviderMap.dumpProviderProto(fd, pw, name, args);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public static class ItemMatcher {
        boolean all = true;
        ArrayList<ComponentName> components;
        ArrayList<Integer> objects;
        ArrayList<String> strings;

        /* JADX INFO: Access modifiers changed from: package-private */
        public void build(String name) {
            ComponentName componentName = ComponentName.unflattenFromString(name);
            if (componentName != null) {
                if (this.components == null) {
                    this.components = new ArrayList<>();
                }
                this.components.add(componentName);
                this.all = false;
                return;
            }
            try {
                int objectId = Integer.parseInt(name, 16);
                if (this.objects == null) {
                    this.objects = new ArrayList<>();
                }
                this.objects.add(Integer.valueOf(objectId));
                this.all = false;
            } catch (RuntimeException e) {
                if (this.strings == null) {
                    this.strings = new ArrayList<>();
                }
                this.strings.add(name);
                this.all = false;
            }
        }

        /* JADX INFO: Access modifiers changed from: package-private */
        public int build(String[] args, int opti) {
            while (opti < args.length) {
                String name = args[opti];
                if ("--".equals(name)) {
                    return opti + 1;
                }
                build(name);
                opti++;
            }
            return opti;
        }

        /* JADX INFO: Access modifiers changed from: package-private */
        public boolean match(Object object, ComponentName comp) {
            if (this.all) {
                return true;
            }
            if (this.components != null) {
                for (int i = 0; i < this.components.size(); i++) {
                    if (this.components.get(i).equals(comp)) {
                        return true;
                    }
                }
            }
            if (this.objects != null) {
                for (int i2 = 0; i2 < this.objects.size(); i2++) {
                    if (System.identityHashCode(object) == this.objects.get(i2).intValue()) {
                        return true;
                    }
                }
            }
            if (this.strings != null) {
                String flat = comp.flattenToString();
                for (int i3 = 0; i3 < this.strings.size(); i3++) {
                    if (flat.contains(this.strings.get(i3))) {
                        return true;
                    }
                }
            }
            return false;
        }
    }

    protected boolean dumpActivity(FileDescriptor fd, PrintWriter pw, String name, String[] args, int opti, boolean dumpAll, boolean dumpVisibleStacksOnly, boolean dumpFocusedStackOnly) {
        TaskRecord lastTask;
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    ArrayList<ActivityRecord> activities = this.mStackSupervisor.getDumpActivitiesLocked(name, dumpVisibleStacksOnly, dumpFocusedStackOnly);
                    resetPriorityAfterLockedSection();
                    if (activities.size() <= 0) {
                        return false;
                    }
                    String[] newArgs = new String[args.length - opti];
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
                    boolean needSep = false;
                    int i = activities.size() - 1;
                    TaskRecord lastTask2 = null;
                    while (true) {
                        int i2 = i;
                        if (i2 < 0) {
                            return true;
                        }
                        ActivityRecord r = activities.get(i2);
                        if (needSep) {
                            pw.println();
                        }
                        synchronized (this) {
                            try {
                                boostPriorityForLockedSection();
                                TaskRecord task = r.getTask();
                                if (lastTask2 != task) {
                                    lastTask2 = task;
                                    try {
                                        pw.print("TASK ");
                                        pw.print(lastTask2.affinity);
                                        pw.print(" id=");
                                        pw.print(lastTask2.taskId);
                                        pw.print(" userId=");
                                        pw.println(lastTask2.userId);
                                        if (dumpAll) {
                                            lastTask2.dump(pw, "  ");
                                        }
                                    } catch (Throwable th) {
                                        th = th;
                                        while (true) {
                                            try {
                                                break;
                                            } catch (Throwable th2) {
                                                th = th2;
                                            }
                                        }
                                        resetPriorityAfterLockedSection();
                                        throw th;
                                    }
                                }
                                lastTask = lastTask2;
                            } catch (Throwable th3) {
                                th = th3;
                            }
                            try {
                            } catch (Throwable th4) {
                                th = th4;
                                while (true) {
                                    break;
                                    break;
                                }
                                resetPriorityAfterLockedSection();
                                throw th;
                            }
                        }
                        resetPriorityAfterLockedSection();
                        dumpActivity("  ", fd, pw, activities.get(i2), newArgs, dumpAll);
                        i = i2 - 1;
                        needSep = true;
                        lastTask2 = lastTask;
                        newArgs = newArgs;
                    }
                } catch (Throwable th5) {
                    th = th5;
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            } catch (Throwable th6) {
                th = th6;
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    private void dumpActivity(String prefix, FileDescriptor fd, PrintWriter pw, ActivityRecord r, String[] args, boolean dumpAll) {
        String innerPrefix = prefix + "  ";
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                pw.print(prefix);
                pw.print("ACTIVITY ");
                pw.print(r.shortComponentName);
                pw.print(" ");
                pw.print(Integer.toHexString(System.identityHashCode(r)));
                pw.print(" pid=");
                if (r.app != null) {
                    pw.println(r.app.pid);
                } else {
                    pw.println("(not running)");
                }
                if (dumpAll) {
                    r.dump(pw, innerPrefix);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (r.app != null && r.app.thread != null) {
            pw.flush();
            try {
                TransferPipe tp = new TransferPipe();
                r.app.thread.dumpActivity(tp.getWriteFd(), r.appToken, innerPrefix, args);
                tp.go(fd);
                tp.kill();
            } catch (RemoteException e) {
                pw.println(innerPrefix + "Got a RemoteException while dumping the activity");
            } catch (IOException e2) {
                pw.println(innerPrefix + "Failure while dumping the activity: " + e2);
            }
        }
    }

    void writeBroadcastsToProtoLocked(ProtoOutputStream proto) {
        BroadcastQueue[] broadcastQueueArr;
        if (this.mRegisteredReceivers.size() > 0) {
            for (ReceiverList r : this.mRegisteredReceivers.values()) {
                r.writeToProto(proto, 2246267895809L);
            }
        }
        this.mReceiverResolver.writeToProto(proto, 1146756268034L);
        int user = 0;
        for (BroadcastQueue q : this.mBroadcastQueues) {
            q.writeToProto(proto, 2246267895811L);
        }
        while (true) {
            int user2 = user;
            long token = 1138166333441L;
            if (user2 < this.mStickyBroadcasts.size()) {
                long token2 = proto.start(2246267895812L);
                proto.write(1120986464257L, this.mStickyBroadcasts.keyAt(user2));
                Iterator<Map.Entry<String, ArrayList<Intent>>> it = this.mStickyBroadcasts.valueAt(user2).entrySet().iterator();
                while (it.hasNext()) {
                    Map.Entry<String, ArrayList<Intent>> ent = it.next();
                    long actionToken = proto.start(2246267895810L);
                    proto.write(token, ent.getKey());
                    Iterator<Intent> it2 = ent.getValue().iterator();
                    while (it2.hasNext()) {
                        Intent intent = it2.next();
                        intent.writeToProto(proto, 2246267895810L, false, true, true, false);
                        actionToken = actionToken;
                        token2 = token2;
                        it2 = it2;
                        ent = ent;
                    }
                    proto.end(actionToken);
                    token = 1138166333441L;
                }
                proto.end(token2);
                user = user2 + 1;
            } else {
                long handlerToken = proto.start(1146756268037L);
                proto.write(1138166333441L, this.mHandler.toString());
                this.mHandler.getLooper().writeToProto(proto, 1146756268034L);
                proto.end(handlerToken);
                return;
            }
        }
    }

    void dumpBroadcastsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        boolean dumpAll2;
        boolean onlyHistory;
        BroadcastQueue[] broadcastQueueArr;
        boolean dumpAll3;
        String[] strArr = args;
        boolean needSep = false;
        boolean printedAnything = false;
        String str = dumpPackage;
        if (!"history".equals(str)) {
            dumpAll2 = dumpAll;
            onlyHistory = false;
        } else {
            if (opti < strArr.length && "-s".equals(strArr[opti])) {
                dumpAll3 = false;
            } else {
                dumpAll3 = dumpAll;
            }
            str = null;
            onlyHistory = true;
            dumpAll2 = dumpAll3;
        }
        String dumpPackage2 = str;
        pw.println("ACTIVITY MANAGER BROADCAST STATE (dumpsys activity broadcasts)");
        if (!onlyHistory && dumpAll2) {
            if (this.mRegisteredReceivers.size() > 0) {
                boolean printed = false;
                for (ReceiverList r : this.mRegisteredReceivers.values()) {
                    if (dumpPackage2 == null || (r.app != null && dumpPackage2.equals(r.app.info.packageName))) {
                        if (!printed) {
                            pw.println("  Registered Receivers:");
                            needSep = true;
                            printed = true;
                            printedAnything = true;
                        }
                        pw.print("  * ");
                        pw.println(r);
                        r.dump(pw, "    ");
                    }
                }
            }
            boolean needSep2 = needSep;
            boolean printedAnything2 = printedAnything;
            if (this.mReceiverResolver.dump(pw, needSep2 ? "\n  Receiver Resolver Table:" : "  Receiver Resolver Table:", "    ", dumpPackage2, false, false)) {
                needSep = true;
                printedAnything = true;
            } else {
                needSep = needSep2;
                printedAnything = printedAnything2;
            }
        }
        BroadcastQueue[] broadcastQueueArr2 = this.mBroadcastQueues;
        int length = broadcastQueueArr2.length;
        int i = 0;
        boolean needSep3 = needSep;
        boolean printedAnything3 = printedAnything;
        int i2 = 0;
        while (i2 < length) {
            BroadcastQueue q = broadcastQueueArr2[i2];
            needSep3 = q.dumpLocked(fd, pw, strArr, opti, dumpAll2, dumpPackage2, needSep3);
            printedAnything3 |= needSep3;
            i2++;
            i = i;
            length = length;
            strArr = args;
        }
        int i3 = i;
        if (!onlyHistory && this.mStickyBroadcasts != null && dumpPackage2 == null) {
            boolean needSep4 = true;
            int user = i3;
            while (user < this.mStickyBroadcasts.size()) {
                if (needSep4) {
                    pw.println();
                }
                needSep4 = true;
                printedAnything3 = true;
                pw.print("  Sticky broadcasts for user ");
                pw.print(this.mStickyBroadcasts.keyAt(user));
                pw.println(":");
                StringBuilder sb = new StringBuilder(128);
                for (Map.Entry<String, ArrayList<Intent>> ent : this.mStickyBroadcasts.valueAt(user).entrySet()) {
                    pw.print("  * Sticky action ");
                    pw.print(ent.getKey());
                    if (dumpAll2) {
                        pw.println(":");
                        ArrayList<Intent> intents = ent.getValue();
                        int N = intents.size();
                        int i4 = i3;
                        while (i4 < N) {
                            sb.setLength(i3);
                            sb.append("    Intent: ");
                            intents.get(i4).toShortString(sb, false, true, false, false);
                            pw.println(sb.toString());
                            Bundle bundle = intents.get(i4).getExtras();
                            if (bundle != null) {
                                pw.print("      ");
                                pw.println(bundle.toString());
                            }
                            i4++;
                            i3 = 0;
                        }
                    } else {
                        pw.println(BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
                    }
                    i3 = 0;
                }
                user++;
                i3 = 0;
            }
        }
        if (!onlyHistory && dumpAll2) {
            pw.println();
            for (BroadcastQueue queue : this.mBroadcastQueues) {
                pw.println("  mBroadcastsScheduled [" + queue.mQueueName + "]=" + queue.mBroadcastsScheduled);
            }
            pw.println("  mHandler:");
            this.mHandler.dump(new PrintWriterPrinter(pw), "    ");
            printedAnything3 = true;
        }
        if (!printedAnything3) {
            pw.println("  (nothing)");
        }
    }

    void dumpBroadcastStatsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        if (this.mCurBroadcastStats == null) {
            return;
        }
        pw.println("ACTIVITY MANAGER BROADCAST STATS STATE (dumpsys activity broadcast-stats)");
        long now = SystemClock.elapsedRealtime();
        if (this.mLastBroadcastStats != null) {
            pw.print("  Last stats (from ");
            TimeUtils.formatDuration(this.mLastBroadcastStats.mStartRealtime, now, pw);
            pw.print(" to ");
            TimeUtils.formatDuration(this.mLastBroadcastStats.mEndRealtime, now, pw);
            pw.print(", ");
            TimeUtils.formatDuration(this.mLastBroadcastStats.mEndUptime - this.mLastBroadcastStats.mStartUptime, pw);
            pw.println(" uptime):");
            if (!this.mLastBroadcastStats.dumpStats(pw, "    ", dumpPackage)) {
                pw.println("    (nothing)");
            }
            pw.println();
        }
        pw.print("  Current stats (from ");
        TimeUtils.formatDuration(this.mCurBroadcastStats.mStartRealtime, now, pw);
        pw.print(" to now, ");
        TimeUtils.formatDuration(SystemClock.uptimeMillis() - this.mCurBroadcastStats.mStartUptime, pw);
        pw.println(" uptime):");
        if (!this.mCurBroadcastStats.dumpStats(pw, "    ", dumpPackage)) {
            pw.println("    (nothing)");
        }
    }

    void dumpBroadcastStatsCheckinLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean fullCheckin, String dumpPackage) {
        if (this.mCurBroadcastStats == null) {
            return;
        }
        if (this.mLastBroadcastStats != null) {
            this.mLastBroadcastStats.dumpCheckinStats(pw, dumpPackage);
            if (fullCheckin) {
                this.mLastBroadcastStats = null;
                return;
            }
        }
        this.mCurBroadcastStats.dumpCheckinStats(pw, dumpPackage);
        if (fullCheckin) {
            this.mCurBroadcastStats = null;
        }
    }

    void dumpProvidersLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        ItemMatcher matcher = new ItemMatcher();
        matcher.build(args, opti);
        pw.println("ACTIVITY MANAGER CONTENT PROVIDERS (dumpsys activity providers)");
        boolean needSep = this.mProviderMap.dumpProvidersLocked(pw, dumpAll, dumpPackage);
        boolean printedAnything = false | needSep;
        if (this.mLaunchingProviders.size() > 0) {
            boolean printed = false;
            for (int i = this.mLaunchingProviders.size() - 1; i >= 0; i--) {
                ContentProviderRecord r = this.mLaunchingProviders.get(i);
                if (dumpPackage == null || dumpPackage.equals(r.name.getPackageName())) {
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        needSep = true;
                        pw.println("  Launching content providers:");
                        printed = true;
                        printedAnything = true;
                    }
                    pw.print("  Launching #");
                    pw.print(i);
                    pw.print(": ");
                    pw.println(r);
                }
            }
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    @GuardedBy("this")
    void dumpPermissionsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        boolean needSep = false;
        boolean printedAnything = false;
        pw.println("ACTIVITY MANAGER URI PERMISSIONS (dumpsys activity permissions)");
        if (this.mGrantedUriPermissions.size() > 0) {
            boolean printed = false;
            int dumpUid = -2;
            int uid = 0;
            if (dumpPackage != null) {
                try {
                    dumpUid = this.mContext.getPackageManager().getPackageUidAsUser(dumpPackage, DumpState.DUMP_CHANGES, 0);
                } catch (PackageManager.NameNotFoundException e) {
                    dumpUid = -1;
                }
            }
            while (true) {
                int i = uid;
                if (i >= this.mGrantedUriPermissions.size()) {
                    break;
                }
                int uid2 = this.mGrantedUriPermissions.keyAt(i);
                if (dumpUid < -1 || UserHandle.getAppId(uid2) == dumpUid) {
                    ArrayMap<GrantUri, UriPermission> perms = this.mGrantedUriPermissions.valueAt(i);
                    if (!printed) {
                        if (needSep) {
                            pw.println();
                        }
                        needSep = true;
                        pw.println("  Granted Uri Permissions:");
                        printed = true;
                        printedAnything = true;
                    }
                    pw.print("  * UID ");
                    pw.print(uid2);
                    pw.println(" holds:");
                    for (UriPermission perm : perms.values()) {
                        pw.print("    ");
                        pw.println(perm);
                        if (dumpAll) {
                            perm.dump(pw, "      ");
                        }
                    }
                }
                uid = i + 1;
            }
        }
        if (!printedAnything) {
            pw.println("  (nothing)");
        }
    }

    void dumpPendingIntentsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
        boolean printed = false;
        pw.println("ACTIVITY MANAGER PENDING INTENTS (dumpsys activity intents)");
        if (this.mIntentSenderRecords.size() > 0) {
            ArrayMap<String, ArrayList<PendingIntentRecord>> byPackage = new ArrayMap<>();
            ArrayList<WeakReference<PendingIntentRecord>> weakRefs = new ArrayList<>();
            Iterator<WeakReference<PendingIntentRecord>> it = this.mIntentSenderRecords.values().iterator();
            while (it.hasNext()) {
                WeakReference<PendingIntentRecord> ref = it.next();
                PendingIntentRecord rec = ref != null ? ref.get() : null;
                if (rec == null) {
                    weakRefs.add(ref);
                } else if (dumpPackage == null || dumpPackage.equals(rec.key.packageName)) {
                    ArrayList<PendingIntentRecord> list = byPackage.get(rec.key.packageName);
                    if (list == null) {
                        list = new ArrayList<>();
                        byPackage.put(rec.key.packageName, list);
                    }
                    list.add(rec);
                }
            }
            boolean printed2 = false;
            for (int i = 0; i < byPackage.size(); i++) {
                ArrayList<PendingIntentRecord> intents = byPackage.valueAt(i);
                printed2 = true;
                pw.print("  * ");
                pw.print(byPackage.keyAt(i));
                pw.print(": ");
                pw.print(intents.size());
                pw.println(" items");
                for (int j = 0; j < intents.size(); j++) {
                    pw.print("    #");
                    pw.print(j);
                    pw.print(": ");
                    pw.println(intents.get(j));
                    if (dumpAll) {
                        intents.get(j).dump(pw, "      ");
                    }
                }
            }
            int i2 = weakRefs.size();
            if (i2 > 0) {
                printed = true;
                pw.println("  * WEAK REFS:");
                for (int i3 = 0; i3 < weakRefs.size(); i3++) {
                    pw.print("    #");
                    pw.print(i3);
                    pw.print(": ");
                    pw.println(weakRefs.get(i3));
                }
            } else {
                printed = printed2;
            }
        }
        if (!printed) {
            pw.println("  (nothing)");
        }
    }

    private static final int dumpProcessList(PrintWriter pw, ActivityManagerService service, List list, String prefix, String normalLabel, String persistentLabel, String dumpPackage) {
        int N = list.size() - 1;
        int numPers = 0;
        for (int numPers2 = N; numPers2 >= 0; numPers2--) {
            ProcessRecord r = (ProcessRecord) list.get(numPers2);
            if (dumpPackage == null || dumpPackage.equals(r.info.packageName)) {
                Object[] objArr = new Object[4];
                objArr[0] = prefix;
                objArr[1] = r.persistent ? persistentLabel : normalLabel;
                objArr[2] = Integer.valueOf(numPers2);
                objArr[3] = r.toString();
                pw.println(String.format("%s%s #%2d: %s", objArr));
                if (r.persistent) {
                    numPers++;
                }
            }
        }
        return numPers;
    }

    private static final ArrayList<Pair<ProcessRecord, Integer>> sortProcessOomList(List<ProcessRecord> origList, String dumpPackage) {
        ArrayList<Pair<ProcessRecord, Integer>> list = new ArrayList<>(origList.size());
        for (int i = 0; i < origList.size(); i++) {
            ProcessRecord r = origList.get(i);
            if (dumpPackage == null || r.pkgList.containsKey(dumpPackage)) {
                list.add(new Pair<>(origList.get(i), Integer.valueOf(i)));
            }
        }
        Comparator<Pair<ProcessRecord, Integer>> comparator = new Comparator<Pair<ProcessRecord, Integer>>() { // from class: com.android.server.am.ActivityManagerService.24
            @Override // java.util.Comparator
            public int compare(Pair<ProcessRecord, Integer> object1, Pair<ProcessRecord, Integer> object2) {
                if (((ProcessRecord) object1.first).setAdj != ((ProcessRecord) object2.first).setAdj) {
                    return ((ProcessRecord) object1.first).setAdj > ((ProcessRecord) object2.first).setAdj ? -1 : 1;
                } else if (((ProcessRecord) object1.first).setProcState != ((ProcessRecord) object2.first).setProcState) {
                    return ((ProcessRecord) object1.first).setProcState > ((ProcessRecord) object2.first).setProcState ? -1 : 1;
                } else if (((Integer) object1.second).intValue() != ((Integer) object2.second).intValue()) {
                    return ((Integer) object1.second).intValue() > ((Integer) object2.second).intValue() ? -1 : 1;
                } else {
                    return 0;
                }
            }
        };
        Collections.sort(list, comparator);
        return list;
    }

    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Type inference failed for: r7v0 */
    /* JADX WARN: Type inference failed for: r7v1, types: [int, boolean] */
    /* JADX WARN: Type inference failed for: r7v19 */
    private static final boolean writeProcessOomListToProto(ProtoOutputStream proto, long fieldId, ActivityManagerService service, List<ProcessRecord> origList, boolean inclDetails, String dumpPackage) {
        ArrayList<Pair<ProcessRecord, Integer>> list;
        long curUptime;
        ArrayList<Pair<ProcessRecord, Integer>> list2 = sortProcessOomList(origList, dumpPackage);
        if (list2.isEmpty()) {
            return false;
        }
        long curUptime2 = SystemClock.uptimeMillis();
        ?? r7 = 1;
        int i = list2.size() - 1;
        while (i >= 0) {
            ProcessRecord r = (ProcessRecord) list2.get(i).first;
            long token = proto.start(fieldId);
            String oomAdj = ProcessList.makeOomAdjString(r.setAdj);
            proto.write(1133871366145L, r.persistent);
            proto.write(1120986464258L, (origList.size() - r7) - ((Integer) list2.get(i).second).intValue());
            proto.write(1138166333443L, oomAdj);
            int schedGroup = -1;
            int i2 = r.setSchedGroup;
            if (i2 == 0) {
                schedGroup = 0;
            } else {
                switch (i2) {
                    case 2:
                        schedGroup = 1;
                        break;
                    case 3:
                        schedGroup = 2;
                        break;
                    case 4:
                        schedGroup = 3;
                        break;
                }
            }
            if (schedGroup != -1) {
                proto.write(1159641169924L, schedGroup);
            }
            if (r.foregroundActivities) {
                proto.write(1133871366149L, (boolean) r7);
            } else if (r.foregroundServices) {
                proto.write(1133871366150L, (boolean) r7);
            }
            proto.write(1159641169927L, ProcessList.makeProcStateProtoEnum(r.curProcState));
            proto.write(1120986464264L, r.trimMemoryLevel);
            r.writeToProto(proto, 1146756268041L);
            proto.write(1138166333450L, r.adjType);
            if (r.adjSource != null || r.adjTarget != null) {
                if (r.adjTarget instanceof ComponentName) {
                    ComponentName cn = (ComponentName) r.adjTarget;
                    cn.writeToProto(proto, 1146756268043L);
                } else if (r.adjTarget != null) {
                    proto.write(1138166333452L, r.adjTarget.toString());
                }
                if (r.adjSource instanceof ProcessRecord) {
                    ProcessRecord p = (ProcessRecord) r.adjSource;
                    p.writeToProto(proto, 1146756268045L);
                } else if (r.adjSource != null) {
                    proto.write(1138166333454L, r.adjSource.toString());
                }
            }
            if (inclDetails) {
                long detailToken = proto.start(1146756268047L);
                proto.write(1120986464257L, r.maxAdj);
                proto.write(1120986464258L, r.curRawAdj);
                proto.write(1120986464259L, r.setRawAdj);
                proto.write(1120986464260L, r.curAdj);
                proto.write(1120986464261L, r.setAdj);
                proto.write(1159641169927L, ProcessList.makeProcStateProtoEnum(r.curProcState));
                proto.write(1159641169928L, ProcessList.makeProcStateProtoEnum(r.setProcState));
                proto.write(1138166333449L, DebugUtils.sizeValueToString(r.lastPss * 1024, new StringBuilder()));
                proto.write(1138166333450L, DebugUtils.sizeValueToString(r.lastSwapPss * 1024, new StringBuilder()));
                proto.write(1138166333451L, DebugUtils.sizeValueToString(r.lastCachedPss * 1024, new StringBuilder()));
                proto.write(1133871366156L, r.cached);
                proto.write(1133871366157L, r.empty);
                proto.write(1133871366158L, r.hasAboveClient);
                if (r.setProcState >= 9 && r.lastCpuTime != 0) {
                    long uptimeSince = curUptime2 - service.mLastPowerCheckUptime;
                    list = list2;
                    curUptime = curUptime2;
                    long timeUsed = r.curCpuTime - r.lastCpuTime;
                    long cpuTimeToken = proto.start(1146756268047L);
                    proto.write(1112396529665L, uptimeSince);
                    proto.write(1112396529666L, timeUsed);
                    proto.write(1108101562371L, (100.0d * timeUsed) / uptimeSince);
                    proto.end(cpuTimeToken);
                } else {
                    list = list2;
                    curUptime = curUptime2;
                }
                proto.end(detailToken);
            } else {
                list = list2;
                curUptime = curUptime2;
            }
            proto.end(token);
            i--;
            list2 = list;
            curUptime2 = curUptime;
            r7 = 1;
        }
        return true;
    }

    private static final boolean dumpProcessOomList(PrintWriter pw, ActivityManagerService service, List<ProcessRecord> origList, String prefix, String normalLabel, String persistentLabel, boolean inclDetails, String dumpPackage) {
        char schedGroup;
        char c;
        ArrayList<Pair<ProcessRecord, Integer>> list;
        long curUptime;
        ArrayList<Pair<ProcessRecord, Integer>> list2 = sortProcessOomList(origList, dumpPackage);
        if (list2.isEmpty()) {
            return false;
        }
        long curUptime2 = SystemClock.uptimeMillis();
        long uptimeSince = curUptime2 - service.mLastPowerCheckUptime;
        int i = list2.size() - 1;
        while (i >= 0) {
            ProcessRecord r = (ProcessRecord) list2.get(i).first;
            String oomAdj = ProcessList.makeOomAdjString(r.setAdj);
            switch (r.setSchedGroup) {
                case 0:
                    schedGroup = 'B';
                    break;
                case 1:
                    schedGroup = 'R';
                    break;
                case 2:
                    schedGroup = 'F';
                    break;
                case 3:
                    schedGroup = 'T';
                    break;
                default:
                    schedGroup = '?';
                    break;
            }
            char foreground = r.foregroundActivities ? 'A' : r.foregroundServices ? 'S' : ' ';
            String procState = ProcessList.makeProcStateString(r.curProcState);
            pw.print(prefix);
            pw.print(r.persistent ? persistentLabel : normalLabel);
            pw.print(" #");
            int num = (origList.size() - 1) - ((Integer) list2.get(i).second).intValue();
            if (num < 10) {
                pw.print(' ');
            }
            pw.print(num);
            pw.print(": ");
            pw.print(oomAdj);
            pw.print(' ');
            pw.print(schedGroup);
            pw.print('/');
            pw.print(foreground);
            pw.print('/');
            pw.print(procState);
            pw.print(" trm:");
            if (r.trimMemoryLevel < 10) {
                c = ' ';
                pw.print(' ');
            } else {
                c = ' ';
            }
            pw.print(r.trimMemoryLevel);
            pw.print(c);
            pw.print(r.toShortString());
            pw.print(" (");
            pw.print(r.adjType);
            pw.println(')');
            if (r.adjSource != null || r.adjTarget != null) {
                pw.print(prefix);
                pw.print("    ");
                if (r.adjTarget instanceof ComponentName) {
                    pw.print(((ComponentName) r.adjTarget).flattenToShortString());
                } else if (r.adjTarget != null) {
                    pw.print(r.adjTarget.toString());
                } else {
                    pw.print("{null}");
                }
                pw.print("<=");
                if (r.adjSource instanceof ProcessRecord) {
                    pw.print("Proc{");
                    pw.print(((ProcessRecord) r.adjSource).toShortString());
                    pw.println("}");
                } else if (r.adjSource != null) {
                    pw.println(r.adjSource.toString());
                } else {
                    pw.println("{null}");
                }
            }
            if (inclDetails) {
                pw.print(prefix);
                pw.print("    ");
                pw.print("oom: max=");
                pw.print(r.maxAdj);
                pw.print(" curRaw=");
                pw.print(r.curRawAdj);
                pw.print(" setRaw=");
                pw.print(r.setRawAdj);
                pw.print(" cur=");
                pw.print(r.curAdj);
                pw.print(" set=");
                pw.println(r.setAdj);
                pw.print(prefix);
                pw.print("    ");
                pw.print("state: cur=");
                pw.print(ProcessList.makeProcStateString(r.curProcState));
                pw.print(" set=");
                pw.print(ProcessList.makeProcStateString(r.setProcState));
                pw.print(" lastPss=");
                DebugUtils.printSizeValue(pw, r.lastPss * 1024);
                pw.print(" lastSwapPss=");
                DebugUtils.printSizeValue(pw, r.lastSwapPss * 1024);
                pw.print(" lastCachedPss=");
                DebugUtils.printSizeValue(pw, r.lastCachedPss * 1024);
                pw.println();
                pw.print(prefix);
                pw.print("    ");
                pw.print("cached=");
                pw.print(r.cached);
                pw.print(" empty=");
                pw.print(r.empty);
                pw.print(" hasAboveClient=");
                pw.println(r.hasAboveClient);
                if (r.setProcState >= 9 && r.lastCpuTime != 0) {
                    list = list2;
                    curUptime = curUptime2;
                    long timeUsed = r.curCpuTime - r.lastCpuTime;
                    pw.print(prefix);
                    pw.print("    ");
                    pw.print("run cpu over ");
                    TimeUtils.formatDuration(uptimeSince, pw);
                    pw.print(" used ");
                    TimeUtils.formatDuration(timeUsed, pw);
                    pw.print(" (");
                    pw.print((100 * timeUsed) / uptimeSince);
                    pw.println("%)");
                    i--;
                    list2 = list;
                    curUptime2 = curUptime;
                }
            }
            list = list2;
            curUptime = curUptime2;
            i--;
            list2 = list;
            curUptime2 = curUptime;
        }
        return true;
    }

    ArrayList<ProcessRecord> collectProcesses(PrintWriter pw, int start, boolean allPkgs, String[] args) {
        ArrayList<ProcessRecord> procs;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (args != null && args.length > start && args[start].charAt(0) != '-') {
                    procs = new ArrayList<>();
                    int pid = -1;
                    try {
                        pid = Integer.parseInt(args[start]);
                    } catch (NumberFormatException e) {
                    }
                    for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord proc = this.mLruProcesses.get(i);
                        if (proc.pid > 0 && proc.pid == pid) {
                            procs.add(proc);
                        } else if (allPkgs && proc.pkgList != null && proc.pkgList.containsKey(args[start])) {
                            procs.add(proc);
                        } else if (proc.processName.equals(args[start])) {
                            procs.add(proc);
                        }
                    }
                    int i2 = procs.size();
                    if (i2 <= 0) {
                        resetPriorityAfterLockedSection();
                        return null;
                    }
                } else {
                    procs = new ArrayList<>(this.mLruProcesses);
                }
                resetPriorityAfterLockedSection();
                return procs;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    final void dumpGraphicsHardwareUsage(FileDescriptor fd, PrintWriter pw, String[] args) {
        ArrayList<ProcessRecord> procs = collectProcesses(pw, 0, false, args);
        if (procs == null) {
            pw.println("No process found for: " + args[0]);
            return;
        }
        long uptime = SystemClock.uptimeMillis();
        long realtime = SystemClock.elapsedRealtime();
        pw.println("Applications Graphics Acceleration Info:");
        pw.println("Uptime: " + uptime + " Realtime: " + realtime);
        for (int i = procs.size() + (-1); i >= 0; i--) {
            ProcessRecord r = procs.get(i);
            if (r.thread != null) {
                pw.println("\n** Graphics info for pid " + r.pid + " [" + r.processName + "] **");
                pw.flush();
                try {
                    TransferPipe tp = new TransferPipe();
                    try {
                        r.thread.dumpGfxInfo(tp.getWriteFd(), args);
                        tp.go(fd);
                        tp.kill();
                    } catch (Throwable th) {
                        tp.kill();
                        throw th;
                        break;
                    }
                } catch (RemoteException e) {
                    pw.println("Got a RemoteException while dumping the app " + r);
                    pw.flush();
                } catch (IOException e2) {
                    pw.println("Failure while dumping the app: " + r);
                    pw.flush();
                }
            }
        }
    }

    final void dumpDbInfo(FileDescriptor fd, PrintWriter pw, String[] args) {
        ArrayList<ProcessRecord> procs = collectProcesses(pw, 0, false, args);
        if (procs == null) {
            pw.println("No process found for: " + args[0]);
            return;
        }
        pw.println("Applications Database Info:");
        for (int i = procs.size() - 1; i >= 0; i--) {
            ProcessRecord r = procs.get(i);
            if (r.thread != null) {
                pw.println("\n** Database info for pid " + r.pid + " [" + r.processName + "] **");
                pw.flush();
                try {
                    TransferPipe tp = new TransferPipe();
                    try {
                        r.thread.dumpDbInfo(tp.getWriteFd(), args);
                        tp.go(fd);
                        tp.kill();
                    } catch (Throwable th) {
                        tp.kill();
                        throw th;
                        break;
                    }
                } catch (RemoteException e) {
                    pw.println("Got a RemoteException while dumping the app " + r);
                    pw.flush();
                } catch (IOException e2) {
                    pw.println("Failure while dumping the app: " + r);
                    pw.flush();
                }
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* loaded from: classes.dex */
    public static final class MemItem {
        final boolean hasActivities;
        final int id;
        final boolean isProc;
        final String label;
        final long pss;
        final String shortLabel;
        ArrayList<MemItem> subitems;
        final long swapPss;

        public MemItem(String _label, String _shortLabel, long _pss, long _swapPss, int _id, boolean _hasActivities) {
            this.isProc = true;
            this.label = _label;
            this.shortLabel = _shortLabel;
            this.pss = _pss;
            this.swapPss = _swapPss;
            this.id = _id;
            this.hasActivities = _hasActivities;
        }

        public MemItem(String _label, String _shortLabel, long _pss, long _swapPss, int _id) {
            this.isProc = false;
            this.label = _label;
            this.shortLabel = _shortLabel;
            this.pss = _pss;
            this.swapPss = _swapPss;
            this.id = _id;
            this.hasActivities = false;
        }
    }

    private static void sortMemItems(List<MemItem> items) {
        Collections.sort(items, new Comparator<MemItem>() { // from class: com.android.server.am.ActivityManagerService.25
            @Override // java.util.Comparator
            public int compare(MemItem lhs, MemItem rhs) {
                if (lhs.pss < rhs.pss) {
                    return 1;
                }
                if (lhs.pss > rhs.pss) {
                    return -1;
                }
                return 0;
            }
        });
    }

    static final void dumpMemItems(PrintWriter pw, String prefix, String tag, ArrayList<MemItem> items, boolean sort, boolean isCompact, boolean dumpSwapPss) {
        int i;
        if (sort && !isCompact) {
            sortMemItems(items);
        }
        char c = 0;
        int i2 = 0;
        while (true) {
            int i3 = i2;
            int i4 = items.size();
            if (i3 >= i4) {
                return;
            }
            MemItem mi = items.get(i3);
            if (isCompact) {
                i = i3;
                if (mi.isProc) {
                    pw.print("proc,");
                    pw.print(tag);
                    pw.print(",");
                    pw.print(mi.shortLabel);
                    pw.print(",");
                    pw.print(mi.id);
                    pw.print(",");
                    pw.print(mi.pss);
                    pw.print(",");
                    pw.print(dumpSwapPss ? Long.valueOf(mi.swapPss) : "N/A");
                    pw.println(mi.hasActivities ? ",a" : ",e");
                } else {
                    pw.print(tag);
                    pw.print(",");
                    pw.print(mi.shortLabel);
                    pw.print(",");
                    pw.print(mi.pss);
                    pw.print(",");
                    pw.println(dumpSwapPss ? Long.valueOf(mi.swapPss) : "N/A");
                }
            } else if (dumpSwapPss) {
                Object[] objArr = new Object[4];
                objArr[c] = prefix;
                i = i3;
                objArr[1] = stringifyKBSize(mi.pss);
                objArr[2] = mi.label;
                objArr[3] = stringifyKBSize(mi.swapPss);
                pw.printf("%s%s: %-60s (%s in swap)\n", objArr);
                c = 0;
            } else {
                i = i3;
                c = 0;
                pw.printf("%s%s: %s\n", prefix, stringifyKBSize(mi.pss), mi.label);
            }
            if (mi.subitems != null) {
                dumpMemItems(pw, prefix + "    ", mi.shortLabel, mi.subitems, true, isCompact, dumpSwapPss);
            }
            i2 = i + 1;
        }
    }

    static final void dumpMemItems(ProtoOutputStream proto, long fieldId, String tag, ArrayList<MemItem> items, boolean sort, boolean dumpSwapPss) {
        if (sort) {
            sortMemItems(items);
        }
        int i = 0;
        while (true) {
            int i2 = i;
            int i3 = items.size();
            if (i2 >= i3) {
                return;
            }
            MemItem mi = items.get(i2);
            long token = proto.start(fieldId);
            proto.write(1138166333441L, tag);
            proto.write(1138166333442L, mi.shortLabel);
            proto.write(1133871366148L, mi.isProc);
            proto.write(1120986464259L, mi.id);
            proto.write(1133871366149L, mi.hasActivities);
            proto.write(1112396529670L, mi.pss);
            if (dumpSwapPss) {
                proto.write(1112396529671L, mi.swapPss);
            }
            if (mi.subitems != null) {
                dumpMemItems(proto, 2246267895816L, mi.shortLabel, mi.subitems, true, dumpSwapPss);
            }
            proto.end(token);
            i = i2 + 1;
        }
    }

    static final void appendMemBucket(StringBuilder out, long memKB, String label, boolean stackLike) {
        int start = label.lastIndexOf(46);
        int start2 = start >= 0 ? start + 1 : 0;
        int end = label.length();
        for (int i = 0; i < DUMP_MEM_BUCKETS.length; i++) {
            if (DUMP_MEM_BUCKETS[i] >= memKB) {
                long bucket = DUMP_MEM_BUCKETS[i] / 1024;
                out.append(bucket);
                out.append(stackLike ? "MB." : "MB ");
                out.append((CharSequence) label, start2, end);
                return;
            }
        }
        out.append(memKB / 1024);
        out.append(stackLike ? "MB." : "MB ");
        out.append((CharSequence) label, start2, end);
    }

    private final void dumpApplicationMemoryUsageHeader(PrintWriter pw, long uptime, long realtime, boolean isCheckinRequest, boolean isCompact) {
        if (isCompact) {
            pw.print("version,");
            pw.println(1);
        }
        if (isCheckinRequest || isCompact) {
            pw.print("time,");
            pw.print(uptime);
            pw.print(",");
            pw.println(realtime);
            return;
        }
        pw.println("Applications Memory Usage (in Kilobytes):");
        pw.println("Uptime: " + uptime + " Realtime: " + realtime);
    }

    private final long[] getKsmInfo() {
        int[] SINGLE_LONG_FORMAT = {8224};
        Process.readProcFile("/sys/kernel/mm/ksm/pages_shared", SINGLE_LONG_FORMAT, null, longTmp, null);
        long[] longTmp = {0};
        Process.readProcFile("/sys/kernel/mm/ksm/pages_sharing", SINGLE_LONG_FORMAT, null, longTmp, null);
        longTmp[0] = 0;
        Process.readProcFile("/sys/kernel/mm/ksm/pages_unshared", SINGLE_LONG_FORMAT, null, longTmp, null);
        longTmp[0] = 0;
        Process.readProcFile("/sys/kernel/mm/ksm/pages_volatile", SINGLE_LONG_FORMAT, null, longTmp, null);
        long[] longOut = {(longTmp[0] * 4096) / 1024, (longTmp[0] * 4096) / 1024, (longTmp[0] * 4096) / 1024, (longTmp[0] * 4096) / 1024};
        return longOut;
    }

    private static String stringifySize(long size, int order) {
        Locale locale = Locale.US;
        if (order != 1) {
            if (order != 1024) {
                if (order != 1048576) {
                    if (order == 1073741824) {
                        return String.format(locale, "%,1dG", Long.valueOf(((size / 1024) / 1024) / 1024));
                    }
                    throw new IllegalArgumentException("Invalid size order");
                }
                return String.format(locale, "%,5dM", Long.valueOf((size / 1024) / 1024));
            }
            return String.format(locale, "%,9dK", Long.valueOf(size / 1024));
        }
        return String.format(locale, "%,13d", Long.valueOf(size));
    }

    private static String stringifyKBSize(long size) {
        return stringifySize(1024 * size, 1024);
    }

    /* JADX INFO: Access modifiers changed from: private */
    /* loaded from: classes.dex */
    public static class MemoryUsageDumpOptions {
        boolean dumpDalvik;
        boolean dumpDetails;
        boolean dumpFullDetails;
        boolean dumpProto;
        boolean dumpSummaryOnly;
        boolean dumpSwapPss;
        boolean dumpUnreachable;
        boolean isCheckinRequest;
        boolean isCompact;
        boolean localOnly;
        boolean oomOnly;
        boolean packages;

        private MemoryUsageDumpOptions() {
        }
    }

    /* JADX WARN: Code restructure failed: missing block: B:52:0x014d, code lost:
        if (r0.dumpProto == false) goto L68;
     */
    /* JADX WARN: Code restructure failed: missing block: B:53:0x014f, code lost:
        dumpApplicationMemoryUsage(r18, r0, r14, r22, r16);
     */
    /* JADX WARN: Code restructure failed: missing block: B:54:0x015c, code lost:
        dumpApplicationMemoryUsage(r18, r19, r20, r0, r14, r22, r16, r23);
     */
    /* JADX WARN: Code restructure failed: missing block: B:55:0x016d, code lost:
        return;
     */
    /* JADX WARN: Code restructure failed: missing block: B:73:?, code lost:
        return;
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    final void dumpApplicationMemoryUsage(java.io.FileDescriptor r18, java.io.PrintWriter r19, java.lang.String r20, java.lang.String[] r21, boolean r22, java.io.PrintWriter r23, boolean r24) {
        /*
            Method dump skipped, instructions count: 366
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.dumpApplicationMemoryUsage(java.io.FileDescriptor, java.io.PrintWriter, java.lang.String, java.lang.String[], boolean, java.io.PrintWriter, boolean):void");
    }

    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Removed duplicated region for block: B:114:0x02c7  */
    /* JADX WARN: Removed duplicated region for block: B:152:0x03a5  */
    /* JADX WARN: Removed duplicated region for block: B:265:0x06df A[Catch: all -> 0x0794, TRY_LEAVE, TryCatch #23 {all -> 0x0794, blocks: (B:262:0x0686, B:263:0x06dc, B:265:0x06df), top: B:478:0x0686 }] */
    /* JADX WARN: Removed duplicated region for block: B:275:0x0742 A[Catch: all -> 0x077c, LOOP:12: B:273:0x073e->B:275:0x0742, LOOP_END, TryCatch #13 {all -> 0x077c, blocks: (B:269:0x0701, B:272:0x072a, B:275:0x0742, B:276:0x075d, B:278:0x076c, B:279:0x0773), top: B:458:0x0701 }] */
    /* JADX WARN: Removed duplicated region for block: B:278:0x076c A[Catch: all -> 0x077c, TryCatch #13 {all -> 0x077c, blocks: (B:269:0x0701, B:272:0x072a, B:275:0x0742, B:276:0x075d, B:278:0x076c, B:279:0x0773), top: B:458:0x0701 }] */
    /* JADX WARN: Removed duplicated region for block: B:380:0x0a48  */
    /* JADX WARN: Removed duplicated region for block: B:391:0x0b06  */
    /* JADX WARN: Removed duplicated region for block: B:394:0x0b2c  */
    /* JADX WARN: Removed duplicated region for block: B:395:0x0b72  */
    /* JADX WARN: Removed duplicated region for block: B:397:0x0b7f  */
    /* JADX WARN: Removed duplicated region for block: B:444:0x03d2 A[EXC_TOP_SPLITTER, SYNTHETIC] */
    /* JADX WARN: Removed duplicated region for block: B:537:? A[RETURN, SYNTHETIC] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    private final void dumpApplicationMemoryUsage(java.io.FileDescriptor r106, java.io.PrintWriter r107, java.lang.String r108, com.android.server.am.ActivityManagerService.MemoryUsageDumpOptions r109, java.lang.String[] r110, boolean r111, java.util.ArrayList<com.android.server.am.ProcessRecord> r112, java.io.PrintWriter r113) {
        /*
            Method dump skipped, instructions count: 3454
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.dumpApplicationMemoryUsage(java.io.FileDescriptor, java.io.PrintWriter, java.lang.String, com.android.server.am.ActivityManagerService$MemoryUsageDumpOptions, java.lang.String[], boolean, java.util.ArrayList, java.io.PrintWriter):void");
    }

    /*  JADX ERROR: IndexOutOfBoundsException in pass: SSATransform
        java.lang.IndexOutOfBoundsException: bitIndex < 0: -124
        	at java.base/java.util.BitSet.get(BitSet.java:626)
        	at jadx.core.dex.visitors.ssa.LiveVarAnalysis.fillBasicBlockInfo(LiveVarAnalysis.java:65)
        	at jadx.core.dex.visitors.ssa.LiveVarAnalysis.runAnalysis(LiveVarAnalysis.java:36)
        	at jadx.core.dex.visitors.ssa.SSATransform.process(SSATransform.java:55)
        	at jadx.core.dex.visitors.ssa.SSATransform.visit(SSATransform.java:41)
        */
    private final void dumpApplicationMemoryUsage(java.io.FileDescriptor r129, com.android.server.am.ActivityManagerService.MemoryUsageDumpOptions r130, java.lang.String[] r131, boolean r132, java.util.ArrayList<com.android.server.am.ProcessRecord> r133) {
        /*
            Method dump skipped, instructions count: 3086
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.dumpApplicationMemoryUsage(java.io.FileDescriptor, com.android.server.am.ActivityManagerService$MemoryUsageDumpOptions, java.lang.String[], boolean, java.util.ArrayList):void");
    }

    private void appendBasicMemEntry(StringBuilder sb, int oomAdj, int procState, long pss, long memtrack, String name) {
        sb.append("  ");
        sb.append(ProcessList.makeOomAdjString(oomAdj));
        sb.append(' ');
        sb.append(ProcessList.makeProcStateString(procState));
        sb.append(' ');
        ProcessList.appendRamKb(sb, pss);
        sb.append(": ");
        sb.append(name);
        if (memtrack > 0) {
            sb.append(" (");
            sb.append(stringifyKBSize(memtrack));
            sb.append(" memtrack)");
        }
    }

    private void appendMemInfo(StringBuilder sb, ProcessMemInfo mi) {
        appendBasicMemEntry(sb, mi.oomAdj, mi.procState, mi.pss, mi.memtrack, mi.name);
        sb.append(" (pid ");
        sb.append(mi.pid);
        sb.append(") ");
        sb.append(mi.adjType);
        sb.append('\n');
        if (mi.adjReason != null) {
            sb.append("                      ");
            sb.append(mi.adjReason);
            sb.append('\n');
        }
    }

    void reportMemUsage(ArrayList<ProcessMemInfo> memInfos) {
        List<ProcessCpuTracker.Stats> stats;
        long totalMemtrack;
        long totalPss;
        int N;
        ProcessMemInfo mi;
        StringBuilder tag;
        StringBuilder stack;
        StringBuilder shortNativeBuilder;
        int statsCount;
        List<ProcessCpuTracker.Stats> stats2;
        int lastOomAdj;
        SparseArray<ProcessMemInfo> infoMap;
        long totalMemtrack2;
        long totalPss2;
        boolean z;
        StringBuilder fullNativeBuilder;
        StringBuilder fullJavaBuilder;
        StringBuilder fullJavaBuilder2;
        ArrayList<ProcessMemInfo> arrayList = memInfos;
        SparseArray<ProcessMemInfo> infoMap2 = new SparseArray<>(memInfos.size());
        int N2 = memInfos.size();
        for (int i = 0; i < N2; i++) {
            ProcessMemInfo mi2 = arrayList.get(i);
            infoMap2.put(mi2.pid, mi2);
        }
        updateCpuStatsNow();
        long[] memtrackTmp = new long[1];
        synchronized (this.mProcessCpuTracker) {
            try {
                stats = this.mProcessCpuTracker.getStats(new ProcessCpuTracker.FilterStats() { // from class: com.android.server.am.-$$Lambda$ActivityManagerService$dLQ66dH4nIti4hweaVJTGHj2tMU
                    public final boolean needed(ProcessCpuTracker.Stats stats3) {
                        return ActivityManagerService.lambda$reportMemUsage$4(stats3);
                    }
                });
            } catch (Throwable th) {
                th = th;
                while (true) {
                    try {
                        break;
                    } catch (Throwable th2) {
                        th = th2;
                    }
                }
                throw th;
            }
        }
        int statsCount2 = stats.size();
        boolean z2 = false;
        for (int i2 = 0; i2 < statsCount2; i2++) {
            ProcessCpuTracker.Stats st = stats.get(i2);
            long pss = Debug.getPss(st.pid, null, memtrackTmp);
            if (pss > 0 && infoMap2.indexOfKey(st.pid) < 0) {
                ProcessMemInfo mi3 = new ProcessMemInfo(st.name, st.pid, JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -1, "native", null);
                mi3.pss = pss;
                mi3.memtrack = memtrackTmp[0];
                arrayList.add(mi3);
            }
        }
        int i3 = 0;
        int N3 = memInfos.size();
        long totalPss3 = 0;
        long totalMemtrack3 = 0;
        while (i3 < N3) {
            ProcessMemInfo mi4 = arrayList.get(i3);
            int i4 = i3;
            if (mi4.pss == 0) {
                mi4.pss = Debug.getPss(mi4.pid, null, memtrackTmp);
                mi4.memtrack = memtrackTmp[0];
            }
            totalMemtrack3 += mi4.pss;
            totalPss3 += mi4.memtrack;
            i3 = i4 + 1;
        }
        Collections.sort(arrayList, new Comparator<ProcessMemInfo>() { // from class: com.android.server.am.ActivityManagerService.26
            @Override // java.util.Comparator
            public int compare(ProcessMemInfo lhs, ProcessMemInfo rhs) {
                if (lhs.oomAdj != rhs.oomAdj) {
                    return lhs.oomAdj < rhs.oomAdj ? -1 : 1;
                } else if (lhs.pss != rhs.pss) {
                    return lhs.pss < rhs.pss ? 1 : -1;
                } else {
                    return 0;
                }
            }
        });
        StringBuilder tag2 = new StringBuilder(128);
        StringBuilder stack2 = new StringBuilder(128);
        tag2.append("Low on memory -- ");
        appendMemBucket(tag2, totalMemtrack3, "total", false);
        appendMemBucket(stack2, totalMemtrack3, "total", true);
        StringBuilder fullNativeBuilder2 = new StringBuilder(1024);
        StringBuilder shortNativeBuilder2 = new StringBuilder(1024);
        StringBuilder fullJavaBuilder3 = new StringBuilder(1024);
        long extraNativeRam = 0;
        long extraNativeMemtrack = 0;
        long cachedPss = 0;
        int N4 = memInfos.size();
        int lastOomAdj2 = Integer.MIN_VALUE;
        boolean firstLine = true;
        int i5 = 0;
        while (true) {
            int N5 = N4;
            totalMemtrack = totalPss3;
            if (i5 >= N5) {
                break;
            }
            ProcessMemInfo mi5 = arrayList.get(i5);
            if (mi5.oomAdj >= 900) {
                totalPss = totalMemtrack3;
                long totalPss4 = mi5.pss;
                cachedPss += totalPss4;
            } else {
                totalPss = totalMemtrack3;
            }
            if (mi5.oomAdj != -1000 && (mi5.oomAdj < 500 || mi5.oomAdj == 600 || mi5.oomAdj == 700)) {
                if (lastOomAdj2 != mi5.oomAdj) {
                    lastOomAdj2 = mi5.oomAdj;
                    if (mi5.oomAdj <= 0) {
                        tag2.append(" / ");
                    }
                    if (mi5.oomAdj >= 0) {
                        if (firstLine) {
                            stack2.append(":");
                            firstLine = false;
                        }
                        stack2.append("\n\t at ");
                    } else {
                        stack2.append("$");
                    }
                } else {
                    tag2.append(" ");
                    stack2.append("$");
                }
                if (mi5.oomAdj <= 0) {
                    appendMemBucket(tag2, mi5.pss, mi5.name, false);
                }
                appendMemBucket(stack2, mi5.pss, mi5.name, true);
                if (mi5.oomAdj >= 0 && (i5 + 1 >= N5 || arrayList.get(i5 + 1).oomAdj != lastOomAdj2)) {
                    stack2.append("(");
                    for (int k = 0; k < DUMP_MEM_OOM_ADJ.length; k++) {
                        if (DUMP_MEM_OOM_ADJ[k] == mi5.oomAdj) {
                            stack2.append(DUMP_MEM_OOM_LABEL[k]);
                            stack2.append(":");
                            stack2.append(DUMP_MEM_OOM_ADJ[k]);
                        }
                    }
                    stack2.append(")");
                }
            }
            appendMemInfo(fullNativeBuilder2, mi5);
            if (mi5.oomAdj == -1000) {
                if (mi5.pss >= 512) {
                    fullJavaBuilder2 = shortNativeBuilder2;
                    appendMemInfo(fullJavaBuilder2, mi5);
                } else {
                    fullJavaBuilder2 = shortNativeBuilder2;
                    extraNativeRam += mi5.pss;
                    extraNativeMemtrack += mi5.memtrack;
                }
                N = N5;
                tag = tag2;
                stack = stack2;
                shortNativeBuilder = fullJavaBuilder2;
                statsCount = statsCount2;
                stats2 = stats;
                lastOomAdj = lastOomAdj2;
                infoMap = infoMap2;
                fullJavaBuilder = fullJavaBuilder3;
                totalMemtrack2 = totalMemtrack;
                totalPss2 = totalPss;
                z = false;
                fullNativeBuilder = fullNativeBuilder2;
            } else {
                StringBuilder shortNativeBuilder3 = shortNativeBuilder2;
                if (extraNativeRam > 0) {
                    lastOomAdj = lastOomAdj2;
                    fullNativeBuilder = fullNativeBuilder2;
                    N = N5;
                    statsCount = statsCount2;
                    stats2 = stats;
                    totalMemtrack2 = totalMemtrack;
                    mi = mi5;
                    totalPss2 = totalPss;
                    tag = tag2;
                    stack = stack2;
                    shortNativeBuilder = shortNativeBuilder3;
                    infoMap = infoMap2;
                    z = false;
                    appendBasicMemEntry(shortNativeBuilder3, JobSchedulerShellCommand.CMD_ERR_NO_PACKAGE, -1, extraNativeRam, extraNativeMemtrack, "(Other native)");
                    shortNativeBuilder.append('\n');
                    extraNativeRam = 0;
                } else {
                    N = N5;
                    mi = mi5;
                    tag = tag2;
                    stack = stack2;
                    shortNativeBuilder = shortNativeBuilder3;
                    statsCount = statsCount2;
                    stats2 = stats;
                    lastOomAdj = lastOomAdj2;
                    infoMap = infoMap2;
                    totalMemtrack2 = totalMemtrack;
                    totalPss2 = totalPss;
                    z = false;
                    fullNativeBuilder = fullNativeBuilder2;
                }
                fullJavaBuilder = fullJavaBuilder3;
                appendMemInfo(fullJavaBuilder, mi);
            }
            i5++;
            fullJavaBuilder3 = fullJavaBuilder;
            totalPss3 = totalMemtrack2;
            fullNativeBuilder2 = fullNativeBuilder;
            z2 = z;
            N4 = N;
            lastOomAdj2 = lastOomAdj;
            stats = stats2;
            statsCount2 = statsCount;
            totalMemtrack3 = totalPss2;
            tag2 = tag;
            stack2 = stack;
            infoMap2 = infoMap;
            shortNativeBuilder2 = shortNativeBuilder;
            arrayList = memInfos;
        }
        long totalPss5 = totalMemtrack3;
        StringBuilder tag3 = tag2;
        StringBuilder stack3 = stack2;
        StringBuilder shortNativeBuilder4 = shortNativeBuilder2;
        StringBuilder fullNativeBuilder3 = fullNativeBuilder2;
        int i6 = z2;
        StringBuilder fullJavaBuilder4 = fullJavaBuilder3;
        fullJavaBuilder4.append("           ");
        ProcessList.appendRamKb(fullJavaBuilder4, totalPss5);
        fullJavaBuilder4.append(": TOTAL");
        if (totalMemtrack > 0) {
            fullJavaBuilder4.append(" (");
            fullJavaBuilder4.append(stringifyKBSize(totalMemtrack));
            fullJavaBuilder4.append(" memtrack)");
        }
        fullJavaBuilder4.append("\n");
        MemInfoReader memInfo = new MemInfoReader();
        memInfo.readMemInfo();
        long[] infos = memInfo.getRawInfo();
        StringBuilder memInfoBuilder = new StringBuilder(1024);
        Debug.getMemInfo(infos);
        memInfoBuilder.append("  MemInfo: ");
        memInfoBuilder.append(stringifyKBSize(infos[5]));
        memInfoBuilder.append(" slab, ");
        memInfoBuilder.append(stringifyKBSize(infos[4]));
        memInfoBuilder.append(" shmem, ");
        memInfoBuilder.append(stringifyKBSize(infos[12]));
        memInfoBuilder.append(" vm alloc, ");
        memInfoBuilder.append(stringifyKBSize(infos[13]));
        memInfoBuilder.append(" page tables ");
        memInfoBuilder.append(stringifyKBSize(infos[14]));
        memInfoBuilder.append(" kernel stack\n");
        memInfoBuilder.append("           ");
        memInfoBuilder.append(stringifyKBSize(infos[2]));
        memInfoBuilder.append(" buffers, ");
        long totalMemtrack4 = infos[3];
        memInfoBuilder.append(stringifyKBSize(totalMemtrack4));
        memInfoBuilder.append(" cached, ");
        memInfoBuilder.append(stringifyKBSize(infos[11]));
        memInfoBuilder.append(" mapped, ");
        memInfoBuilder.append(stringifyKBSize(infos[1]));
        memInfoBuilder.append(" free\n");
        if (infos[10] != 0) {
            memInfoBuilder.append("  ZRAM: ");
            memInfoBuilder.append(stringifyKBSize(infos[10]));
            memInfoBuilder.append(" RAM, ");
            memInfoBuilder.append(stringifyKBSize(infos[8]));
            memInfoBuilder.append(" swap total, ");
            memInfoBuilder.append(stringifyKBSize(infos[9]));
            memInfoBuilder.append(" swap free\n");
        }
        long[] ksm = getKsmInfo();
        if (ksm[1] != 0 || ksm[i6] != 0 || ksm[2] != 0 || ksm[3] != 0) {
            memInfoBuilder.append("  KSM: ");
            memInfoBuilder.append(stringifyKBSize(ksm[1]));
            memInfoBuilder.append(" saved from shared ");
            memInfoBuilder.append(stringifyKBSize(ksm[i6]));
            memInfoBuilder.append("\n       ");
            memInfoBuilder.append(stringifyKBSize(ksm[2]));
            memInfoBuilder.append(" unshared; ");
            memInfoBuilder.append(stringifyKBSize(ksm[3]));
            memInfoBuilder.append(" volatile\n");
        }
        memInfoBuilder.append("  Free RAM: ");
        memInfoBuilder.append(stringifyKBSize(cachedPss + memInfo.getCachedSizeKb() + memInfo.getFreeSizeKb()));
        memInfoBuilder.append("\n");
        memInfoBuilder.append("  Used RAM: ");
        memInfoBuilder.append(stringifyKBSize((totalPss5 - cachedPss) + memInfo.getKernelUsedSizeKb()));
        memInfoBuilder.append("\n");
        memInfoBuilder.append("  Lost RAM: ");
        memInfoBuilder.append(stringifyKBSize(((((memInfo.getTotalSizeKb() - totalPss5) - memInfo.getFreeSizeKb()) - memInfo.getCachedSizeKb()) - memInfo.getKernelUsedSizeKb()) - memInfo.getZramTotalSizeKb()));
        memInfoBuilder.append("\n");
        Slog.i("ActivityManager", "Low on memory:");
        Slog.i("ActivityManager", shortNativeBuilder4.toString());
        Slog.i("ActivityManager", fullJavaBuilder4.toString());
        Slog.i("ActivityManager", memInfoBuilder.toString());
        StringBuilder dropBuilder = new StringBuilder(1024);
        dropBuilder.append("Low on memory:");
        dropBuilder.append((CharSequence) stack3);
        dropBuilder.append('\n');
        dropBuilder.append((CharSequence) fullNativeBuilder3);
        dropBuilder.append((CharSequence) fullJavaBuilder4);
        dropBuilder.append('\n');
        dropBuilder.append((CharSequence) memInfoBuilder);
        dropBuilder.append('\n');
        StringWriter catSw = new StringWriter();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                FastPrintWriter fastPrintWriter = new FastPrintWriter(catSw, i6, 256);
                String[] emptyArgs = new String[i6];
                fastPrintWriter.println();
                try {
                    dumpProcessesLocked(null, fastPrintWriter, emptyArgs, 0, false, null, -1);
                    fastPrintWriter.println();
                    this.mServices.newServiceDumperLocked(null, fastPrintWriter, emptyArgs, 0, false, null).dumpLocked();
                    fastPrintWriter.println();
                    try {
                        dumpActivitiesLocked(null, fastPrintWriter, emptyArgs, 0, false, false, null);
                        fastPrintWriter.flush();
                        resetPriorityAfterLockedSection();
                        dropBuilder.append(catSw.toString());
                        StatsLog.write(81);
                        addErrorToDropBox("lowmem", null, "system_server", null, null, tag3.toString(), dropBuilder.toString(), null, null);
                        synchronized (this) {
                            try {
                                boostPriorityForLockedSection();
                                long now = SystemClock.uptimeMillis();
                                if (this.mLastMemUsageReportTime < now) {
                                    this.mLastMemUsageReportTime = now;
                                }
                            } finally {
                                resetPriorityAfterLockedSection();
                            }
                        }
                        resetPriorityAfterLockedSection();
                    } catch (Throwable th3) {
                        th = th3;
                        while (true) {
                            try {
                                break;
                            } catch (Throwable th4) {
                                th = th4;
                            }
                        }
                        throw th;
                    }
                } catch (Throwable th5) {
                    th = th5;
                }
            } catch (Throwable th6) {
                th = th6;
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public static /* synthetic */ boolean lambda$reportMemUsage$4(ProcessCpuTracker.Stats st) {
        return st.vsize > 0;
    }

    private static boolean scanArgs(String[] args, String value) {
        if (args != null) {
            for (String arg : args) {
                if (value.equals(arg)) {
                    return true;
                }
            }
        }
        return false;
    }

    private final boolean removeDyingProviderLocked(ProcessRecord proc, ContentProviderRecord cpr, boolean always) {
        boolean inLaunching = this.mLaunchingProviders.contains(cpr);
        if (!inLaunching || always) {
            synchronized (cpr) {
                cpr.launchingApp = null;
                cpr.notifyAll();
            }
            this.mProviderMap.removeProviderByClass(cpr.name, UserHandle.getUserId(cpr.uid));
            String[] names = cpr.info.authority.split(";");
            for (String str : names) {
                this.mProviderMap.removeProviderByName(str, UserHandle.getUserId(cpr.uid));
            }
        }
        for (int i = cpr.connections.size() - 1; i >= 0; i--) {
            ContentProviderConnection conn = cpr.connections.get(i);
            if (!conn.waiting || !inLaunching || always) {
                ProcessRecord capp = conn.client;
                conn.dead = true;
                if (conn.stableCount > 0) {
                    if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
                        if (cpr.name != null && cpr.name.getClassName() != null && cpr.name.getClassName().contains("ApiPublisherProvider")) {
                            StringBuilder sb = new StringBuilder();
                            sb.append("depends on provider ");
                            sb.append(cpr.name.flattenToShortString());
                            sb.append(" client ");
                            sb.append(proc != null ? proc.processName : "??");
                            sb.append(" keep alive");
                            Log.d("ActivityManager", sb.toString());
                        } else {
                            StringBuilder sb2 = new StringBuilder();
                            sb2.append("depends on provider ");
                            sb2.append(cpr.name.flattenToShortString());
                            sb2.append(" in dying proc ");
                            sb2.append(proc != null ? proc.processName : "??");
                            sb2.append(" (adj ");
                            sb2.append(proc != null ? Integer.valueOf(proc.setAdj) : "??");
                            sb2.append(")");
                            capp.kill(sb2.toString(), true);
                        }
                    }
                } else if (capp.thread != null && conn.provider.provider != null) {
                    try {
                        capp.thread.unstableProviderDied(conn.provider.provider.asBinder());
                    } catch (RemoteException e) {
                    }
                    cpr.connections.remove(i);
                    if (conn.client.conProviders.remove(conn)) {
                        stopAssociationLocked(capp.uid, capp.processName, cpr.uid, cpr.name);
                    }
                }
            }
        }
        if (inLaunching && always) {
            this.mLaunchingProviders.remove(cpr);
        }
        return inLaunching;
    }

    @GuardedBy("this")
    private final boolean cleanUpApplicationRecordLocked(final ProcessRecord app, boolean restarting, boolean allowRestart, int index, boolean replacingPid) {
        if (index >= 0) {
            removeLruProcessLocked(app);
            ProcessList.remove(app.pid);
        }
        this.mProcessesToGc.remove(app);
        this.mPendingPssProcesses.remove(app);
        ProcessList.abortNextPssTime(app.procStateMemTracker);
        if (app.crashDialog != null && !app.forceCrashReport) {
            app.crashDialog.dismiss();
            app.crashDialog = null;
        }
        if (app.anrDialog != null) {
            app.anrDialog.dismiss();
            app.anrDialog = null;
        }
        if (app.waitDialog != null) {
            app.waitDialog.dismiss();
            app.waitDialog = null;
        }
        app.crashing = false;
        app.notResponding = false;
        app.resetPackageList(this.mProcessStats);
        app.unlinkDeathRecipient();
        app.makeInactive(this.mProcessStats);
        app.waitingToKill = null;
        app.forcingToImportant = null;
        updateProcessForegroundLocked(app, false, false);
        app.foregroundActivities = false;
        app.hasShownUi = false;
        app.treatLikeActivity = false;
        app.hasAboveClient = false;
        app.hasClientActivities = false;
        this.mServices.killServicesLocked(app, allowRestart);
        boolean restart = false;
        for (int i = app.pubProviders.size() - 1; i >= 0; i--) {
            ContentProviderRecord cpr = app.pubProviders.valueAt(i);
            boolean always = app.bad || !allowRestart;
            boolean inLaunching = removeDyingProviderLocked(app, cpr, always);
            if ((inLaunching || always) && cpr.hasConnectionOrHandle()) {
                restart = true;
            }
            cpr.provider = null;
            cpr.proc = null;
        }
        app.pubProviders.clear();
        if (cleanupAppInLaunchingProvidersLocked(app, false)) {
            restart = true;
        }
        if (!app.conProviders.isEmpty()) {
            for (int i2 = app.conProviders.size() - 1; i2 >= 0; i2--) {
                ContentProviderConnection conn = app.conProviders.get(i2);
                conn.provider.connections.remove(conn);
                stopAssociationLocked(app.uid, app.processName, conn.provider.uid, conn.provider.name);
            }
            app.conProviders.clear();
        }
        skipCurrentReceiverLocked(app);
        for (int i3 = app.receivers.size() - 1; i3 >= 0; i3--) {
            removeReceiverLocked(app.receivers.valueAt(i3));
        }
        app.receivers.clear();
        if (this.mBackupTarget != null && app.pid == this.mBackupTarget.app.pid) {
            if (ActivityManagerDebugConfig.DEBUG_BACKUP || ActivityManagerDebugConfig.DEBUG_CLEANUP) {
                Slog.d("ActivityManager", "App " + this.mBackupTarget.appInfo + " died during backup");
            }
            this.mHandler.post(new Runnable() { // from class: com.android.server.am.ActivityManagerService.27
                @Override // java.lang.Runnable
                public void run() {
                    try {
                        IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(BatteryService.HealthServiceWrapper.INSTANCE_HEALTHD));
                        bm.agentDisconnected(app.info.packageName);
                    } catch (RemoteException e) {
                    }
                }
            });
        }
        for (int i4 = this.mPendingProcessChanges.size() - 1; i4 >= 0; i4--) {
            ProcessChangeItem item = this.mPendingProcessChanges.get(i4);
            if (app.pid > 0 && item.pid == app.pid) {
                this.mPendingProcessChanges.remove(i4);
                this.mAvailProcessChanges.add(item);
            }
        }
        this.mUiHandler.obtainMessage(32, app.pid, app.info.uid, null).sendToTarget();
        if (restarting) {
            return false;
        }
        if (!app.persistent || app.isolated) {
            if (ActivityManagerDebugConfig.DEBUG_PROCESSES || ActivityManagerDebugConfig.DEBUG_CLEANUP) {
                Slog.v("ActivityManager", "Removing non-persistent process during cleanup: " + app);
            }
            if (!replacingPid) {
                removeProcessNameLocked(app.processName, app.uid, app);
            }
            if (this.mHeavyWeightProcess == app) {
                this.mHandler.sendMessage(this.mHandler.obtainMessage(25, this.mHeavyWeightProcess.userId, 0));
                this.mHeavyWeightProcess = null;
            }
        } else if (!app.removed && this.mPersistentStartingProcesses.indexOf(app) < 0) {
            this.mPersistentStartingProcesses.add(app);
            restart = true;
        }
        if ((ActivityManagerDebugConfig.DEBUG_PROCESSES || ActivityManagerDebugConfig.DEBUG_CLEANUP) && this.mProcessesOnHold.contains(app)) {
            Slog.v("ActivityManager", "Clean-up removing on hold: " + app);
        }
        this.mProcessesOnHold.remove(app);
        if (app == this.mHomeProcess) {
            this.mHomeProcess = null;
        }
        if (app == this.mPreviousProcess) {
            this.mPreviousProcess = null;
        }
        if (restart && !app.isolated) {
            if (index < 0) {
                ProcessList.remove(app.pid);
            }
            addProcessNameLocked(app);
            app.pendingStart = false;
            startProcessLocked(app, "restart", app.processName);
            return true;
        }
        if (app.pid > 0 && app.pid != MY_PID) {
            synchronized (this.mPidsSelfLocked) {
                this.mPidsSelfLocked.remove(app.pid);
                this.mHandler.removeMessages(20, app);
            }
            this.mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
            if (app.isolated) {
                this.mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
            }
            app.setPid(0);
        }
        return false;
    }

    boolean checkAppInLaunchingProvidersLocked(ProcessRecord app) {
        for (int i = this.mLaunchingProviders.size() - 1; i >= 0; i--) {
            ContentProviderRecord cpr = this.mLaunchingProviders.get(i);
            if (cpr.launchingApp == app) {
                return true;
            }
        }
        return false;
    }

    boolean cleanupAppInLaunchingProvidersLocked(ProcessRecord app, boolean alwaysBad) {
        boolean restart = false;
        for (int i = this.mLaunchingProviders.size() - 1; i >= 0; i--) {
            ContentProviderRecord cpr = this.mLaunchingProviders.get(i);
            if (cpr.launchingApp == app) {
                if (!alwaysBad && !app.bad && cpr.hasConnectionOrHandle()) {
                    restart = true;
                } else {
                    removeDyingProviderLocked(app, cpr, true);
                }
            }
        }
        return restart;
    }

    public List<ActivityManager.RunningServiceInfo> getServices(int maxNum, int flags) {
        List<ActivityManager.RunningServiceInfo> runningServiceInfoLocked;
        enforceNotIsolatedCaller("getServices");
        int callingUid = Binder.getCallingUid();
        boolean canInteractAcrossUsers = ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", callingUid) == 0;
        boolean allowed = isGetTasksAllowed("getServices", Binder.getCallingPid(), callingUid);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                runningServiceInfoLocked = this.mServices.getRunningServiceInfoLocked(maxNum, flags, callingUid, allowed, canInteractAcrossUsers);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return runningServiceInfoLocked;
    }

    public PendingIntent getRunningServiceControlPanel(ComponentName name) {
        PendingIntent runningServiceControlPanelLocked;
        enforceNotIsolatedCaller("getRunningServiceControlPanel");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                runningServiceControlPanelLocked = this.mServices.getRunningServiceControlPanelLocked(name);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return runningServiceControlPanelLocked;
    }

    public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, boolean requireForeground, String callingPackage, int userId) throws TransactionTooLargeException {
        String str;
        boolean z;
        long origId;
        ComponentName res;
        enforceNotIsolatedCaller("startService");
        if (service == null || !service.hasFileDescriptors()) {
            if (callingPackage != null) {
                if (ActivityManagerDebugConfig.DEBUG_SERVICE) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("*** startService: ");
                    sb.append(service);
                    sb.append(" type=");
                    str = resolvedType;
                    sb.append(str);
                    sb.append(" fg=");
                    z = requireForeground;
                    sb.append(z);
                    Slog.v("ActivityManager", sb.toString());
                } else {
                    str = resolvedType;
                    z = requireForeground;
                }
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        int callingPid = Binder.getCallingPid();
                        int callingUid = Binder.getCallingUid();
                        long origId2 = Binder.clearCallingIdentity();
                        try {
                            String str2 = str;
                            origId = origId2;
                            try {
                                res = this.mServices.startServiceLocked(caller, service, str2, callingPid, callingUid, z, callingPackage, userId);
                                Binder.restoreCallingIdentity(origId);
                            } catch (Throwable th) {
                                th = th;
                                Binder.restoreCallingIdentity(origId);
                                throw th;
                            }
                        } catch (Throwable th2) {
                            th = th2;
                            origId = origId2;
                        }
                    } catch (Throwable th3) {
                        resetPriorityAfterLockedSection();
                        throw th3;
                    }
                }
                resetPriorityAfterLockedSection();
                return res;
            }
            throw new IllegalArgumentException("callingPackage cannot be null");
        }
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public ComponentName startServiceInPackage(int uid, Intent service, String resolvedType, boolean fgRequired, String callingPackage, int userId) throws TransactionTooLargeException {
        Intent intent;
        String str;
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    if (!ActivityManagerDebugConfig.DEBUG_SERVICE) {
                        intent = service;
                        str = resolvedType;
                    } else {
                        StringBuilder sb = new StringBuilder();
                        sb.append("startServiceInPackage: ");
                        intent = service;
                        try {
                            sb.append(intent);
                            sb.append(" type=");
                            str = resolvedType;
                            sb.append(str);
                            Slog.v("ActivityManager", sb.toString());
                        } catch (Throwable th) {
                            th = th;
                            resetPriorityAfterLockedSection();
                            throw th;
                        }
                    }
                    long origId = Binder.clearCallingIdentity();
                    ComponentName res = this.mServices.startServiceLocked(null, intent, str, -1, uid, fgRequired, callingPackage, userId);
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return res;
                } catch (Throwable th2) {
                    th = th2;
                }
            } catch (Throwable th3) {
                th = th3;
            }
        }
    }

    public int stopService(IApplicationThread caller, Intent service, String resolvedType, int userId) {
        int stopServiceLocked;
        enforceNotIsolatedCaller("stopService");
        if (service != null && service.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                stopServiceLocked = this.mServices.stopServiceLocked(caller, service, resolvedType, userId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return stopServiceLocked;
    }

    public IBinder peekService(Intent service, String resolvedType, String callingPackage) {
        IBinder peekServiceLocked;
        enforceNotIsolatedCaller("peekService");
        if (service != null && service.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        if (callingPackage == null) {
            throw new IllegalArgumentException("callingPackage cannot be null");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                peekServiceLocked = this.mServices.peekServiceLocked(service, resolvedType, callingPackage);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return peekServiceLocked;
    }

    public boolean stopServiceToken(ComponentName className, IBinder token, int startId) {
        boolean stopServiceTokenLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                stopServiceTokenLocked = this.mServices.stopServiceTokenLocked(className, token, startId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return stopServiceTokenLocked;
    }

    public void setServiceForeground(ComponentName className, IBinder token, int id, Notification notification, int flags) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mServices.setServiceForegroundLocked(className, token, id, notification, flags);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll, boolean requireFull, String name, String callerPackage) {
        return this.mUserController.handleIncomingUser(callingPid, callingUid, userId, allowAll, requireFull ? 2 : 0, name, callerPackage);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean isSingleton(String componentProcessName, ApplicationInfo aInfo, String className, int flags) {
        boolean result = false;
        if (UserHandle.getAppId(aInfo.uid) >= 10000) {
            if ((flags & 1073741824) != 0) {
                if (ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS", aInfo.uid) != 0) {
                    ComponentName comp = new ComponentName(aInfo.packageName, className);
                    String msg = "Permission Denial: Component " + comp.flattenToShortString() + " requests FLAG_SINGLE_USER, but app does not hold android.permission.INTERACT_ACROSS_USERS";
                    Slog.w("ActivityManager", msg);
                    throw new SecurityException(msg);
                }
                result = true;
            }
        } else if ("system".equals(componentProcessName)) {
            result = true;
        } else if ((flags & 1073741824) != 0) {
            result = UserHandle.isSameApp(aInfo.uid, NetworkAgentInfo.EVENT_NETWORK_LINGER_COMPLETE) || (aInfo.flags & 8) != 0;
        }
        if (ActivityManagerDebugConfig.DEBUG_MU) {
            Slog.v(TAG_MU, "isSingleton(" + componentProcessName + ", " + aInfo + ", " + className + ", 0x" + Integer.toHexString(flags) + ") = " + result);
        }
        return result;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean isValidSingletonCall(int callingUid, int componentUid) {
        int componentAppId = UserHandle.getAppId(componentUid);
        return UserHandle.isSameApp(callingUid, componentUid) || componentAppId == 1000 || componentAppId == 1001 || ActivityManager.checkUidPermission("android.permission.INTERACT_ACROSS_USERS_FULL", componentUid) == 0;
    }

    public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, String callingPackage, int userId) throws TransactionTooLargeException {
        int bindServiceLocked;
        enforceNotIsolatedCaller("bindService");
        if (service != null && service.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        if (callingPackage == null) {
            throw new IllegalArgumentException("callingPackage cannot be null");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                bindServiceLocked = this.mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, callingPackage, userId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return bindServiceLocked;
    }

    public boolean unbindService(IServiceConnection connection) {
        boolean unbindServiceLocked;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                unbindServiceLocked = this.mServices.unbindServiceLocked(connection);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return unbindServiceLocked;
    }

    public void publishService(IBinder token, Intent intent, IBinder service) {
        if (intent != null && intent.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!(token instanceof ServiceRecord)) {
                    throw new IllegalArgumentException("Invalid service token");
                }
                this.mServices.publishServiceLocked((ServiceRecord) token, intent, service);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void unbindFinished(IBinder token, Intent intent, boolean doRebind) {
        if (intent != null && intent.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mServices.unbindFinishedLocked((ServiceRecord) token, intent, doRebind);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void serviceDoneExecuting(IBinder token, int type, int startId, int res) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!(token instanceof ServiceRecord)) {
                    Slog.e("ActivityManager", "serviceDoneExecuting: Invalid service token=" + token);
                    throw new IllegalArgumentException("Invalid service token");
                }
                this.mServices.serviceDoneExecutingLocked((ServiceRecord) token, type, startId, res);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public boolean bindBackupAgent(String packageName, int backupMode, int userId) {
        ApplicationInfo app;
        BatteryStatsImpl stats;
        BatteryStatsImpl.Uid.Pkg.Serv ss;
        ComponentName componentName;
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v("ActivityManager", "bindBackupAgent: app=" + packageName + " mode=" + backupMode);
        }
        enforceCallingPermission("android.permission.CONFIRM_FULL_BACKUP", "bindBackupAgent");
        IPackageManager pm = AppGlobals.getPackageManager();
        try {
            ApplicationInfo app2 = pm.getApplicationInfo(packageName, 1024, userId);
            app = app2;
        } catch (RemoteException e) {
            app = null;
        }
        if (app == null) {
            Slog.w("ActivityManager", "Unable to bind backup agent for " + packageName);
            return false;
        }
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    BatteryStatsImpl stats2 = this.mBatteryStatsService.getActiveStatistics();
                    synchronized (stats2) {
                        try {
                            ss = stats2.getServiceStatsLocked(app.uid, app.packageName, app.name);
                        } catch (Throwable th) {
                            th = th;
                            stats = stats2;
                        }
                        try {
                        } catch (Throwable th2) {
                            th = th2;
                            stats = stats2;
                            while (true) {
                                try {
                                    break;
                                } catch (Throwable th3) {
                                    th = th3;
                                }
                            }
                            throw th;
                        }
                    }
                    try {
                        try {
                            AppGlobals.getPackageManager().setPackageStoppedState(app.packageName, false, UserHandle.getUserId(app.uid));
                        } catch (Throwable th4) {
                            th = th4;
                            resetPriorityAfterLockedSection();
                            throw th;
                        }
                    } catch (RemoteException e2) {
                    } catch (IllegalArgumentException e3) {
                        Slog.w("ActivityManager", "Failed trying to unstop package " + app.packageName + ": " + e3);
                    }
                    BackupRecord r = new BackupRecord(ss, app, backupMode);
                    if (backupMode == 0) {
                        componentName = new ComponentName(app.packageName, app.backupAgentName);
                    } else {
                        componentName = new ComponentName(PackageManagerService.PLATFORM_PACKAGE_NAME, "FullBackupAgent");
                    }
                    ComponentName hostingName = componentName;
                    ApplicationInfo app3 = app;
                    ProcessRecord proc = startProcessLocked(app.processName, app, false, 0, BatteryService.HealthServiceWrapper.INSTANCE_HEALTHD, hostingName, false, false, false);
                    if (proc == null) {
                        Slog.e("ActivityManager", "Unable to start backup agent process " + r);
                        resetPriorityAfterLockedSection();
                        return false;
                    }
                    if (UserHandle.isApp(app3.uid) && backupMode == 1) {
                        proc.inFullBackup = true;
                    }
                    r.app = proc;
                    int oldBackupUid = this.mBackupTarget != null ? this.mBackupTarget.appInfo.uid : -1;
                    int newBackupUid = proc.inFullBackup ? r.appInfo.uid : -1;
                    this.mBackupTarget = r;
                    this.mBackupAppName = app3.packageName;
                    updateOomAdjLocked(proc, true);
                    if (proc.thread != null) {
                        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
                            Slog.v("ActivityManager", "Agent proc already running: " + proc);
                        }
                        try {
                            proc.thread.scheduleCreateBackupAgent(app3, compatibilityInfoForPackageLocked(app3), backupMode);
                        } catch (RemoteException e4) {
                        }
                    } else if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
                        Slog.v("ActivityManager", "Agent proc not running, waiting for attach");
                    }
                    resetPriorityAfterLockedSection();
                    JobSchedulerInternal js = (JobSchedulerInternal) LocalServices.getService(JobSchedulerInternal.class);
                    if (oldBackupUid != -1) {
                        js.removeBackingUpUid(oldBackupUid);
                    }
                    if (newBackupUid != -1) {
                        js.addBackingUpUid(newBackupUid);
                    }
                    return true;
                } catch (Throwable th5) {
                    th = th5;
                }
            } catch (Throwable th6) {
                th = th6;
            }
        }
    }

    public void clearPendingBackup() {
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v("ActivityManager", "clearPendingBackup");
        }
        enforceCallingPermission("android.permission.BACKUP", "clearPendingBackup");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mBackupTarget = null;
                this.mBackupAppName = null;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        JobSchedulerInternal js = (JobSchedulerInternal) LocalServices.getService(JobSchedulerInternal.class);
        js.clearAllBackingUpUids();
    }

    public void backupAgentCreated(String agentPackageName, IBinder agent) {
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v("ActivityManager", "backupAgentCreated: " + agentPackageName + " = " + agent);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!agentPackageName.equals(this.mBackupAppName)) {
                    Slog.e("ActivityManager", "Backup agent created for " + agentPackageName + " but not requested!");
                    resetPriorityAfterLockedSection();
                    return;
                }
                resetPriorityAfterLockedSection();
                long oldIdent = Binder.clearCallingIdentity();
                try {
                    try {
                        IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(BatteryService.HealthServiceWrapper.INSTANCE_HEALTHD));
                        bm.agentConnected(agentPackageName, agent);
                    } finally {
                        Binder.restoreCallingIdentity(oldIdent);
                    }
                } catch (RemoteException e) {
                } catch (Exception e2) {
                    Slog.w("ActivityManager", "Exception trying to deliver BackupAgent binding: ");
                    e2.printStackTrace();
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void unbindBackupAgent(ApplicationInfo appInfo) {
        if (ActivityManagerDebugConfig.DEBUG_BACKUP) {
            Slog.v("ActivityManager", "unbindBackupAgent: " + appInfo);
        }
        if (appInfo == null) {
            Slog.w("ActivityManager", "unbind backup agent for null app");
            return;
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mBackupAppName == null) {
                    Slog.w("ActivityManager", "Unbinding backup agent with no active backup");
                    this.mBackupTarget = null;
                    this.mBackupAppName = null;
                    resetPriorityAfterLockedSection();
                } else if (!this.mBackupAppName.equals(appInfo.packageName)) {
                    Slog.e("ActivityManager", "Unbind of " + appInfo + " but is not the current backup target");
                    this.mBackupTarget = null;
                    this.mBackupAppName = null;
                    resetPriorityAfterLockedSection();
                } else {
                    ProcessRecord proc = this.mBackupTarget.app;
                    updateOomAdjLocked(proc, true);
                    proc.inFullBackup = false;
                    int oldBackupUid = this.mBackupTarget != null ? this.mBackupTarget.appInfo.uid : -1;
                    if (proc.thread != null) {
                        try {
                            proc.thread.scheduleDestroyBackupAgent(appInfo, compatibilityInfoForPackageLocked(appInfo));
                        } catch (Exception e) {
                            Slog.e("ActivityManager", "Exception when unbinding backup agent:");
                            e.printStackTrace();
                        }
                    }
                    this.mBackupTarget = null;
                    this.mBackupAppName = null;
                    int oldBackupUid2 = oldBackupUid;
                    resetPriorityAfterLockedSection();
                    if (oldBackupUid2 != -1) {
                        JobSchedulerInternal js = (JobSchedulerInternal) LocalServices.getService(JobSchedulerInternal.class);
                        js.removeBackingUpUid(oldBackupUid2);
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    private boolean isInstantApp(ProcessRecord record, String callerPackage, int uid) {
        if (UserHandle.getAppId(uid) < 10000) {
            return false;
        }
        if (record != null) {
            return record.info.isInstantApp();
        }
        IPackageManager pm = AppGlobals.getPackageManager();
        if (callerPackage == null) {
            try {
                String[] packageNames = pm.getPackagesForUid(uid);
                if (packageNames == null || packageNames.length == 0) {
                    throw new IllegalArgumentException("Unable to determine caller package name");
                }
                callerPackage = packageNames[0];
            } catch (RemoteException e) {
                Slog.e("ActivityManager", "Error looking up if " + callerPackage + " is an instant app.", e);
                return true;
            }
        }
        this.mAppOpsService.checkPackage(uid, callerPackage);
        return pm.isInstantApp(callerPackage, UserHandle.getUserId(uid));
    }

    boolean isPendingBroadcastProcessLocked(int pid) {
        return this.mFgBroadcastQueue.isPendingBroadcastProcessLocked(pid) || this.mBgBroadcastQueue.isPendingBroadcastProcessLocked(pid);
    }

    void skipPendingBroadcastLocked(int pid) {
        BroadcastQueue[] broadcastQueueArr;
        Slog.w("ActivityManager", "Unattached app died before broadcast acknowledged, skipping");
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            queue.skipPendingBroadcastLocked(pid);
        }
    }

    boolean sendPendingBroadcastsLocked(ProcessRecord app) {
        BroadcastQueue[] broadcastQueueArr;
        boolean didSomething = false;
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            didSomething |= queue.sendPendingBroadcastsLocked(app);
        }
        return didSomething;
    }

    public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId, int flags) {
        int callingUid;
        int i;
        ReceiverList rl;
        Intent sticky;
        ArrayList<Intent> allSticky;
        int userId2;
        int i2;
        int i3;
        ArrayList<Intent> stickyIntents;
        int i4;
        Iterator<String> actions;
        String action;
        ArrayList<Intent> stickyIntents2;
        String callerPackage2 = callerPackage;
        enforceNotIsolatedCaller("registerReceiver");
        ArrayList<Intent> stickyIntents3 = null;
        ProcessRecord callerApp = null;
        int i5 = 0;
        boolean visibleToInstantApps = (flags & 1) != 0;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (caller != null) {
                    try {
                        callerApp = getRecordForAppLocked(caller);
                        if (callerApp == null) {
                            throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when registering receiver " + receiver);
                        }
                        if (callerApp.info.uid != 1000 && !callerApp.pkgList.containsKey(callerPackage2) && !PackageManagerService.PLATFORM_PACKAGE_NAME.equals(callerPackage2)) {
                            throw new SecurityException("Given caller package " + callerPackage2 + " is not running in process " + callerApp);
                        }
                        callingUid = callerApp.info.uid;
                        i = callerApp.pid;
                    } catch (Throwable th) {
                        th = th;
                        while (true) {
                            try {
                                break;
                            } catch (Throwable th2) {
                                th = th2;
                            }
                        }
                        resetPriorityAfterLockedSection();
                        throw th;
                    }
                } else {
                    callerPackage2 = null;
                    callingUid = Binder.getCallingUid();
                    i = Binder.getCallingPid();
                }
                String callerPackage3 = callerPackage2;
                ProcessRecord callerApp2 = callerApp;
                int callingPid = i;
                try {
                    boolean instantApp = isInstantApp(callerApp2, callerPackage3, callingUid);
                    int userId3 = this.mUserController.handleIncomingUser(callingPid, callingUid, userId, true, 2, "registerReceiver", callerPackage3);
                    try {
                        Iterator<String> actions2 = filter.actionsIterator();
                        if (actions2 == null) {
                            try {
                                ArrayList<String> noAction = new ArrayList<>(1);
                                noAction.add(null);
                                actions2 = noAction.iterator();
                            } catch (Throwable th3) {
                                th = th3;
                                while (true) {
                                    break;
                                    break;
                                }
                                resetPriorityAfterLockedSection();
                                throw th;
                            }
                        }
                        int[] userIds = {-1, UserHandle.getUserId(callingUid)};
                        while (actions2.hasNext()) {
                            try {
                                String action2 = actions2.next();
                                int length = userIds.length;
                                ArrayList<Intent> stickyIntents4 = stickyIntents3;
                                int i6 = i5;
                                while (i6 < length) {
                                    try {
                                        int id = userIds[i6];
                                        ArrayMap<String, ArrayList<Intent>> stickies = this.mStickyBroadcasts.get(id);
                                        if (stickies != null) {
                                            action = action2;
                                            ArrayList<Intent> intents = stickies.get(action);
                                            i4 = length;
                                            if (intents != null) {
                                                if (stickyIntents4 == null) {
                                                    actions = actions2;
                                                    stickyIntents2 = new ArrayList<>();
                                                } else {
                                                    actions = actions2;
                                                    stickyIntents2 = stickyIntents4;
                                                }
                                                try {
                                                    stickyIntents2.addAll(intents);
                                                    stickyIntents4 = stickyIntents2;
                                                } catch (Throwable th4) {
                                                    th = th4;
                                                    while (true) {
                                                        break;
                                                        break;
                                                    }
                                                    resetPriorityAfterLockedSection();
                                                    throw th;
                                                }
                                            } else {
                                                actions = actions2;
                                            }
                                        } else {
                                            i4 = length;
                                            actions = actions2;
                                            action = action2;
                                        }
                                        i6++;
                                        action2 = action;
                                        length = i4;
                                        actions2 = actions;
                                    } catch (Throwable th5) {
                                        th = th5;
                                        while (true) {
                                            break;
                                            break;
                                        }
                                        resetPriorityAfterLockedSection();
                                        throw th;
                                    }
                                }
                                stickyIntents3 = stickyIntents4;
                                i5 = 0;
                            } catch (Throwable th6) {
                                th = th6;
                            }
                        }
                        resetPriorityAfterLockedSection();
                        int callingUid2 = callingUid;
                        ArrayList<Intent> allSticky2 = null;
                        if (stickyIntents3 != null) {
                            ContentResolver resolver = this.mContext.getContentResolver();
                            int i7 = 0;
                            int N = stickyIntents3.size();
                            while (i7 < N) {
                                Intent intent = stickyIntents3.get(i7);
                                if (instantApp && (intent.getFlags() & DumpState.DUMP_COMPILER_STATS) == 0) {
                                    stickyIntents = stickyIntents3;
                                } else {
                                    stickyIntents = stickyIntents3;
                                    if (filter.match(resolver, intent, true, "ActivityManager") >= 0) {
                                        if (allSticky2 == null) {
                                            allSticky2 = new ArrayList<>();
                                        }
                                        allSticky2.add(intent);
                                    }
                                }
                                i7++;
                                stickyIntents3 = stickyIntents;
                            }
                        }
                        ArrayList<Intent> allSticky3 = allSticky2;
                        Intent sticky2 = allSticky3 != null ? allSticky3.get(0) : null;
                        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
                            Slog.v("ActivityManager", "Register receiver " + filter + ": " + sticky2);
                        }
                        if (receiver == null) {
                            return sticky2;
                        }
                        synchronized (this) {
                            try {
                                try {
                                    boostPriorityForLockedSection();
                                    if (callerApp2 != null) {
                                        try {
                                            if (callerApp2.thread == null || callerApp2.thread.asBinder() != caller.asBinder()) {
                                                resetPriorityAfterLockedSection();
                                                return null;
                                            }
                                        } catch (Throwable th7) {
                                            e = th7;
                                            resetPriorityAfterLockedSection();
                                            throw e;
                                        }
                                    }
                                    rl = this.mRegisteredReceivers.get(receiver.asBinder());
                                    if (rl == null) {
                                        try {
                                            sticky = sticky2;
                                            allSticky = allSticky3;
                                            userId2 = userId3;
                                            try {
                                                ReceiverList rl2 = new ReceiverList(this, callerApp2, callingPid, callingUid2, userId3, receiver);
                                                if (rl2.app != null) {
                                                    int totalReceiversForApp = rl2.app.receivers.size();
                                                    if (totalReceiversForApp >= 1000) {
                                                        throw new IllegalStateException("Too many receivers, total of " + totalReceiversForApp + ", registered for pid: " + rl2.pid + ", callerPackage: " + callerPackage3);
                                                    }
                                                    rl2.app.receivers.add(rl2);
                                                    i2 = 0;
                                                } else {
                                                    try {
                                                        i2 = 0;
                                                        receiver.asBinder().linkToDeath(rl2, 0);
                                                        rl2.linkedToDeath = true;
                                                    } catch (RemoteException e) {
                                                        resetPriorityAfterLockedSection();
                                                        return sticky;
                                                    }
                                                }
                                                this.mRegisteredReceivers.put(receiver.asBinder(), rl2);
                                                rl = rl2;
                                            } catch (Throwable th8) {
                                                e = th8;
                                                resetPriorityAfterLockedSection();
                                                throw e;
                                            }
                                        } catch (Throwable th9) {
                                            e = th9;
                                            resetPriorityAfterLockedSection();
                                            throw e;
                                        }
                                    } else {
                                        sticky = sticky2;
                                        allSticky = allSticky3;
                                        userId2 = userId3;
                                        i2 = 0;
                                        try {
                                            if (rl.uid != callingUid2) {
                                                throw new IllegalArgumentException("Receiver requested to register for uid " + callingUid2 + " was previously registered for uid " + rl.uid + " callerPackage is " + callerPackage3);
                                            } else if (rl.pid != callingPid) {
                                                throw new IllegalArgumentException("Receiver requested to register for pid " + callingPid + " was previously registered for pid " + rl.pid + " callerPackage is " + callerPackage3);
                                            } else if (rl.userId != userId2) {
                                                throw new IllegalArgumentException("Receiver requested to register for user " + userId2 + " was previously registered for user " + rl.userId + " callerPackage is " + callerPackage3);
                                            }
                                        } catch (Throwable th10) {
                                            e = th10;
                                            resetPriorityAfterLockedSection();
                                            throw e;
                                        }
                                    }
                                    i3 = i2;
                                } catch (Throwable th11) {
                                    e = th11;
                                }
                            } catch (Throwable th12) {
                                e = th12;
                            }
                            try {
                                BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage3, permission, callingUid2, userId2, instantApp, visibleToInstantApps);
                                try {
                                    if (rl.containsFilter(filter)) {
                                        Slog.w("ActivityManager", "Receiver with filter " + filter + " already registered for pid " + rl.pid + ", callerPackage is " + callerPackage3);
                                    } else {
                                        rl.add(bf);
                                        if (!bf.debugCheck()) {
                                            Slog.w("ActivityManager", "==> For Dynamic broadcast");
                                        }
                                        this.mReceiverResolver.addFilter(bf);
                                    }
                                    if (allSticky != null) {
                                        ArrayList receivers = new ArrayList();
                                        receivers.add(bf);
                                        ArrayList<Intent> allSticky4 = allSticky;
                                        int stickyCount = allSticky4.size();
                                        while (i3 < stickyCount) {
                                            Intent intent2 = allSticky4.get(i3);
                                            BroadcastQueue queue = broadcastQueueForIntent(intent2);
                                            BroadcastRecord r = new BroadcastRecord(queue, intent2, null, null, -1, -1, false, null, null, -1, null, receivers, null, 0, null, null, false, true, true, -1);
                                            queue.enqueueParallelBroadcastLocked(r);
                                            queue.scheduleBroadcastsLocked();
                                            i3++;
                                            rl = rl;
                                        }
                                    }
                                    resetPriorityAfterLockedSection();
                                    return sticky;
                                } catch (Throwable th13) {
                                    e = th13;
                                    resetPriorityAfterLockedSection();
                                    throw e;
                                }
                            } catch (Throwable th14) {
                                e = th14;
                                resetPriorityAfterLockedSection();
                                throw e;
                            }
                        }
                    } catch (Throwable th15) {
                        th = th15;
                    }
                } catch (Throwable th16) {
                    th = th16;
                }
            } catch (Throwable th17) {
                th = th17;
            }
        }
    }

    public void unregisterReceiver(IIntentReceiver receiver) {
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
            Slog.v("ActivityManager", "Unregister receiver: " + receiver);
        }
        long origId = Binder.clearCallingIdentity();
        boolean doTrim = false;
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ReceiverList rl = this.mRegisteredReceivers.get(receiver.asBinder());
                if (rl != null) {
                    BroadcastRecord r = rl.curBroadcast;
                    if (r != null && r == r.queue.getMatchingOrderedReceiver(r)) {
                        boolean doNext = r.queue.finishReceiverLocked(r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false);
                        if (doNext) {
                            doTrim = true;
                            r.queue.processNextBroadcast(false);
                        }
                    }
                    if (rl.app != null) {
                        rl.app.receivers.remove(rl);
                    }
                    removeReceiverLocked(rl);
                    if (rl.linkedToDeath) {
                        rl.linkedToDeath = false;
                        rl.receiver.asBinder().unlinkToDeath(rl, 0);
                    }
                }
            }
            resetPriorityAfterLockedSection();
            if (doTrim) {
                trimApplications();
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    void removeReceiverLocked(ReceiverList rl) {
        this.mRegisteredReceivers.remove(rl.receiver.asBinder());
        for (int i = rl.size() - 1; i >= 0; i--) {
            this.mReceiverResolver.removeFilter(rl.get(i));
        }
    }

    private final void sendPackageBroadcastLocked(int cmd, String[] packages, int userId) {
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord r = this.mLruProcesses.get(i);
            if (r.thread != null && (userId == -1 || r.userId == userId)) {
                try {
                    r.thread.dispatchPackageBroadcast(cmd, packages);
                } catch (RemoteException e) {
                }
            }
        }
    }

    private List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType, int callingUid, int[] users) {
        int pmFlags;
        HashSet<ComponentName> singleUserReceivers;
        int pmFlags2;
        int[] iArr = users;
        int pmFlags3 = 268436480;
        boolean scannedFirstReceivers = false;
        try {
            int length = iArr.length;
            List<ResolveInfo> receivers = null;
            HashSet<ComponentName> singleUserReceivers2 = null;
            int i = 0;
            while (i < length) {
                try {
                    int user = iArr[i];
                    try {
                        try {
                            if (callingUid == 2000) {
                                try {
                                    if (this.mUserController.hasUserRestriction("no_debugging_features", user) && !isPermittedShellBroadcast(intent)) {
                                        pmFlags = pmFlags3;
                                        i++;
                                        pmFlags3 = pmFlags;
                                        iArr = users;
                                    }
                                } catch (RemoteException e) {
                                    return receivers;
                                }
                            }
                            List<ResolveInfo> newReceivers = AppGlobals.getPackageManager().queryIntentReceivers(intent, resolvedType, pmFlags3, user).getList();
                            if (user != 0 && newReceivers != null) {
                                int i2 = 0;
                                while (i2 < newReceivers.size()) {
                                    try {
                                        if ((newReceivers.get(i2).activityInfo.flags & 536870912) != 0) {
                                            newReceivers.remove(i2);
                                            i2--;
                                        }
                                        i2++;
                                    } catch (RemoteException e2) {
                                        return receivers;
                                    }
                                }
                            }
                            if (newReceivers != null && newReceivers.size() == 0) {
                                newReceivers = null;
                            }
                            if (receivers == null) {
                                List<ResolveInfo> receivers2 = newReceivers;
                                pmFlags = pmFlags3;
                                receivers = receivers2;
                            } else if (newReceivers != null) {
                                if (scannedFirstReceivers) {
                                    pmFlags = pmFlags3;
                                    singleUserReceivers = singleUserReceivers2;
                                } else {
                                    scannedFirstReceivers = true;
                                    singleUserReceivers = singleUserReceivers2;
                                    int i3 = 0;
                                    while (i3 < receivers.size()) {
                                        ResolveInfo ri = receivers.get(i3);
                                        if ((ri.activityInfo.flags & 1073741824) != 0) {
                                            pmFlags2 = pmFlags3;
                                            try {
                                                ComponentName cn = new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name);
                                                if (singleUserReceivers == null) {
                                                    singleUserReceivers = new HashSet<>();
                                                }
                                                singleUserReceivers.add(cn);
                                            } catch (RemoteException e3) {
                                                return receivers;
                                            }
                                        } else {
                                            pmFlags2 = pmFlags3;
                                        }
                                        i3++;
                                        pmFlags3 = pmFlags2;
                                    }
                                    pmFlags = pmFlags3;
                                }
                                for (int i4 = 0; i4 < newReceivers.size(); i4++) {
                                    ResolveInfo ri2 = newReceivers.get(i4);
                                    if ((ri2.activityInfo.flags & 1073741824) != 0) {
                                        ComponentName cn2 = new ComponentName(ri2.activityInfo.packageName, ri2.activityInfo.name);
                                        if (singleUserReceivers == null) {
                                            singleUserReceivers = new HashSet<>();
                                        }
                                        if (!singleUserReceivers.contains(cn2)) {
                                            singleUserReceivers.add(cn2);
                                            receivers.add(ri2);
                                        }
                                    } else {
                                        receivers.add(ri2);
                                    }
                                }
                                singleUserReceivers2 = singleUserReceivers;
                            } else {
                                pmFlags = pmFlags3;
                            }
                            i++;
                            pmFlags3 = pmFlags;
                            iArr = users;
                        } catch (RemoteException e4) {
                            return receivers;
                        }
                    } catch (RemoteException e5) {
                    }
                } catch (RemoteException e6) {
                }
            }
            return receivers;
        } catch (RemoteException e7) {
            return null;
        }
    }

    private boolean isPermittedShellBroadcast(Intent intent) {
        return INTENT_REMOTE_BUGREPORT_FINISHED.equals(intent.getAction());
    }

    private void checkBroadcastFromSystem(Intent intent, ProcessRecord callerApp, String callerPackage, int callingUid, boolean isProtectedBroadcast, List receivers) {
        if ((intent.getFlags() & DumpState.DUMP_CHANGES) != 0) {
            return;
        }
        String action = intent.getAction();
        if (isProtectedBroadcast || "android.intent.action.CLOSE_SYSTEM_DIALOGS".equals(action) || "com.android.intent.action.DISMISS_KEYBOARD_SHORTCUTS".equals(action) || "android.intent.action.MEDIA_BUTTON".equals(action) || "android.intent.action.MEDIA_SCANNER_SCAN_FILE".equals(action) || "com.android.intent.action.SHOW_KEYBOARD_SHORTCUTS".equals(action) || "android.intent.action.MASTER_CLEAR".equals(action) || "android.intent.action.FACTORY_RESET".equals(action) || "android.appwidget.action.APPWIDGET_CONFIGURE".equals(action) || "android.appwidget.action.APPWIDGET_UPDATE".equals(action) || "android.location.HIGH_POWER_REQUEST_CHANGE".equals(action) || "com.android.omadm.service.CONFIGURATION_UPDATE".equals(action) || "android.text.style.SUGGESTION_PICKED".equals(action) || "android.media.action.OPEN_AUDIO_EFFECT_CONTROL_SESSION".equals(action) || "android.media.action.CLOSE_AUDIO_EFFECT_CONTROL_SESSION".equals(action)) {
            return;
        }
        if (intent.getPackage() != null || intent.getComponent() != null) {
            if (receivers == null || receivers.size() == 0) {
                return;
            }
            boolean allProtected = true;
            int i = receivers.size() - 1;
            while (true) {
                if (i < 0) {
                    break;
                }
                Object target = receivers.get(i);
                if (target instanceof ResolveInfo) {
                    ResolveInfo ri = (ResolveInfo) target;
                    if (ri.activityInfo.exported && ri.activityInfo.permission == null) {
                        allProtected = false;
                        break;
                    }
                    i--;
                } else {
                    BroadcastFilter bf = (BroadcastFilter) target;
                    if (bf.requiredPermission != null) {
                        i--;
                    } else {
                        allProtected = false;
                        break;
                    }
                }
            }
            if (allProtected) {
                return;
            }
        }
        if (PackageManagerService.PLATFORM_PACKAGE_NAME.equals(callerPackage)) {
            if (callerApp != null) {
                Log.wtf("ActivityManager", "Sending non-protected broadcast " + action + " from system " + callerApp.toShortString() + " pkg " + callerPackage, new Throwable());
                return;
            }
            Log.wtf("ActivityManager", "Sending non-protected broadcast " + action + " from system uid " + UserHandle.formatUid(callingUid) + " pkg " + callerPackage, new Throwable());
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    /* JADX WARN: Can't fix incorrect switch cases order, some code will duplicate */
    /* JADX WARN: Code restructure failed: missing block: B:223:0x051c, code lost:
        if (r45.equals("android.intent.action.PACKAGE_REMOVED") != false) goto L380;
     */
    /* JADX WARN: Multi-variable type inference failed */
    /* JADX WARN: Removed duplicated region for block: B:316:0x07bb  */
    /* JADX WARN: Removed duplicated region for block: B:318:0x07c4  */
    /* JADX WARN: Removed duplicated region for block: B:358:0x08e0  */
    /* JADX WARN: Removed duplicated region for block: B:360:0x08e5  */
    /* JADX WARN: Removed duplicated region for block: B:361:0x08ed  */
    /* JADX WARN: Removed duplicated region for block: B:364:0x08fe  */
    /* JADX WARN: Removed duplicated region for block: B:365:0x0907  */
    /* JADX WARN: Removed duplicated region for block: B:368:0x0911  */
    /* JADX WARN: Removed duplicated region for block: B:385:0x094c  */
    /* JADX WARN: Removed duplicated region for block: B:389:0x0957  */
    /* JADX WARN: Removed duplicated region for block: B:390:0x0959  */
    /* JADX WARN: Removed duplicated region for block: B:393:0x095f  */
    /* JADX WARN: Removed duplicated region for block: B:395:0x0983  */
    /* JADX WARN: Removed duplicated region for block: B:396:0x0988  */
    /* JADX WARN: Removed duplicated region for block: B:399:0x098c A[ADDED_TO_REGION] */
    /* JADX WARN: Removed duplicated region for block: B:417:0x0a20  */
    /* JADX WARN: Removed duplicated region for block: B:462:0x0ae0  */
    /* JADX WARN: Removed duplicated region for block: B:464:0x0ae4  */
    /* JADX WARN: Removed duplicated region for block: B:468:0x0af8  */
    /* JADX WARN: Removed duplicated region for block: B:469:0x0b08  */
    /* JADX WARN: Removed duplicated region for block: B:471:0x0b0b  */
    /* JADX WARN: Removed duplicated region for block: B:496:0x0bf8  */
    /* JADX WARN: Removed duplicated region for block: B:71:0x01e0  */
    /* JADX WARN: Removed duplicated region for block: B:91:0x0293  */
    /* JADX WARN: Type inference failed for: r1v32 */
    /* JADX WARN: Type inference failed for: r1v33, types: [int] */
    /* JADX WARN: Type inference failed for: r1v34, types: [int] */
    @com.android.internal.annotations.GuardedBy("this")
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public final int broadcastIntentLocked(com.android.server.am.ProcessRecord r55, java.lang.String r56, android.content.Intent r57, java.lang.String r58, android.content.IIntentReceiver r59, int r60, java.lang.String r61, android.os.Bundle r62, java.lang.String[] r63, int r64, android.os.Bundle r65, boolean r66, boolean r67, int r68, int r69, int r70) {
        /*
            Method dump skipped, instructions count: 3286
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.broadcastIntentLocked(com.android.server.am.ProcessRecord, java.lang.String, android.content.Intent, java.lang.String, android.content.IIntentReceiver, int, java.lang.String, android.os.Bundle, java.lang.String[], int, android.os.Bundle, boolean, boolean, int, int, int):int");
    }

    private int getUidFromIntent(Intent intent) {
        if (intent == null) {
            return -1;
        }
        Bundle intentExtras = intent.getExtras();
        if (!intent.hasExtra("android.intent.extra.UID")) {
            return -1;
        }
        return intentExtras.getInt("android.intent.extra.UID");
    }

    final void rotateBroadcastStatsIfNeededLocked() {
        long now = SystemClock.elapsedRealtime();
        if (this.mCurBroadcastStats == null || this.mCurBroadcastStats.mStartRealtime + 86400000 < now) {
            this.mLastBroadcastStats = this.mCurBroadcastStats;
            if (this.mLastBroadcastStats != null) {
                this.mLastBroadcastStats.mEndRealtime = SystemClock.elapsedRealtime();
                this.mLastBroadcastStats.mEndUptime = SystemClock.uptimeMillis();
            }
            this.mCurBroadcastStats = new BroadcastStats();
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public final void addBroadcastStatLocked(String action, String srcPackage, int receiveCount, int skipCount, long dispatchTime) {
        rotateBroadcastStatsIfNeededLocked();
        this.mCurBroadcastStats.addBroadcast(action, srcPackage, receiveCount, skipCount, dispatchTime);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public final void addBackgroundCheckViolationLocked(String action, String targetPackage) {
        rotateBroadcastStatsIfNeededLocked();
        this.mCurBroadcastStats.addBackgroundCheckViolation(action, targetPackage);
    }

    final Intent verifyBroadcastLocked(Intent intent) {
        int callingUid;
        if (intent != null && intent.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        int flags = intent.getFlags();
        if (!this.mProcessesReady && (67108864 & flags) == 0 && (1073741824 & flags) == 0) {
            Slog.e("ActivityManager", "Attempt to launch receivers of broadcast intent " + intent + " before boot completion");
            throw new IllegalStateException("Cannot broadcast before boot completed");
        } else if ((33554432 & flags) != 0) {
            throw new IllegalArgumentException("Can't use FLAG_RECEIVER_BOOT_UPGRADE here");
        } else {
            if ((flags & DumpState.DUMP_CHANGES) != 0 && (callingUid = Binder.getCallingUid()) != 0 && callingUid != 1000 && callingUid != 2000) {
                Slog.w("ActivityManager", "Removing FLAG_RECEIVER_FROM_SHELL because caller is UID " + Binder.getCallingUid());
                intent.removeFlags(DumpState.DUMP_CHANGES);
            }
            return intent;
        }
    }

    public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean serialized, boolean sticky, int userId) {
        Intent intent2;
        enforceNotIsolatedCaller("broadcastIntent");
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    intent2 = intent;
                } catch (Throwable th) {
                    th = th;
                }
                try {
                    Intent intent3 = verifyBroadcastLocked(intent2);
                    try {
                        ProcessRecord callerApp = getRecordForAppLocked(caller);
                        int callingPid = Binder.getCallingPid();
                        int callingUid = Binder.getCallingUid();
                        long origId = Binder.clearCallingIdentity();
                        int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent3, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, bOptions, serialized, sticky, callingPid, callingUid, userId);
                        Binder.restoreCallingIdentity(origId);
                        resetPriorityAfterLockedSection();
                        return res;
                    } catch (Throwable th2) {
                        th = th2;
                        resetPriorityAfterLockedSection();
                        throw th;
                    }
                } catch (Throwable th3) {
                    th = th3;
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            } catch (Throwable th4) {
                th = th4;
                intent2 = intent;
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public int broadcastIntentInPackage(String packageName, int uid, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String requiredPermission, Bundle bOptions, boolean serialized, boolean sticky, int userId) {
        Intent intent2;
        synchronized (this) {
            try {
                try {
                    boostPriorityForLockedSection();
                    intent2 = intent;
                } catch (Throwable th) {
                    th = th;
                    intent2 = intent;
                }
            } catch (Throwable th2) {
                th = th2;
            }
            try {
                Intent intent3 = verifyBroadcastLocked(intent2);
                try {
                    long origId = Binder.clearCallingIdentity();
                    String[] requiredPermissions = requiredPermission == null ? null : new String[]{requiredPermission};
                    int res = broadcastIntentLocked(null, packageName, intent3, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, -1, bOptions, serialized, sticky, -1, uid, userId);
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return res;
                } catch (Throwable th3) {
                    th = th3;
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            } catch (Throwable th4) {
                th = th4;
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public final void unbroadcastIntent(IApplicationThread caller, Intent intent, int userId) {
        if (intent != null && intent.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        int userId2 = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, 0, "removeStickyBroadcast", null);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (checkCallingPermission("android.permission.BROADCAST_STICKY") != 0) {
                    String msg = "Permission Denial: unbroadcastIntent() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.BROADCAST_STICKY";
                    Slog.w("ActivityManager", msg);
                    throw new SecurityException(msg);
                }
                ArrayMap<String, ArrayList<Intent>> stickies = this.mStickyBroadcasts.get(userId2);
                if (stickies != null) {
                    ArrayList<Intent> list = stickies.get(intent.getAction());
                    if (list != null) {
                        int N = list.size();
                        int i = 0;
                        while (true) {
                            if (i >= N) {
                                break;
                            } else if (!intent.filterEquals(list.get(i))) {
                                i++;
                            } else {
                                list.remove(i);
                                break;
                            }
                        }
                        if (list.size() <= 0) {
                            stickies.remove(intent.getAction());
                        }
                    }
                    int N2 = stickies.size();
                    if (N2 <= 0) {
                        this.mStickyBroadcasts.remove(userId2);
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void backgroundServicesFinishedLocked(int userId) {
        BroadcastQueue[] broadcastQueueArr;
        for (BroadcastQueue queue : this.mBroadcastQueues) {
            queue.backgroundServicesFinishedLocked(userId);
        }
    }

    public void finishReceiver(IBinder who, int resultCode, String resultData, Bundle resultExtras, boolean resultAbort, int flags) {
        if (ActivityManagerDebugConfig.DEBUG_BROADCAST) {
            Slog.v("ActivityManager", "Finish receiver: " + who);
        }
        if (resultExtras != null && resultExtras.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Bundle");
        }
        long origId = Binder.clearCallingIdentity();
        boolean doNext = false;
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                BroadcastQueue queue = (flags & 268435456) != 0 ? this.mFgBroadcastQueue : this.mBgBroadcastQueue;
                BroadcastRecord r = queue.getMatchingOrderedReceiver(who);
                if (r != null) {
                    doNext = r.queue.finishReceiverLocked(r, resultCode, resultData, resultExtras, resultAbort, true);
                }
                if (doNext) {
                    r.queue.processNextBroadcastLocked(false, true);
                }
                trimApplicationsLocked();
            }
            resetPriorityAfterLockedSection();
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public boolean startInstrumentation(ComponentName className, String profileFile, int flags, Bundle arguments, IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection, int userId, String abiOverride) {
        InstrumentationInfo ii;
        ApplicationInfo ai;
        enforceNotIsolatedCaller("startInstrumentation");
        int userId2 = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, 2, "startInstrumentation", null);
        if (arguments == null || !arguments.hasFileDescriptors()) {
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    InstrumentationInfo ii2 = null;
                    try {
                        ii2 = this.mContext.getPackageManager().getInstrumentationInfo(className, 1024);
                        ApplicationInfo ai2 = AppGlobals.getPackageManager().getApplicationInfo(ii2.targetPackage, 1024, userId2);
                        ai = ai2;
                        ii = ii2;
                    } catch (PackageManager.NameNotFoundException | RemoteException e) {
                        ii = ii2;
                        ai = null;
                    }
                    if (ii == null) {
                        reportStartInstrumentationFailureLocked(watcher, className, "Unable to find instrumentation info for: " + className);
                        resetPriorityAfterLockedSection();
                        return false;
                    } else if (ai == null) {
                        reportStartInstrumentationFailureLocked(watcher, className, "Unable to find instrumentation target package: " + ii.targetPackage);
                        resetPriorityAfterLockedSection();
                        return false;
                    } else if (!ai.hasCode()) {
                        reportStartInstrumentationFailureLocked(watcher, className, "Instrumentation target has no code: " + ii.targetPackage);
                        resetPriorityAfterLockedSection();
                        return false;
                    } else {
                        int match = this.mContext.getPackageManager().checkSignatures(ii.targetPackage, ii.packageName);
                        if (match < 0 && match != -1) {
                            String msg = "Permission Denial: starting instrumentation " + className + " from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingPid() + " not allowed because package " + ii.packageName + " does not have a signature matching the target " + ii.targetPackage;
                            reportStartInstrumentationFailureLocked(watcher, className, msg);
                            throw new SecurityException(msg);
                        }
                        ActiveInstrumentation activeInstr = new ActiveInstrumentation(this);
                        activeInstr.mClass = className;
                        String defProcess = ai.processName;
                        if (ii.targetProcesses == null) {
                            activeInstr.mTargetProcesses = new String[]{ai.processName};
                        } else if (ii.targetProcesses.equals("*")) {
                            activeInstr.mTargetProcesses = new String[0];
                        } else {
                            activeInstr.mTargetProcesses = ii.targetProcesses.split(",");
                            defProcess = activeInstr.mTargetProcesses[0];
                        }
                        String defProcess2 = defProcess;
                        activeInstr.mTargetInfo = ai;
                        activeInstr.mProfileFile = profileFile;
                        activeInstr.mArguments = arguments;
                        activeInstr.mWatcher = watcher;
                        activeInstr.mUiAutomationConnection = uiAutomationConnection;
                        activeInstr.mResultClass = className;
                        boolean disableHiddenApiChecks = (flags & 1) != 0;
                        if (disableHiddenApiChecks) {
                            enforceCallingPermission("android.permission.DISABLE_HIDDEN_API_CHECKS", "disable hidden API checks");
                        }
                        long origId = Binder.clearCallingIdentity();
                        ApplicationInfo ai3 = ai;
                        forceStopPackageLocked(ii.targetPackage, -1, true, false, true, true, false, userId2, "start instr");
                        if (this.mUsageStatsService != null) {
                            this.mUsageStatsService.reportEvent(ii.targetPackage, userId2, 6);
                        }
                        ProcessRecord app = addAppLocked(ai3, defProcess2, false, disableHiddenApiChecks, abiOverride);
                        app.instr = activeInstr;
                        activeInstr.mFinished = false;
                        activeInstr.mRunningProcesses.add(app);
                        if (!this.mActiveInstrumentation.contains(activeInstr)) {
                            this.mActiveInstrumentation.add(activeInstr);
                        }
                        Binder.restoreCallingIdentity(origId);
                        resetPriorityAfterLockedSection();
                        return true;
                    }
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
        }
        throw new IllegalArgumentException("File descriptors passed in Bundle");
    }

    private void reportStartInstrumentationFailureLocked(IInstrumentationWatcher watcher, ComponentName cn, String report) {
        Slog.w("ActivityManager", report);
        if (watcher != null) {
            Bundle results = new Bundle();
            results.putString("id", "ActivityManagerService");
            results.putString("Error", report);
            this.mInstrumentationReporter.reportStatus(watcher, cn, -1, results);
        }
    }

    void addInstrumentationResultsLocked(ProcessRecord app, Bundle results) {
        if (app.instr == null) {
            Slog.w("ActivityManager", "finishInstrumentation called on non-instrumented: " + app);
        } else if (!app.instr.mFinished && results != null) {
            if (app.instr.mCurResults == null) {
                app.instr.mCurResults = new Bundle(results);
                return;
            }
            app.instr.mCurResults.putAll(results);
        }
    }

    public void addInstrumentationResults(IApplicationThread target, Bundle results) {
        UserHandle.getCallingUserId();
        if (results != null && results.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord app = getRecordForAppLocked(target);
                if (app == null) {
                    Slog.w("ActivityManager", "addInstrumentationResults: no app for " + target);
                    resetPriorityAfterLockedSection();
                    return;
                }
                long origId = Binder.clearCallingIdentity();
                addInstrumentationResultsLocked(app, results);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    @GuardedBy("this")
    void finishInstrumentationLocked(ProcessRecord app, int resultCode, Bundle results) {
        if (app.instr == null) {
            Slog.w("ActivityManager", "finishInstrumentation called on non-instrumented: " + app);
            return;
        }
        if (!app.instr.mFinished) {
            if (app.instr.mWatcher != null) {
                Bundle finalResults = app.instr.mCurResults;
                if (finalResults != null) {
                    if (app.instr.mCurResults != null && results != null) {
                        finalResults.putAll(results);
                    }
                } else {
                    finalResults = results;
                }
                this.mInstrumentationReporter.reportFinished(app.instr.mWatcher, app.instr.mClass, resultCode, finalResults);
            }
            if (app.instr.mUiAutomationConnection != null) {
                this.mHandler.obtainMessage(56, app.instr.mUiAutomationConnection).sendToTarget();
            }
            app.instr.mFinished = true;
        }
        app.instr.removeProcess(app);
        app.instr = null;
        forceStopPackageLocked(app.info.packageName, -1, false, false, true, true, false, app.userId, "finished inst");
    }

    public void finishInstrumentation(IApplicationThread target, int resultCode, Bundle results) {
        UserHandle.getCallingUserId();
        if (results != null && results.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in Intent");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ProcessRecord app = getRecordForAppLocked(target);
                if (app == null) {
                    Slog.w("ActivityManager", "finishInstrumentation: no app for " + target);
                    resetPriorityAfterLockedSection();
                    return;
                }
                long origId = Binder.clearCallingIdentity();
                finishInstrumentationLocked(app, resultCode, results);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public ConfigurationInfo getDeviceConfigurationInfo() {
        ConfigurationInfo config = new ConfigurationInfo();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                Configuration globalConfig = getGlobalConfiguration();
                config.reqTouchScreen = globalConfig.touchscreen;
                config.reqKeyboardType = globalConfig.keyboard;
                config.reqNavigation = globalConfig.navigation;
                if (globalConfig.navigation == 2 || globalConfig.navigation == 3) {
                    config.reqInputFeatures |= 2;
                }
                if (globalConfig.keyboard != 0 && globalConfig.keyboard != 1) {
                    config.reqInputFeatures |= 1;
                }
                config.reqGlEsVersion = this.GL_ES_VERSION;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return config;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public ActivityStack getFocusedStack() {
        return this.mStackSupervisor.getFocusedStack();
    }

    public ActivityManager.StackInfo getFocusedStackInfo() throws RemoteException {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "getStackInfo()");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ActivityStack focusedStack = getFocusedStack();
                if (focusedStack != null) {
                    ActivityManager.StackInfo stackInfo = this.mStackSupervisor.getStackInfo(focusedStack.mStackId);
                    resetPriorityAfterLockedSection();
                    return stackInfo;
                }
                resetPriorityAfterLockedSection();
                return null;
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }

    public Configuration getConfiguration() {
        Configuration ci;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ci = new Configuration(getGlobalConfiguration());
                ci.userSetLocale = false;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return ci;
    }

    public void suppressResizeConfigChanges(boolean suppress) throws RemoteException {
        enforceCallingPermission("android.permission.MANAGE_ACTIVITY_STACKS", "suppressResizeConfigChanges()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mSuppressResizeConfigChanges = suppress;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void moveTasksToFullscreenStack(int fromStackId, boolean onTop) {
        enforceCallerIsRecentsOrHasPermission("android.permission.MANAGE_ACTIVITY_STACKS", "moveTasksToFullscreenStack()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                ActivityStack stack = this.mStackSupervisor.getStack(fromStackId);
                if (stack != null) {
                    if (!stack.isActivityTypeStandardOrUndefined()) {
                        throw new IllegalArgumentException("You can't move tasks from non-standard stacks.");
                    }
                    this.mStackSupervisor.moveTasksToFullscreenStackLocked(stack, onTop);
                }
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void updatePersistentConfiguration(Configuration values) {
        enforceCallingPermission("android.permission.CHANGE_CONFIGURATION", "updatePersistentConfiguration()");
        enforceWriteSettingsPermission("updatePersistentConfiguration()");
        if (values == null) {
            throw new NullPointerException("Configuration must not be null");
        }
        int userId = UserHandle.getCallingUserId();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                updatePersistentConfigurationLocked(values, userId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    private void updatePersistentConfigurationLocked(Configuration values, int userId) {
        long origId = Binder.clearCallingIdentity();
        try {
            updateConfigurationLocked(values, null, false, true, userId, false);
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    /* JADX INFO: Access modifiers changed from: private */
    public void updateFontScaleIfNeeded(int userId) {
        float scaleFactor = Settings.System.getFloatForUser(this.mContext.getContentResolver(), "font_scale", 1.0f, userId);
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (getGlobalConfiguration().fontScale == scaleFactor) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                Configuration configuration = this.mWindowManager.computeNewConfiguration(0);
                configuration.fontScale = scaleFactor;
                updatePersistentConfigurationLocked(configuration, userId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    private void enforceWriteSettingsPermission(String func) {
        int uid = Binder.getCallingUid();
        if (uid == 0 || Settings.checkAndNoteWriteSettingsOperation(this.mContext, uid, Settings.getPackageNameForUid(this.mContext, uid), false)) {
            return;
        }
        String msg = "Permission Denial: " + func + " from pid=" + Binder.getCallingPid() + ", uid=" + uid + " requires android.permission.WRITE_SETTINGS";
        Slog.w("ActivityManager", msg);
        throw new SecurityException(msg);
    }

    public boolean updateConfiguration(Configuration values) {
        boolean z;
        enforceCallingPermission("android.permission.CHANGE_CONFIGURATION", "updateConfiguration()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (values == null && this.mWindowManager != null) {
                    values = this.mWindowManager.computeNewConfiguration(0);
                }
                if (this.mWindowManager != null) {
                    this.mProcessList.applyDisplaySize(this.mWindowManager);
                }
                long origId = Binder.clearCallingIdentity();
                if (values != null) {
                    Settings.System.clearConfiguration(values);
                }
                updateConfigurationLocked(values, null, false, false, -10000, false, this.mTmpUpdateConfigurationResult);
                z = this.mTmpUpdateConfigurationResult.changes != 0;
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return z;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void updateUserConfigurationLocked() {
        Configuration configuration = new Configuration(getGlobalConfiguration());
        int currentUserId = this.mUserController.getCurrentUserId();
        Settings.System.adjustConfigurationForUser(this.mContext.getContentResolver(), configuration, currentUserId, Settings.System.canWrite(this.mContext));
        updateConfigurationLocked(configuration, null, false, false, currentUserId, false);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale) {
        return updateConfigurationLocked(values, starting, initLocale, false);
    }

    boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean deferResume) {
        return updateConfigurationLocked(values, starting, initLocale, false, -10000, deferResume);
    }

    /* JADX INFO: Access modifiers changed from: private */
    public boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean persistent, int userId, boolean deferResume) {
        return updateConfigurationLocked(values, starting, initLocale, persistent, userId, deferResume, null);
    }

    private boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean persistent, int userId, boolean deferResume, UpdateConfigurationResult result) {
        int changes = 0;
        if (this.mWindowManager != null) {
            this.mWindowManager.deferSurfaceLayout();
        }
        if (values != null) {
            try {
                changes = updateGlobalConfigurationLocked(values, initLocale, persistent, userId, deferResume);
            } catch (Throwable th) {
                if (this.mWindowManager != null) {
                    this.mWindowManager.continueSurfaceLayout();
                }
                throw th;
            }
        }
        boolean kept = ensureConfigAndVisibilityAfterUpdate(starting, changes);
        if (this.mWindowManager != null) {
            this.mWindowManager.continueSurfaceLayout();
        }
        if (result != null) {
            result.changes = changes;
            result.activityRelaunched = !kept;
        }
        return kept;
    }

    private static boolean isSplitConfigurationChange(int configDiff) {
        return (configDiff & 4100) != 0;
    }

    /* JADX WARN: Code restructure failed: missing block: B:53:0x025a, code lost:
        if (r14.mProcessesReady == false) goto L64;
     */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    private int updateGlobalConfigurationLocked(android.content.res.Configuration r44, boolean r45, boolean r46, int r47, boolean r48) {
        /*
            Method dump skipped, instructions count: 730
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.updateGlobalConfigurationLocked(android.content.res.Configuration, boolean, boolean, int, boolean):int");
    }

    public boolean updateDisplayOverrideConfiguration(Configuration values, int displayId) {
        enforceCallingPermission("android.permission.CHANGE_CONFIGURATION", "updateDisplayOverrideConfiguration()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (!this.mStackSupervisor.isDisplayAdded(displayId)) {
                    if (ActivityManagerDebugConfig.DEBUG_CONFIGURATION) {
                        Slog.w("ActivityManager", "Trying to update display configuration for non-existing displayId=" + displayId);
                    }
                    resetPriorityAfterLockedSection();
                    return false;
                }
                if (values == null && this.mWindowManager != null) {
                    values = this.mWindowManager.computeNewConfiguration(displayId);
                }
                if (this.mWindowManager != null) {
                    this.mProcessList.applyDisplaySize(this.mWindowManager);
                }
                long origId = Binder.clearCallingIdentity();
                if (values != null) {
                    Settings.System.clearConfiguration(values);
                }
                updateDisplayOverrideConfigurationLocked(values, null, false, displayId, this.mTmpUpdateConfigurationResult);
                boolean z = this.mTmpUpdateConfigurationResult.changes != 0;
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
                return z;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public boolean updateDisplayOverrideConfigurationLocked(Configuration values, ActivityRecord starting, boolean deferResume, int displayId) {
        return updateDisplayOverrideConfigurationLocked(values, starting, deferResume, displayId, null);
    }

    private boolean updateDisplayOverrideConfigurationLocked(Configuration values, ActivityRecord starting, boolean deferResume, int displayId, UpdateConfigurationResult result) {
        int changes = 0;
        if (this.mWindowManager != null) {
            this.mWindowManager.deferSurfaceLayout();
        }
        try {
            if (values != null) {
                if (displayId == 0) {
                    changes = updateGlobalConfigurationLocked(values, false, false, -10000, deferResume);
                } else {
                    changes = performDisplayOverrideConfigUpdate(values, deferResume, displayId);
                }
            }
            boolean kept = ensureConfigAndVisibilityAfterUpdate(starting, changes);
            if (result != null) {
                result.changes = changes;
                result.activityRelaunched = !kept;
            }
            return kept;
        } finally {
            if (this.mWindowManager != null) {
                this.mWindowManager.continueSurfaceLayout();
            }
        }
    }

    private int performDisplayOverrideConfigUpdate(Configuration values, boolean deferResume, int displayId) {
        int[] resizedStacks;
        this.mTempConfig.setTo(this.mStackSupervisor.getDisplayOverrideConfiguration(displayId));
        int changes = this.mTempConfig.updateFrom(values);
        if (changes != 0) {
            Slog.i("ActivityManager", "Override config changes=" + Integer.toHexString(changes) + " " + this.mTempConfig + " for displayId=" + displayId);
            this.mStackSupervisor.setDisplayOverrideConfiguration(this.mTempConfig, displayId);
            boolean isDensityChange = (changes & 4096) != 0;
            if (isDensityChange && displayId == 0) {
                this.mAppWarnings.onDensityChanged();
                killAllBackgroundProcessesExcept(24, 4);
            }
        }
        if (this.mWindowManager != null && (resizedStacks = this.mWindowManager.setNewDisplayOverrideConfiguration(this.mTempConfig, displayId)) != null) {
            for (int stackId : resizedStacks) {
                resizeStackWithBoundsFromWindowManager(stackId, deferResume);
            }
        }
        return changes;
    }

    private boolean ensureConfigAndVisibilityAfterUpdate(ActivityRecord starting, int changes) {
        ActivityStack mainStack = this.mStackSupervisor.getFocusedStack();
        if (mainStack == null) {
            return true;
        }
        if (changes != 0 && starting == null) {
            starting = mainStack.topRunningActivityLocked();
        }
        if (starting == null) {
            return true;
        }
        boolean kept = starting.ensureActivityConfiguration(changes, false);
        this.mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes, false);
        return kept;
    }

    private void resizeStackWithBoundsFromWindowManager(int stackId, boolean deferResume) {
        Rect newStackBounds = new Rect();
        ActivityStack stack = this.mStackSupervisor.getStack(stackId);
        if (stack == null) {
            StringWriter writer = new StringWriter();
            PrintWriter printWriter = new PrintWriter(writer);
            this.mStackSupervisor.dumpDisplays(printWriter);
            printWriter.flush();
            Log.wtf("ActivityManager", "stack not found:" + stackId + " displays:" + writer);
        }
        stack.getBoundsForNewConfiguration(newStackBounds);
        this.mStackSupervisor.resizeStackLocked(stack, !newStackBounds.isEmpty() ? newStackBounds : null, null, null, false, false, deferResume);
    }

    /* JADX INFO: Access modifiers changed from: private */
    public void updateShouldShowDialogsLocked(Configuration config) {
        boolean z = false;
        boolean inputMethodExists = (config.keyboard == 1 && config.touchscreen == 1 && config.navigation == 1) ? false : true;
        int modeType = config.uiMode & 15;
        boolean uiModeSupportsDialogs = (modeType == 3 || (modeType == 6 && Build.IS_USER) || modeType == 4 || modeType == 7) ? false : true;
        boolean hideDialogsSet = Settings.Global.getInt(this.mContext.getContentResolver(), "hide_error_dialogs", 0) != 0;
        if (inputMethodExists && uiModeSupportsDialogs && !hideDialogsSet) {
            z = true;
        }
        this.mShowDialogs = z;
    }

    public boolean shouldUpRecreateTask(IBinder token, String destAffinity) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord srec = ActivityRecord.forTokenLocked(token);
                if (srec != null) {
                    boolean shouldUpRecreateTaskLocked = srec.getStack().shouldUpRecreateTaskLocked(srec, destAffinity);
                    resetPriorityAfterLockedSection();
                    return shouldUpRecreateTaskLocked;
                }
                resetPriorityAfterLockedSection();
                return false;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public boolean navigateUpTo(IBinder token, Intent destIntent, int resultCode, Intent resultData) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.forTokenLocked(token);
                if (r != null) {
                    boolean navigateUpToLocked = r.getStack().navigateUpToLocked(r, destIntent, resultCode, resultData);
                    resetPriorityAfterLockedSection();
                    return navigateUpToLocked;
                }
                resetPriorityAfterLockedSection();
                return false;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public int getLaunchedFromUid(IBinder activityToken) {
        ActivityRecord srec;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                srec = ActivityRecord.forTokenLocked(activityToken);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (srec == null) {
            return -1;
        }
        return srec.launchedFromUid;
    }

    public String getLaunchedFromPackage(IBinder activityToken) {
        ActivityRecord srec;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                srec = ActivityRecord.forTokenLocked(activityToken);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        if (srec == null) {
            return null;
        }
        return srec.launchedFromPackage;
    }

    private boolean isReceivingBroadcastLocked(ProcessRecord app, ArraySet<BroadcastQueue> receivingQueues) {
        int N = app.curReceivers.size();
        int i = 0;
        if (N > 0) {
            while (i < N) {
                receivingQueues.add(app.curReceivers.valueAt(i).queue);
                i++;
            }
            return true;
        }
        BroadcastQueue[] broadcastQueueArr = this.mBroadcastQueues;
        int length = broadcastQueueArr.length;
        while (i < length) {
            BroadcastQueue queue = broadcastQueueArr[i];
            BroadcastRecord r = queue.mPendingBroadcast;
            if (r != null && r.curApp == app) {
                receivingQueues.add(queue);
            }
            i++;
        }
        return !receivingQueues.isEmpty();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public Association startAssociationLocked(int sourceUid, String sourceProcess, int sourceState, int targetUid, ComponentName targetComponent, String targetProcess) {
        if (!this.mTrackingAssociations) {
            return null;
        }
        ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components = this.mAssociations.get(targetUid);
        if (components == null) {
            components = new ArrayMap<>();
            this.mAssociations.put(targetUid, components);
        }
        ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components2 = components;
        SparseArray<ArrayMap<String, Association>> sourceUids = components2.get(targetComponent);
        if (sourceUids == null) {
            sourceUids = new SparseArray<>();
            components2.put(targetComponent, sourceUids);
        }
        SparseArray<ArrayMap<String, Association>> sourceUids2 = sourceUids;
        ArrayMap<String, Association> sourceProcesses = sourceUids2.get(sourceUid);
        if (sourceProcesses == null) {
            sourceProcesses = new ArrayMap<>();
            sourceUids2.put(sourceUid, sourceProcesses);
        }
        ArrayMap<String, Association> sourceProcesses2 = sourceProcesses;
        Association ass = sourceProcesses2.get(sourceProcess);
        if (ass == null) {
            ass = new Association(sourceUid, sourceProcess, targetUid, targetComponent, targetProcess);
            sourceProcesses2.put(sourceProcess, ass);
        }
        ass.mCount++;
        ass.mNesting++;
        if (ass.mNesting == 1) {
            long uptimeMillis = SystemClock.uptimeMillis();
            ass.mLastStateUptime = uptimeMillis;
            ass.mStartTime = uptimeMillis;
            ass.mLastState = sourceState;
        }
        return ass;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void stopAssociationLocked(int sourceUid, String sourceProcess, int targetUid, ComponentName targetComponent) {
        ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components;
        SparseArray<ArrayMap<String, Association>> sourceUids;
        ArrayMap<String, Association> sourceProcesses;
        Association ass;
        if (this.mTrackingAssociations && (components = this.mAssociations.get(targetUid)) != null && (sourceUids = components.get(targetComponent)) != null && (sourceProcesses = sourceUids.get(sourceUid)) != null && (ass = sourceProcesses.get(sourceProcess)) != null && ass.mNesting > 0) {
            ass.mNesting--;
            if (ass.mNesting == 0) {
                long uptime = SystemClock.uptimeMillis();
                ass.mTime += uptime - ass.mStartTime;
                long[] jArr = ass.mStateTimes;
                int i = ass.mLastState + 0;
                jArr[i] = jArr[i] + (uptime - ass.mLastStateUptime);
                ass.mLastState = 21;
            }
        }
    }

    private void noteUidProcessState(int uid, int state) {
        int N1;
        ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> targetComponents;
        ActivityManagerService activityManagerService = this;
        activityManagerService.mBatteryStatsService.noteUidProcessState(uid, state);
        activityManagerService.mAppOpsService.updateUidProcState(uid, state);
        if (activityManagerService.mTrackingAssociations) {
            int i1 = 0;
            int N12 = activityManagerService.mAssociations.size();
            while (i1 < N12) {
                ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> targetComponents2 = activityManagerService.mAssociations.valueAt(i1);
                int i2 = 0;
                int N2 = targetComponents2.size();
                while (i2 < N2) {
                    SparseArray<ArrayMap<String, Association>> sourceUids = targetComponents2.valueAt(i2);
                    ArrayMap<String, Association> sourceProcesses = sourceUids.get(uid);
                    if (sourceProcesses != null) {
                        int i4 = 0;
                        int N4 = sourceProcesses.size();
                        while (i4 < N4) {
                            Association ass = sourceProcesses.valueAt(i4);
                            if (ass.mNesting < 1) {
                                N1 = N12;
                                targetComponents = targetComponents2;
                            } else {
                                long uptime = SystemClock.uptimeMillis();
                                long[] jArr = ass.mStateTimes;
                                int i = ass.mLastState + 0;
                                N1 = N12;
                                targetComponents = targetComponents2;
                                jArr[i] = jArr[i] + (uptime - ass.mLastStateUptime);
                                ass.mLastState = state;
                                ass.mLastStateUptime = uptime;
                            }
                            i4++;
                            N12 = N1;
                            targetComponents2 = targetComponents;
                        }
                    }
                    i2++;
                    N12 = N12;
                    targetComponents2 = targetComponents2;
                }
                i1++;
                activityManagerService = this;
            }
        }
    }

    /* JADX WARN: Code restructure failed: missing block: B:206:0x047a, code lost:
        if (r11 <= 3) goto L158;
     */
    /* JADX WARN: Code restructure failed: missing block: B:378:0x0866, code lost:
        if (r0.completedAdjSeq < r53.mAdjSeq) goto L452;
     */
    /* JADX WARN: Code restructure failed: missing block: B:545:0x0b84, code lost:
        if (r2.completedAdjSeq < r53.mAdjSeq) goto L366;
     */
    /* JADX WARN: Removed duplicated region for block: B:402:0x08b4  */
    /* JADX WARN: Removed duplicated region for block: B:440:0x091a  */
    /* JADX WARN: Removed duplicated region for block: B:442:0x091f  */
    /* JADX WARN: Removed duplicated region for block: B:447:0x0932  */
    /* JADX WARN: Removed duplicated region for block: B:468:0x0981  */
    /* JADX WARN: Removed duplicated region for block: B:478:0x0997  */
    /* JADX WARN: Removed duplicated region for block: B:484:0x09a1  */
    /* JADX WARN: Removed duplicated region for block: B:488:0x09ad  */
    /* JADX WARN: Removed duplicated region for block: B:661:0x0e22  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    private final boolean computeOomAdjLocked(com.android.server.am.ProcessRecord r54, int r55, com.android.server.am.ProcessRecord r56, boolean r57, long r58) {
        /*
            Method dump skipped, instructions count: 3714
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.computeOomAdjLocked(com.android.server.am.ProcessRecord, int, com.android.server.am.ProcessRecord, boolean, long):boolean");
    }

    void recordPssSampleLocked(final ProcessRecord proc, int procState, long pss, long uss, long swapPss, long rss, int statType, long pssDuration, long now) {
        EventLogTags.writeAmPss(proc.pid, proc.uid, proc.processName, pss * 1024, uss * 1024, swapPss * 1024, rss * 1024, statType, procState, pssDuration);
        proc.lastPssTime = now;
        proc.baseProcessTracker.addPss(pss, uss, rss, true, statType, pssDuration, proc.pkgList);
        if (ActivityManagerDebugConfig.DEBUG_PSS) {
            Slog.d("ActivityManager", "pss of " + proc.toShortString() + ": " + pss + " lastPss=" + proc.lastPss + " state=" + ProcessList.makeProcStateString(procState));
        }
        if (proc.initialIdlePss == 0) {
            proc.initialIdlePss = pss;
        }
        proc.lastPss = pss;
        proc.lastSwapPss = swapPss;
        if (procState >= 13) {
            proc.lastCachedPss = pss;
            proc.lastCachedSwapPss = swapPss;
        }
        SparseArray<Pair<Long, String>> watchUids = (SparseArray) this.mMemWatchProcesses.getMap().get(proc.processName);
        Long check = null;
        if (watchUids != null) {
            Pair<Long, String> val = watchUids.get(proc.uid);
            if (val == null) {
                val = watchUids.get(0);
            }
            if (val != null) {
                check = (Long) val.first;
            }
        }
        if (check != null && pss * 1024 >= check.longValue() && proc.thread != null && this.mMemWatchDumpProcName == null) {
            boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
            if (!isDebuggable && (proc.info.flags & 2) != 0) {
                isDebuggable = true;
            }
            if (isDebuggable) {
                Slog.w("ActivityManager", "Process " + proc + " exceeded pss limit " + check + "; reporting");
                final File heapdumpFile = DumpHeapProvider.getJavaFile();
                this.mMemWatchDumpProcName = proc.processName;
                this.mMemWatchDumpFile = heapdumpFile.toString();
                this.mMemWatchDumpPid = proc.pid;
                this.mMemWatchDumpUid = proc.uid;
                BackgroundThread.getHandler().post(new Runnable() { // from class: com.android.server.am.ActivityManagerService.28
                    @Override // java.lang.Runnable
                    public void run() {
                        ActivityManagerService.this.revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), null, DumpHeapActivity.JAVA_URI, 3, UserHandle.myUserId());
                        ParcelFileDescriptor fd = null;
                        try {
                            try {
                                try {
                                    heapdumpFile.delete();
                                    fd = ParcelFileDescriptor.open(heapdumpFile, 771751936);
                                    IApplicationThread thread = proc.thread;
                                    if (thread != null) {
                                        try {
                                            if (ActivityManagerDebugConfig.DEBUG_PSS) {
                                                Slog.d("ActivityManager", "Requesting dump heap from " + proc + " to " + heapdumpFile);
                                            }
                                            thread.dumpHeap(true, false, false, heapdumpFile.toString(), fd);
                                        } catch (RemoteException e) {
                                        }
                                    }
                                    if (fd != null) {
                                        fd.close();
                                    }
                                } catch (IOException e2) {
                                }
                            } catch (FileNotFoundException e3) {
                                e3.printStackTrace();
                                if (fd != null) {
                                    fd.close();
                                }
                            }
                        } catch (Throwable th) {
                            if (0 != 0) {
                                try {
                                    fd.close();
                                } catch (IOException e4) {
                                }
                            }
                            throw th;
                        }
                    }
                });
                return;
            }
            Slog.w("ActivityManager", "Process " + proc + " exceeded pss limit " + check + ", but debugging not enabled");
        }
    }

    boolean requestPssLocked(ProcessRecord proc, int procState) {
        if (this.mPendingPssProcesses.contains(proc)) {
            return false;
        }
        if (this.mPendingPssProcesses.size() == 0) {
            this.mBgHandler.sendEmptyMessage(1);
        }
        if (ActivityManagerDebugConfig.DEBUG_PSS) {
            Slog.d("ActivityManager", "Requesting pss of: " + proc);
        }
        proc.pssProcState = procState;
        proc.pssStatType = 0;
        this.mPendingPssProcesses.add(proc);
        return true;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void requestPssAllProcsLocked(long now, boolean always, boolean memLowered) {
        if (!always) {
            if (now < this.mLastFullPssTime + (memLowered ? this.mConstants.FULL_PSS_LOWERED_INTERVAL : this.mConstants.FULL_PSS_MIN_INTERVAL)) {
                return;
            }
        }
        if (ActivityManagerDebugConfig.DEBUG_PSS) {
            Slog.d("ActivityManager", "Requesting pss of all procs!  memLowered=" + memLowered);
        }
        this.mLastFullPssTime = now;
        this.mFullPssPending = true;
        for (int i = this.mPendingPssProcesses.size() - 1; i >= 0; i--) {
            ProcessList.abortNextPssTime(this.mPendingPssProcesses.get(i).procStateMemTracker);
        }
        this.mPendingPssProcesses.ensureCapacity(this.mLruProcesses.size());
        this.mPendingPssProcesses.clear();
        for (int i2 = this.mLruProcesses.size() - 1; i2 >= 0; i2--) {
            ProcessRecord app = this.mLruProcesses.get(i2);
            if (app.thread != null && app.curProcState != 19 && (memLowered || ((always && now > app.lastStateTime + 1000) || now > app.lastStateTime + 1200000))) {
                app.pssProcState = app.setProcState;
                app.pssStatType = always ? 2 : 1;
                app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, app.procStateMemTracker, this.mTestPssMode, isSleepingLocked(), now);
                this.mPendingPssProcesses.add(app);
            }
        }
        if (!this.mBgHandler.hasMessages(1)) {
            this.mBgHandler.sendEmptyMessage(1);
        }
    }

    public void setTestPssMode(boolean enabled) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mTestPssMode = enabled;
                if (enabled) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, true);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    final void performAppGcLocked(ProcessRecord app) {
        try {
            app.lastRequestedGc = SystemClock.uptimeMillis();
            if (app.thread != null) {
                if (app.reportLowMemory) {
                    app.reportLowMemory = false;
                    app.thread.scheduleLowMemory();
                } else {
                    app.thread.processInBackground();
                }
            }
        } catch (Exception e) {
        }
    }

    private final boolean canGcNowLocked() {
        BroadcastQueue[] broadcastQueueArr;
        boolean processingBroadcasts = false;
        for (BroadcastQueue q : this.mBroadcastQueues) {
            if (q.mParallelBroadcasts.size() != 0 || q.mOrderedBroadcasts.size() != 0) {
                processingBroadcasts = true;
            }
        }
        if (processingBroadcasts) {
            return false;
        }
        return isSleepingLocked() || this.mStackSupervisor.allResumedActivitiesIdle();
    }

    /* JADX WARN: Removed duplicated region for block: B:9:0x0017  */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    final void performAppGcsLocked() {
        /*
            r6 = this;
            java.util.ArrayList<com.android.server.am.ProcessRecord> r0 = r6.mProcessesToGc
            int r0 = r0.size()
            if (r0 > 0) goto L9
            return
        L9:
            boolean r1 = r6.canGcNowLocked()
            if (r1 == 0) goto L49
        Lf:
            java.util.ArrayList<com.android.server.am.ProcessRecord> r1 = r6.mProcessesToGc
            int r1 = r1.size()
            if (r1 <= 0) goto L46
            java.util.ArrayList<com.android.server.am.ProcessRecord> r1 = r6.mProcessesToGc
            r2 = 0
            java.lang.Object r1 = r1.remove(r2)
            com.android.server.am.ProcessRecord r1 = (com.android.server.am.ProcessRecord) r1
            int r2 = r1.curRawAdj
            r3 = 200(0xc8, float:2.8E-43)
            if (r2 > r3) goto L2c
            boolean r2 = r1.reportLowMemory
            if (r2 == 0) goto L2b
            goto L2c
        L2b:
            goto Lf
        L2c:
            long r2 = r1.lastRequestedGc
            com.android.server.am.ActivityManagerConstants r4 = r6.mConstants
            long r4 = r4.GC_MIN_INTERVAL
            long r2 = r2 + r4
            long r4 = android.os.SystemClock.uptimeMillis()
            int r2 = (r2 > r4 ? 1 : (r2 == r4 ? 0 : -1))
            if (r2 > 0) goto L42
            r6.performAppGcLocked(r1)
            r6.scheduleAppGcsLocked()
            return
        L42:
            r6.addProcessToGcListLocked(r1)
        L46:
            r6.scheduleAppGcsLocked()
        L49:
            return
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.performAppGcsLocked():void");
    }

    final void performAppGcsIfAppropriateLocked() {
        if (canGcNowLocked()) {
            performAppGcsLocked();
        } else {
            scheduleAppGcsLocked();
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public final void scheduleAppGcsLocked() {
        this.mHandler.removeMessages(5);
        if (this.mProcessesToGc.size() > 0) {
            ProcessRecord proc = this.mProcessesToGc.get(0);
            Message msg = this.mHandler.obtainMessage(5);
            long when = proc.lastRequestedGc + this.mConstants.GC_MIN_INTERVAL;
            long now = SystemClock.uptimeMillis();
            if (when < this.mConstants.GC_TIMEOUT + now) {
                when = now + this.mConstants.GC_TIMEOUT;
            }
            this.mHandler.sendMessageAtTime(msg, when);
        }
    }

    final void addProcessToGcListLocked(ProcessRecord proc) {
        boolean added = false;
        int i = this.mProcessesToGc.size() - 1;
        while (true) {
            if (i < 0) {
                break;
            } else if (this.mProcessesToGc.get(i).lastRequestedGc >= proc.lastRequestedGc) {
                i--;
            } else {
                added = true;
                this.mProcessesToGc.add(i + 1, proc);
                break;
            }
        }
        if (!added) {
            this.mProcessesToGc.add(0, proc);
        }
    }

    final void scheduleAppGcLocked(ProcessRecord app) {
        long now = SystemClock.uptimeMillis();
        if (app.lastRequestedGc + this.mConstants.GC_MIN_INTERVAL <= now && !this.mProcessesToGc.contains(app)) {
            addProcessToGcListLocked(app);
            scheduleAppGcsLocked();
        }
    }

    final void checkExcessivePowerUsageLocked() {
        long j;
        boolean doCpuKills;
        long curUptime;
        long uptimeSince;
        ProcessRecord app;
        int cpuLimit;
        ActivityManagerService activityManagerService = this;
        updateCpuStatsNow();
        BatteryStatsImpl stats = activityManagerService.mBatteryStatsService.getActiveStatistics();
        boolean doCpuKills2 = true;
        long j2 = 0;
        if (activityManagerService.mLastPowerCheckUptime == 0) {
            doCpuKills2 = false;
        }
        boolean doCpuKills3 = doCpuKills2;
        long curUptime2 = SystemClock.uptimeMillis();
        long uptimeSince2 = curUptime2 - activityManagerService.mLastPowerCheckUptime;
        activityManagerService.mLastPowerCheckUptime = curUptime2;
        int i = activityManagerService.mLruProcesses.size();
        while (i > 0) {
            int i2 = i - 1;
            ProcessRecord app2 = activityManagerService.mLruProcesses.get(i2);
            if (app2.setProcState >= 13) {
                if (app2.lastCpuTime <= j2) {
                    j = j2;
                    doCpuKills = doCpuKills3;
                    curUptime = curUptime2;
                    uptimeSince = uptimeSince2;
                } else {
                    long cputimeUsed = app2.curCpuTime - app2.lastCpuTime;
                    if (ActivityManagerDebugConfig.DEBUG_POWER) {
                        StringBuilder sb = new StringBuilder(128);
                        sb.append("CPU for ");
                        app2.toShortString(sb);
                        sb.append(": over ");
                        TimeUtils.formatDuration(uptimeSince2, sb);
                        sb.append(" used ");
                        TimeUtils.formatDuration(cputimeUsed, sb);
                        sb.append(" (");
                        sb.append((cputimeUsed * 100) / uptimeSince2);
                        sb.append("%)");
                        Slog.i("ActivityManager", sb.toString());
                    }
                    if (doCpuKills3) {
                        j = 0;
                        if (uptimeSince2 > 0) {
                            long checkDur = curUptime2 - app2.whenUnimportant;
                            doCpuKills = doCpuKills3;
                            curUptime = curUptime2;
                            if (checkDur <= activityManagerService.mConstants.POWER_CHECK_INTERVAL) {
                                cpuLimit = activityManagerService.mConstants.POWER_CHECK_MAX_CPU_1;
                            } else if (checkDur <= activityManagerService.mConstants.POWER_CHECK_INTERVAL * 2 || app2.setProcState <= 13) {
                                cpuLimit = activityManagerService.mConstants.POWER_CHECK_MAX_CPU_2;
                            } else if (checkDur <= activityManagerService.mConstants.POWER_CHECK_INTERVAL * 3) {
                                cpuLimit = activityManagerService.mConstants.POWER_CHECK_MAX_CPU_3;
                            } else {
                                cpuLimit = activityManagerService.mConstants.POWER_CHECK_MAX_CPU_4;
                            }
                            int cpuLimit2 = cpuLimit;
                            if ((100 * cputimeUsed) / uptimeSince2 >= cpuLimit2) {
                                synchronized (stats) {
                                    try {
                                        app = app2;
                                        uptimeSince = uptimeSince2;
                                        try {
                                            stats.reportExcessiveCpuLocked(app2.info.uid, app2.processName, uptimeSince2, cputimeUsed);
                                        } catch (Throwable th) {
                                            th = th;
                                            while (true) {
                                                try {
                                                    break;
                                                } catch (Throwable th2) {
                                                    th = th2;
                                                }
                                            }
                                            throw th;
                                        }
                                    } catch (Throwable th3) {
                                        th = th3;
                                    }
                                }
                                app.kill("excessive cpu " + cputimeUsed + " during " + uptimeSince + " dur=" + checkDur + " limit=" + cpuLimit2, true);
                                app.baseProcessTracker.reportExcessiveCpu(app.pkgList);
                            } else {
                                app = app2;
                                uptimeSince = uptimeSince2;
                            }
                            app.lastCpuTime = app.curCpuTime;
                        } else {
                            app = app2;
                            doCpuKills = doCpuKills3;
                            curUptime = curUptime2;
                        }
                    } else {
                        app = app2;
                        doCpuKills = doCpuKills3;
                        curUptime = curUptime2;
                        j = 0;
                    }
                    uptimeSince = uptimeSince2;
                    app.lastCpuTime = app.curCpuTime;
                }
            } else {
                j = j2;
                doCpuKills = doCpuKills3;
                curUptime = curUptime2;
                uptimeSince = uptimeSince2;
            }
            uptimeSince2 = uptimeSince;
            i = i2;
            j2 = j;
            doCpuKills3 = doCpuKills;
            curUptime2 = curUptime;
            activityManagerService = this;
        }
    }

    private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) {
        int processGroup;
        boolean success = true;
        if (app.curRawAdj != app.setRawAdj) {
            app.setRawAdj = app.curRawAdj;
        }
        int changes = 0;
        if (app.curAdj != app.setAdj) {
            ProcessList.setOomAdj(app.pid, app.uid, app.curAdj);
            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ || this.mCurOomAdjUid == app.info.uid) {
                String msg = "Set " + app.pid + " " + app.processName + " adj " + app.curAdj + ": " + app.adjType;
                reportOomAdjMessageLocked("ActivityManager", msg);
            }
            app.setAdj = app.curAdj;
            app.verifiedAdj = -10000;
        }
        if (app.setSchedGroup != app.curSchedGroup) {
            int oldSchedGroup = app.setSchedGroup;
            app.setSchedGroup = app.curSchedGroup;
            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ || this.mCurOomAdjUid == app.uid) {
                String msg2 = "Setting sched group of " + app.processName + " to " + app.curSchedGroup + ": " + app.adjType;
                reportOomAdjMessageLocked("ActivityManager", msg2);
            }
            String msg3 = app.waitingToKill;
            if (msg3 != null && app.curReceivers.isEmpty() && app.setSchedGroup == 0) {
                app.kill(app.waitingToKill, true);
                success = false;
            } else {
                switch (app.curSchedGroup) {
                    case 0:
                        processGroup = 0;
                        break;
                    case 1:
                        processGroup = 7;
                        break;
                    case 2:
                    default:
                        processGroup = -1;
                        break;
                    case 3:
                    case 4:
                        processGroup = 5;
                        break;
                }
                int processGroup2 = processGroup;
                long oldId = Binder.clearCallingIdentity();
                try {
                    Process.setProcessGroup(app.pid, processGroup2);
                    if (app.curSchedGroup == 3) {
                        if (oldSchedGroup != 3) {
                            this.mVrController.onTopProcChangedLocked(app);
                            if (this.mUseFifoUiScheduling) {
                                app.savedPriority = Process.getThreadPriority(app.pid);
                                scheduleAsFifoPriority(app.pid, true);
                                if (app.renderThreadTid != 0) {
                                    scheduleAsFifoPriority(app.renderThreadTid, true);
                                    if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                        Slog.d("UI_FIFO", "Set RenderThread (TID " + app.renderThreadTid + ") to FIFO");
                                    }
                                } else if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                    Slog.d("UI_FIFO", "Not setting RenderThread TID");
                                }
                            } else {
                                Process.setThreadPriority(app.pid, -10);
                                if (app.renderThreadTid != 0) {
                                    try {
                                        Process.setThreadPriority(app.renderThreadTid, -10);
                                    } catch (IllegalArgumentException e) {
                                    }
                                }
                            }
                        }
                    } else if (oldSchedGroup == 3 && app.curSchedGroup != 3) {
                        this.mVrController.onTopProcChangedLocked(app);
                        if (this.mUseFifoUiScheduling) {
                            try {
                                Process.setThreadScheduler(app.pid, 0, 0);
                                Process.setThreadPriority(app.pid, app.savedPriority);
                                if (app.renderThreadTid != 0) {
                                    Process.setThreadScheduler(app.renderThreadTid, 0, 0);
                                    Process.setThreadPriority(app.renderThreadTid, -4);
                                }
                            } catch (IllegalArgumentException e2) {
                                Slog.w("ActivityManager", "Failed to set scheduling policy, thread does not exist:\n" + e2);
                            } catch (SecurityException e3) {
                                Slog.w("ActivityManager", "Failed to set scheduling policy, not allowed:\n" + e3);
                            }
                        } else {
                            Process.setThreadPriority(app.pid, 0);
                            if (app.renderThreadTid != 0) {
                                Process.setThreadPriority(app.renderThreadTid, 0);
                            }
                        }
                    }
                } catch (Exception e4) {
                } catch (Throwable th) {
                    Binder.restoreCallingIdentity(oldId);
                    throw th;
                }
                Binder.restoreCallingIdentity(oldId);
            }
        }
        boolean success2 = success;
        if (app.repForegroundActivities != app.foregroundActivities) {
            app.repForegroundActivities = app.foregroundActivities;
            changes = 0 | 1;
        }
        int changes2 = changes;
        if (app.repProcState != app.curProcState) {
            app.repProcState = app.curProcState;
            if (app.thread != null) {
                try {
                    app.thread.setProcessState(app.repProcState);
                } catch (RemoteException e5) {
                }
            }
        }
        if (app.setProcState == 19 || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) {
            app.lastStateTime = now;
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, app.procStateMemTracker, this.mTestPssMode, isSleepingLocked(), now);
            if (ActivityManagerDebugConfig.DEBUG_PSS) {
                Slog.d("ActivityManager", "Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to " + ProcessList.makeProcStateString(app.curProcState) + " next pss in " + (app.nextPssTime - now) + ": " + app);
            }
        } else if ((now > app.nextPssTime || (now > app.lastPssTime + 3600000 && now > app.lastStateTime + ProcessList.minTimeFromStateChange(this.mTestPssMode))) && requestPssLocked(app, app.setProcState)) {
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, app.procStateMemTracker, this.mTestPssMode, isSleepingLocked(), now);
        }
        if (app.setProcState == app.curProcState) {
            if (app.reportedInteraction && nowElapsed - app.interactionEventTime > this.mConstants.USAGE_STATS_INTERACTION_INTERVAL) {
                maybeUpdateUsageStatsLocked(app, nowElapsed);
            }
        } else {
            if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ || this.mCurOomAdjUid == app.uid) {
                String msg4 = "Proc state change of " + app.processName + " to " + ProcessList.makeProcStateString(app.curProcState) + " (" + app.curProcState + "): " + app.adjType;
                reportOomAdjMessageLocked("ActivityManager", msg4);
            }
            boolean setImportant = app.setProcState < 9;
            boolean curImportant = app.curProcState < 9;
            if (setImportant && !curImportant) {
                app.whenUnimportant = now;
                app.lastCpuTime = 0L;
            }
            maybeUpdateUsageStatsLocked(app, nowElapsed);
            maybeUpdateLastTopTime(app, now);
            app.setProcState = app.curProcState;
            if (app.setProcState >= 13) {
                app.notCachedSinceIdle = false;
            }
            if (!doingAll) {
                setProcessTrackerStateLocked(app, this.mProcessStats.getMemFactorLocked(), now);
            } else {
                app.procStateChanged = true;
            }
        }
        if (changes2 != 0) {
            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                Slog.i("ActivityManager", "Changes in " + app + ": " + changes2);
            }
            int i = this.mPendingProcessChanges.size() - 1;
            ProcessChangeItem item = null;
            while (true) {
                if (i >= 0) {
                    ProcessChangeItem item2 = this.mPendingProcessChanges.get(i);
                    item = item2;
                    if (item.pid == app.pid) {
                        if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                            Slog.i("ActivityManager", "Re-using existing item: " + item);
                        }
                    } else {
                        i--;
                    }
                }
            }
            if (i < 0) {
                int NA = this.mAvailProcessChanges.size();
                if (NA > 0) {
                    ProcessChangeItem item3 = this.mAvailProcessChanges.remove(NA - 1);
                    item = item3;
                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                        Slog.i("ActivityManager", "Retrieving available item: " + item);
                    }
                } else {
                    item = new ProcessChangeItem();
                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                        Slog.i("ActivityManager", "Allocating new item: " + item);
                    }
                }
                item.changes = 0;
                item.pid = app.pid;
                item.uid = app.info.uid;
                if (this.mPendingProcessChanges.size() == 0) {
                    if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                        Slog.i("ActivityManager", "*** Enqueueing dispatch processes changed!");
                    }
                    this.mUiHandler.obtainMessage(31).sendToTarget();
                }
                this.mPendingProcessChanges.add(item);
            }
            item.changes |= changes2;
            item.foregroundActivities = app.repForegroundActivities;
            if (ActivityManagerDebugConfig.DEBUG_PROCESS_OBSERVERS) {
                Slog.i("ActivityManager", "Item " + Integer.toHexString(System.identityHashCode(item)) + " " + app.toShortString() + ": changes=" + item.changes + " foreground=" + item.foregroundActivities + " type=" + app.adjType + " source=" + app.adjSource + " target=" + app.adjTarget);
            }
        }
        return success2;
    }

    private boolean isEphemeralLocked(int uid) {
        String[] packages = this.mContext.getPackageManager().getPackagesForUid(uid);
        if (packages == null || packages.length != 1) {
            return false;
        }
        return getPackageManagerInternalLocked().isPackageEphemeral(UserHandle.getUserId(uid), packages[0]);
    }

    @VisibleForTesting
    final void enqueueUidChangeLocked(UidRecord uidRec, int uid, int change) {
        UidRecord.ChangeItem pendingChange;
        UidRecord.ChangeItem pendingChange2;
        if (uidRec == null || uidRec.pendingChange == null) {
            if (this.mPendingUidChanges.size() == 0) {
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i("ActivityManager", "*** Enqueueing dispatch uid changed!");
                }
                this.mUiHandler.obtainMessage(53).sendToTarget();
            }
            int NA = this.mAvailUidChanges.size();
            if (NA > 0) {
                pendingChange = this.mAvailUidChanges.remove(NA - 1);
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i("ActivityManager", "Retrieving available item: " + pendingChange);
                }
            } else {
                pendingChange = new UidRecord.ChangeItem();
                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                    Slog.i("ActivityManager", "Allocating new item: " + pendingChange);
                }
            }
            if (uidRec != null) {
                uidRec.pendingChange = pendingChange;
                if ((change & 1) != 0 && !uidRec.idle) {
                    change |= 2;
                }
            } else if (uid < 0) {
                throw new IllegalArgumentException("No UidRecord or uid");
            }
            pendingChange.uidRecord = uidRec;
            pendingChange.uid = uidRec != null ? uidRec.uid : uid;
            this.mPendingUidChanges.add(pendingChange);
            pendingChange2 = pendingChange;
        } else {
            pendingChange2 = uidRec.pendingChange;
            if ((change & 6) == 0) {
                change |= pendingChange2.change & 6;
            }
            if ((change & 24) == 0) {
                change |= pendingChange2.change & 24;
            }
            if ((change & 1) != 0) {
                change &= -13;
                if (!uidRec.idle) {
                    change |= 2;
                }
            }
        }
        pendingChange2.change = change;
        pendingChange2.processState = uidRec != null ? uidRec.setProcState : 19;
        pendingChange2.ephemeral = uidRec != null ? uidRec.ephemeral : isEphemeralLocked(uid);
        pendingChange2.procStateSeq = uidRec != null ? uidRec.curProcStateSeq : 0L;
        if (uidRec != null) {
            uidRec.lastReportedChange = change;
            uidRec.updateLastDispatchedProcStateSeq(change);
        }
        if (this.mLocalPowerManager != null) {
            if ((change & 4) != 0) {
                this.mLocalPowerManager.uidActive(pendingChange2.uid);
            }
            if ((change & 2) != 0) {
                this.mLocalPowerManager.uidIdle(pendingChange2.uid);
            }
            if ((change & 1) != 0) {
                this.mLocalPowerManager.uidGone(pendingChange2.uid);
            } else {
                this.mLocalPowerManager.updateUidProcState(pendingChange2.uid, pendingChange2.processState);
            }
        }
    }

    private void maybeUpdateProviderUsageStatsLocked(ProcessRecord app, String providerPkgName, String authority) {
        UserState userState;
        if (app == null || app.curProcState > 5 || (userState = this.mUserController.getStartedUserState(app.userId)) == null) {
            return;
        }
        long now = SystemClock.elapsedRealtime();
        Long lastReported = userState.mProviderLastReportedFg.get(authority);
        if (lastReported == null || lastReported.longValue() < now - 60000) {
            if (this.mSystemReady) {
                this.mUsageStatsService.reportContentProviderUsage(authority, providerPkgName, app.userId);
            }
            userState.mProviderLastReportedFg.put(authority, Long.valueOf(now));
        }
    }

    private void maybeUpdateUsageStatsLocked(ProcessRecord app, long nowElapsed) {
        boolean isInteraction;
        if (ActivityManagerDebugConfig.DEBUG_USAGE_STATS) {
            Slog.d("ActivityManager", "Checking proc [" + Arrays.toString(app.getPackageList()) + "] state changes: old = " + app.setProcState + ", new = " + app.curProcState);
        }
        if (this.mUsageStatsService == null) {
            return;
        }
        if (app.curProcState <= 2) {
            isInteraction = true;
            app.fgInteractionTime = 0L;
        } else if (app.curProcState <= 3) {
            if (app.fgInteractionTime == 0) {
                app.fgInteractionTime = nowElapsed;
                isInteraction = false;
            } else {
                isInteraction = nowElapsed > app.fgInteractionTime + this.mConstants.SERVICE_USAGE_INTERACTION_TIME;
            }
        } else {
            isInteraction = app.curProcState <= 5;
            app.fgInteractionTime = 0L;
        }
        if (isInteraction && (!app.reportedInteraction || nowElapsed - app.interactionEventTime > this.mConstants.USAGE_STATS_INTERACTION_INTERVAL)) {
            app.interactionEventTime = nowElapsed;
            String[] packages = app.getPackageList();
            if (packages != null) {
                for (String str : packages) {
                    this.mUsageStatsService.reportEvent(str, app.userId, 6);
                }
            }
        }
        app.reportedInteraction = isInteraction;
        if (!isInteraction) {
            app.interactionEventTime = 0L;
        }
    }

    private void maybeUpdateLastTopTime(ProcessRecord app, long nowUptime) {
        if (app.setProcState <= 2 && app.curProcState > 2) {
            app.lastTopTime = nowUptime;
        }
    }

    private final void setProcessTrackerStateLocked(ProcessRecord proc, int memFactor, long now) {
        if (proc.thread != null && proc.baseProcessTracker != null) {
            proc.baseProcessTracker.setState(proc.repProcState, memFactor, now, proc.pkgList);
        }
    }

    private final boolean updateOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
        if (app.thread == null) {
            return false;
        }
        computeOomAdjLocked(app, cachedAdj, TOP_APP, doingAll, now);
        return applyOomAdjLocked(app, doingAll, now, SystemClock.elapsedRealtime());
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public final void updateProcessForegroundLocked(ProcessRecord proc, boolean isForeground, boolean oomAdj) {
        if (isForeground != proc.foregroundServices) {
            proc.foregroundServices = isForeground;
            ArrayList<ProcessRecord> curProcs = (ArrayList) this.mForegroundPackages.get(proc.info.packageName, proc.info.uid);
            if (isForeground) {
                if (curProcs == null) {
                    curProcs = new ArrayList<>();
                    this.mForegroundPackages.put(proc.info.packageName, proc.info.uid, curProcs);
                }
                if (!curProcs.contains(proc)) {
                    curProcs.add(proc);
                    this.mBatteryStatsService.noteEvent(32770, proc.info.packageName, proc.info.uid);
                }
            } else if (curProcs != null && curProcs.remove(proc)) {
                this.mBatteryStatsService.noteEvent(16386, proc.info.packageName, proc.info.uid);
                if (curProcs.size() <= 0) {
                    this.mForegroundPackages.remove(proc.info.packageName, proc.info.uid);
                }
            }
            if (oomAdj) {
                updateOomAdjLocked();
            }
        }
    }

    private final ActivityRecord resumedAppLocked() {
        String pkg;
        int uid;
        ActivityRecord act = this.mStackSupervisor.getResumedActivityLocked();
        if (act != null) {
            pkg = act.packageName;
            uid = act.info.applicationInfo.uid;
        } else {
            pkg = null;
            uid = -1;
        }
        if (uid != this.mCurResumedUid || (pkg != this.mCurResumedPackage && (pkg == null || !pkg.equals(this.mCurResumedPackage)))) {
            if (this.mCurResumedPackage != null) {
                this.mBatteryStatsService.noteEvent(16387, this.mCurResumedPackage, this.mCurResumedUid);
            }
            this.mCurResumedPackage = pkg;
            this.mCurResumedUid = uid;
            if (this.mCurResumedPackage != null) {
                this.mBatteryStatsService.noteEvent(32771, this.mCurResumedPackage, this.mCurResumedUid);
            }
        }
        return act;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public final boolean updateOomAdjLocked(ProcessRecord app, boolean oomAdjAll) {
        ActivityRecord TOP_ACT = resumedAppLocked();
        ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;
        boolean wasCached = app.cached;
        this.mAdjSeq++;
        int cachedAdj = app.curRawAdj >= 900 ? app.curRawAdj : 1001;
        boolean success = updateOomAdjLocked(app, cachedAdj, TOP_APP, false, SystemClock.uptimeMillis());
        if (oomAdjAll && (wasCached != app.cached || app.curRawAdj == 1001)) {
            updateOomAdjLocked();
        }
        return success;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public final void updateOomAdjLocked() {
        int cycleCount;
        int i;
        long nowElapsed;
        int uidChange;
        int uidChange2;
        int fgTrimLevel;
        int numEmpty;
        int numEmpty2;
        int cachedProcessLimit;
        int numCachedAndEmpty;
        int factor;
        StringBuilder sb;
        StringBuilder sb2;
        int cycleCount2;
        int nextCachedAdj;
        ProcessRecord app;
        int numEmpty3;
        boolean z;
        int numCached;
        int cachedProcessLimit2;
        int emptyProcessLimit;
        int emptyFactor;
        int nextEmptyAdj;
        int i2;
        long now;
        long nowElapsed2;
        int curCachedAdj;
        int curCachedAdj2;
        int emptyFactor2;
        int cachedProcessLimit3;
        int emptyProcessLimit2;
        ActivityRecord TOP_ACT;
        int nextCachedAdj2;
        int emptyProcessLimit3;
        ActivityManagerService activityManagerService = this;
        ActivityRecord TOP_ACT2 = resumedAppLocked();
        ProcessRecord TOP_APP = TOP_ACT2 != null ? TOP_ACT2.app : null;
        long now2 = SystemClock.uptimeMillis();
        long nowElapsed3 = SystemClock.elapsedRealtime();
        long oldTime = now2 - 1800000;
        int N = activityManagerService.mLruProcesses.size();
        for (int i3 = activityManagerService.mActiveUids.size() - 1; i3 >= 0; i3--) {
            activityManagerService.mActiveUids.valueAt(i3).reset();
        }
        activityManagerService.mStackSupervisor.rankTaskLayersIfNeeded();
        activityManagerService.mAdjSeq++;
        activityManagerService.mNewNumServiceProcs = 0;
        activityManagerService.mNewNumAServiceProcs = 0;
        int emptyProcessLimit4 = activityManagerService.mConstants.CUR_MAX_EMPTY_PROCESSES;
        int cachedProcessLimit4 = activityManagerService.mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit4;
        int numEmptyProcs = (N - activityManagerService.mNumNonCachedProcs) - activityManagerService.mNumCachedHiddenProcs;
        if (numEmptyProcs > cachedProcessLimit4) {
            numEmptyProcs = cachedProcessLimit4;
        }
        int emptyFactor3 = numEmptyProcs / 3;
        if (emptyFactor3 < 1) {
            emptyFactor3 = 1;
        }
        int emptyFactor4 = emptyFactor3;
        int cachedFactor = (activityManagerService.mNumCachedHiddenProcs > 0 ? activityManagerService.mNumCachedHiddenProcs : 1) / 3;
        if (cachedFactor < 1) {
            cachedFactor = 1;
        }
        int cachedFactor2 = cachedFactor;
        int stepEmpty = 0;
        int numTrimming = 0;
        activityManagerService.mNumNonCachedProcs = 0;
        activityManagerService.mNumCachedHiddenProcs = 0;
        int nextCachedAdj3 = 900 + 1;
        int nextEmptyAdj2 = 900 + 2;
        boolean retryCycles = false;
        int i4 = N - 1;
        while (true) {
            int i5 = i4;
            if (i5 < 0) {
                break;
            }
            activityManagerService.mLruProcesses.get(i5).containsCycle = false;
            i4 = i5 - 1;
        }
        int emptyFactor5 = N - 1;
        int stepCached = 0;
        long nowElapsed4 = nowElapsed3;
        int curCachedAdj3 = 900;
        int nextCachedAdj4 = nextCachedAdj3;
        int curEmptyAdj = 900;
        int nextEmptyAdj3 = nextEmptyAdj2;
        while (true) {
            int stepCached2 = emptyFactor5;
            if (stepCached2 >= 0) {
                ProcessRecord app2 = activityManagerService.mLruProcesses.get(stepCached2);
                if (app2.killedByAm || app2.thread == null) {
                    emptyFactor2 = emptyFactor4;
                    cachedProcessLimit3 = cachedProcessLimit4;
                    emptyProcessLimit2 = emptyProcessLimit4;
                    TOP_ACT = TOP_ACT2;
                    nextCachedAdj2 = nextCachedAdj4;
                    emptyProcessLimit3 = N;
                } else {
                    app2.procStateChanged = false;
                    int emptyFactor6 = emptyFactor4;
                    cachedProcessLimit3 = cachedProcessLimit4;
                    TOP_ACT = TOP_ACT2;
                    emptyProcessLimit2 = emptyProcessLimit4;
                    emptyProcessLimit3 = N;
                    activityManagerService.computeOomAdjLocked(app2, NetworkAgentInfo.EVENT_NETWORK_LINGER_COMPLETE, TOP_APP, true, now2);
                    boolean retryCycles2 = retryCycles | app2.containsCycle;
                    if (app2.curAdj >= 1001) {
                        switch (app2.curProcState) {
                            case 15:
                            case 16:
                            case 17:
                                app2.curRawAdj = curCachedAdj3;
                                app2.curAdj = app2.modifyRawOomAdj(curCachedAdj3);
                                boolean z2 = ActivityManagerDebugConfig.DEBUG_LRU;
                                nextCachedAdj2 = nextCachedAdj4;
                                if (curCachedAdj3 != nextCachedAdj2) {
                                    int stepCached3 = stepCached + 1;
                                    if (stepCached3 >= cachedFactor2) {
                                        int nextCachedAdj5 = nextCachedAdj2 + 2;
                                        if (nextCachedAdj5 > 906) {
                                            nextCachedAdj5 = 906;
                                        }
                                        retryCycles = retryCycles2;
                                        nextCachedAdj4 = nextCachedAdj5;
                                        stepCached = 0;
                                        curCachedAdj3 = nextCachedAdj2;
                                    } else {
                                        retryCycles = retryCycles2;
                                        nextCachedAdj4 = nextCachedAdj2;
                                        stepCached = stepCached3;
                                    }
                                    emptyFactor2 = emptyFactor6;
                                    break;
                                } else {
                                    emptyFactor2 = emptyFactor6;
                                    break;
                                }
                            default:
                                nextCachedAdj2 = nextCachedAdj4;
                                app2.curRawAdj = curEmptyAdj;
                                app2.curAdj = app2.modifyRawOomAdj(curEmptyAdj);
                                boolean z3 = ActivityManagerDebugConfig.DEBUG_LRU;
                                if (curEmptyAdj != nextEmptyAdj3) {
                                    int stepEmpty2 = stepEmpty + 1;
                                    emptyFactor2 = emptyFactor6;
                                    if (stepEmpty2 >= emptyFactor2) {
                                        int i6 = nextEmptyAdj3;
                                        nextEmptyAdj3 += 2;
                                        if (nextEmptyAdj3 > 906) {
                                            retryCycles = retryCycles2;
                                            nextCachedAdj4 = nextCachedAdj2;
                                            nextEmptyAdj3 = 906;
                                        } else {
                                            retryCycles = retryCycles2;
                                            nextCachedAdj4 = nextCachedAdj2;
                                        }
                                        stepEmpty = 0;
                                        curEmptyAdj = i6;
                                        break;
                                    } else {
                                        retryCycles = retryCycles2;
                                        nextCachedAdj4 = nextCachedAdj2;
                                        stepEmpty = stepEmpty2;
                                        break;
                                    }
                                } else {
                                    emptyFactor2 = emptyFactor6;
                                    break;
                                }
                        }
                        int i7 = stepCached2 - 1;
                        emptyFactor4 = emptyFactor2;
                        N = emptyProcessLimit3;
                        cachedProcessLimit4 = cachedProcessLimit3;
                        TOP_ACT2 = TOP_ACT;
                        emptyProcessLimit4 = emptyProcessLimit2;
                        activityManagerService = this;
                        emptyFactor5 = i7;
                    } else {
                        nextCachedAdj2 = nextCachedAdj4;
                        emptyFactor2 = emptyFactor6;
                    }
                    retryCycles = retryCycles2;
                }
                nextCachedAdj4 = nextCachedAdj2;
                int i72 = stepCached2 - 1;
                emptyFactor4 = emptyFactor2;
                N = emptyProcessLimit3;
                cachedProcessLimit4 = cachedProcessLimit3;
                TOP_ACT2 = TOP_ACT;
                emptyProcessLimit4 = emptyProcessLimit2;
                activityManagerService = this;
                emptyFactor5 = i72;
            } else {
                int emptyFactor7 = emptyFactor4;
                int cachedProcessLimit5 = cachedProcessLimit4;
                int emptyProcessLimit5 = emptyProcessLimit4;
                int nextCachedAdj6 = nextCachedAdj4;
                int N2 = N;
                int cycleCount3 = 0;
                while (true) {
                    cycleCount = cycleCount3;
                    if (retryCycles && cycleCount < 10) {
                        cycleCount3 = cycleCount + 1;
                        int i8 = 0;
                        while (i8 < N2) {
                            ProcessRecord app3 = this.mLruProcesses.get(i8);
                            if (app3.killedByAm || app3.thread == null) {
                                curCachedAdj2 = curCachedAdj3;
                            } else {
                                curCachedAdj2 = curCachedAdj3;
                                if (app3.containsCycle) {
                                    app3.adjSeq--;
                                    app3.completedAdjSeq--;
                                }
                            }
                            i8++;
                            curCachedAdj3 = curCachedAdj2;
                        }
                        int curCachedAdj4 = curCachedAdj3;
                        int curCachedAdj5 = 1;
                        retryCycles = false;
                        int i9 = 0;
                        while (i9 < N2) {
                            ProcessRecord app4 = this.mLruProcesses.get(i9);
                            if (app4.killedByAm || app4.thread == null || app4.containsCycle != curCachedAdj5) {
                                emptyFactor = emptyFactor7;
                                nextEmptyAdj = nextEmptyAdj3;
                                i2 = curCachedAdj5;
                                now = now2;
                                nowElapsed2 = nowElapsed4;
                                curCachedAdj = curCachedAdj4;
                            } else {
                                emptyFactor = emptyFactor7;
                                nextEmptyAdj = nextEmptyAdj3;
                                nowElapsed2 = nowElapsed4;
                                i2 = curCachedAdj5;
                                curCachedAdj = curCachedAdj4;
                                now = now2;
                                if (computeOomAdjLocked(app4, NetworkAgentInfo.EVENT_NETWORK_LINGER_COMPLETE, TOP_APP, true, now2)) {
                                    retryCycles = true;
                                }
                            }
                            i9++;
                            curCachedAdj5 = i2;
                            curCachedAdj4 = curCachedAdj;
                            emptyFactor7 = emptyFactor;
                            nextEmptyAdj3 = nextEmptyAdj;
                            nowElapsed4 = nowElapsed2;
                            now2 = now;
                        }
                        curCachedAdj3 = curCachedAdj4;
                    }
                }
                long now3 = now2;
                long nowElapsed5 = nowElapsed4;
                boolean z4 = true;
                int i10 = N2 - 1;
                int numCached2 = 0;
                int numEmpty4 = 0;
                while (true) {
                    int i11 = i10;
                    if (i11 < 0) {
                        int trackerMemFactor = numEmpty4;
                        int cycleCount4 = numCached2;
                        int cachedProcessLimit6 = cachedProcessLimit5;
                        int emptyProcessLimit6 = emptyProcessLimit5;
                        incrementProcStateSeqAndNotifyAppsLocked();
                        this.mNumServiceProcs = this.mNewNumServiceProcs;
                        int numCachedAndEmpty2 = cycleCount4 + trackerMemFactor;
                        int memFactor = (cycleCount4 > this.mConstants.CUR_TRIM_CACHED_PROCESSES || trackerMemFactor > this.mConstants.CUR_TRIM_EMPTY_PROCESSES) ? 0 : numCachedAndEmpty2 <= 3 ? 3 : numCachedAndEmpty2 <= 5 ? 2 : 1;
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                            Slog.d("ActivityManager", "oom: memFactor=" + memFactor + " last=" + this.mLastMemoryLevel + " allowLow=" + this.mAllowLowerMemLevel + " numProcs=" + this.mLruProcesses.size() + " last=" + this.mLastNumProcesses);
                        }
                        if (memFactor > this.mLastMemoryLevel && (!this.mAllowLowerMemLevel || this.mLruProcesses.size() >= this.mLastNumProcesses)) {
                            memFactor = this.mLastMemoryLevel;
                            if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                Slog.d("ActivityManager", "Keeping last mem factor!");
                            }
                        }
                        int memFactor2 = memFactor;
                        if (memFactor2 != this.mLastMemoryLevel) {
                            EventLogTags.writeAmMemFactor(memFactor2, this.mLastMemoryLevel);
                        }
                        this.mLastMemoryLevel = memFactor2;
                        this.mLastNumProcesses = this.mLruProcesses.size();
                        boolean allChanged = this.mProcessStats.setMemFactorLocked(memFactor2, !isSleepingLocked(), now3);
                        int trackerMemFactor2 = this.mProcessStats.getMemFactorLocked();
                        if (memFactor2 != 0) {
                            if (this.mLowRamStartTime == 0) {
                                this.mLowRamStartTime = now3;
                            }
                            switch (memFactor2) {
                                case 2:
                                    fgTrimLevel = 10;
                                    break;
                                case 3:
                                    fgTrimLevel = 15;
                                    break;
                                default:
                                    fgTrimLevel = 5;
                                    break;
                            }
                            int factor2 = numTrimming / 3;
                            int step = 0;
                            int minFactor = this.mHomeProcess != null ? 2 + 1 : 2;
                            if (this.mPreviousProcess != null) {
                                minFactor++;
                            }
                            int minFactor2 = minFactor;
                            if (factor2 < minFactor2) {
                                factor2 = minFactor2;
                            }
                            int i12 = N2 - 1;
                            int curLevel = 80;
                            while (true) {
                                int i13 = i12;
                                ProcessRecord TOP_APP2 = TOP_APP;
                                if (i13 >= 0) {
                                    int emptyProcessLimit7 = emptyProcessLimit6;
                                    ProcessRecord app5 = this.mLruProcesses.get(i13);
                                    if (allChanged || app5.procStateChanged) {
                                        numEmpty = trackerMemFactor;
                                        numEmpty2 = trackerMemFactor2;
                                        setProcessTrackerStateLocked(app5, numEmpty2, now3);
                                        cachedProcessLimit = cachedProcessLimit6;
                                        app5.procStateChanged = false;
                                    } else {
                                        numEmpty = trackerMemFactor;
                                        cachedProcessLimit = cachedProcessLimit6;
                                        numEmpty2 = trackerMemFactor2;
                                    }
                                    if (app5.curProcState < 13 || app5.killedByAm) {
                                        numCachedAndEmpty = numCachedAndEmpty2;
                                        if (app5.curProcState != 12 || app5.killedByAm) {
                                            if (app5.curProcState < 6 && !app5.systemNoUi) {
                                                factor = factor2;
                                            } else if (app5.pendingUiClean) {
                                                if (app5.trimMemoryLevel >= 20 || app5.thread == null) {
                                                    factor = factor2;
                                                } else {
                                                    try {
                                                        try {
                                                            if (!ActivityManagerDebugConfig.DEBUG_SWITCH) {
                                                                try {
                                                                    if (!ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                                                        factor = factor2;
                                                                        app5.thread.scheduleTrimMemory(20);
                                                                    }
                                                                } catch (RemoteException e) {
                                                                    factor = factor2;
                                                                }
                                                            }
                                                            sb.append("Trimming memory of bg-ui ");
                                                            sb.append(app5.processName);
                                                            sb.append(" to ");
                                                            sb.append(20);
                                                            Slog.v("ActivityManager", sb.toString());
                                                            app5.thread.scheduleTrimMemory(20);
                                                        } catch (RemoteException e2) {
                                                        }
                                                        sb = new StringBuilder();
                                                        factor = factor2;
                                                    } catch (RemoteException e3) {
                                                        factor = factor2;
                                                    }
                                                }
                                                app5.pendingUiClean = false;
                                            } else {
                                                factor = factor2;
                                            }
                                            if (app5.trimMemoryLevel < fgTrimLevel && app5.thread != null) {
                                                try {
                                                    if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                                        Slog.v("ActivityManager", "Trimming memory of fg " + app5.processName + " to " + fgTrimLevel);
                                                    }
                                                    app5.thread.scheduleTrimMemory(fgTrimLevel);
                                                } catch (RemoteException e4) {
                                                }
                                            }
                                            app5.trimMemoryLevel = fgTrimLevel;
                                            i12 = i13 - 1;
                                            trackerMemFactor2 = numEmpty2;
                                            TOP_APP = TOP_APP2;
                                            emptyProcessLimit6 = emptyProcessLimit7;
                                            trackerMemFactor = numEmpty;
                                            cachedProcessLimit6 = cachedProcessLimit;
                                            numCachedAndEmpty2 = numCachedAndEmpty;
                                            factor2 = factor;
                                        } else {
                                            if (app5.trimMemoryLevel < 40 && app5.thread != null) {
                                                try {
                                                    if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                                        Slog.v("ActivityManager", "Trimming memory of heavy-weight " + app5.processName + " to 40");
                                                    }
                                                    app5.thread.scheduleTrimMemory(40);
                                                } catch (RemoteException e5) {
                                                }
                                            }
                                            app5.trimMemoryLevel = 40;
                                        }
                                    } else {
                                        if (app5.trimMemoryLevel >= curLevel || app5.thread == null) {
                                            numCachedAndEmpty = numCachedAndEmpty2;
                                        } else {
                                            try {
                                                try {
                                                    if (!ActivityManagerDebugConfig.DEBUG_SWITCH) {
                                                        try {
                                                            if (!ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                                                numCachedAndEmpty = numCachedAndEmpty2;
                                                                app5.thread.scheduleTrimMemory(curLevel);
                                                            }
                                                        } catch (RemoteException e6) {
                                                            numCachedAndEmpty = numCachedAndEmpty2;
                                                        }
                                                    }
                                                    sb2.append("Trimming memory of ");
                                                    sb2.append(app5.processName);
                                                    sb2.append(" to ");
                                                    sb2.append(curLevel);
                                                    Slog.v("ActivityManager", sb2.toString());
                                                    app5.thread.scheduleTrimMemory(curLevel);
                                                } catch (RemoteException e7) {
                                                }
                                                sb2 = new StringBuilder();
                                                numCachedAndEmpty = numCachedAndEmpty2;
                                            } catch (RemoteException e8) {
                                                numCachedAndEmpty = numCachedAndEmpty2;
                                            }
                                        }
                                        app5.trimMemoryLevel = curLevel;
                                        int step2 = step + 1;
                                        if (step2 >= factor2) {
                                            step2 = 0;
                                            if (curLevel == 60) {
                                                curLevel = 40;
                                            } else if (curLevel == 80) {
                                                curLevel = 60;
                                            }
                                        }
                                        step = step2;
                                    }
                                    factor = factor2;
                                    i12 = i13 - 1;
                                    trackerMemFactor2 = numEmpty2;
                                    TOP_APP = TOP_APP2;
                                    emptyProcessLimit6 = emptyProcessLimit7;
                                    trackerMemFactor = numEmpty;
                                    cachedProcessLimit6 = cachedProcessLimit;
                                    numCachedAndEmpty2 = numCachedAndEmpty;
                                    factor2 = factor;
                                }
                            }
                        } else {
                            if (this.mLowRamStartTime != 0) {
                                this.mLowRamTimeSinceLastIdle += now3 - this.mLowRamStartTime;
                                this.mLowRamStartTime = 0L;
                            }
                            int i14 = N2 - 1;
                            while (true) {
                                int i15 = i14;
                                if (i15 >= 0) {
                                    ProcessRecord app6 = this.mLruProcesses.get(i15);
                                    if (allChanged || app6.procStateChanged) {
                                        setProcessTrackerStateLocked(app6, trackerMemFactor2, now3);
                                        app6.procStateChanged = false;
                                    }
                                    if ((app6.curProcState >= 6 || app6.systemNoUi) && app6.pendingUiClean) {
                                        if (app6.trimMemoryLevel < 20 && app6.thread != null) {
                                            try {
                                                if (ActivityManagerDebugConfig.DEBUG_SWITCH || ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                                                    StringBuilder sb3 = new StringBuilder();
                                                    sb3.append("Trimming memory of ui hidden ");
                                                    sb3.append(app6.processName);
                                                    sb3.append(" to ");
                                                    try {
                                                        sb3.append(20);
                                                        Slog.v("ActivityManager", sb3.toString());
                                                    } catch (RemoteException e9) {
                                                    }
                                                }
                                                try {
                                                    app6.thread.scheduleTrimMemory(20);
                                                } catch (RemoteException e10) {
                                                }
                                            } catch (RemoteException e11) {
                                            }
                                        }
                                        i = 0;
                                        app6.pendingUiClean = false;
                                    } else {
                                        i = 0;
                                    }
                                    app6.trimMemoryLevel = i;
                                    i14 = i15 - 1;
                                }
                            }
                        }
                        if (this.mAlwaysFinishActivities) {
                            this.mStackSupervisor.scheduleDestroyAllActivities(null, "always-finish");
                        }
                        if (allChanged) {
                            requestPssAllProcsLocked(now3, false, this.mProcessStats.isMemFactorLowered());
                        }
                        ArrayList<UidRecord> becameIdle = null;
                        if (this.mLocalPowerManager != null) {
                            this.mLocalPowerManager.startUidChanges();
                        }
                        int i16 = this.mActiveUids.size() - 1;
                        while (i16 >= 0) {
                            UidRecord uidRec = this.mActiveUids.valueAt(i16);
                            if (uidRec.curProcState == 19) {
                                nowElapsed = nowElapsed5;
                            } else if (uidRec.setProcState == uidRec.curProcState && uidRec.setWhitelist == uidRec.curWhitelist) {
                                nowElapsed = nowElapsed5;
                            } else {
                                if (ActivityManagerDebugConfig.DEBUG_UID_OBSERVERS) {
                                    Slog.i("ActivityManager", "Changes in " + uidRec + ": proc state from " + uidRec.setProcState + " to " + uidRec.curProcState + ", whitelist from " + uidRec.setWhitelist + " to " + uidRec.curWhitelist);
                                }
                                if (!ActivityManager.isProcStateBackground(uidRec.curProcState) || uidRec.curWhitelist) {
                                    nowElapsed = nowElapsed5;
                                    if (uidRec.idle) {
                                        uidChange = 4;
                                        EventLogTags.writeAmUidActive(uidRec.uid);
                                        uidRec.idle = false;
                                    } else {
                                        uidChange = 0;
                                    }
                                    uidRec.lastBackgroundTime = 0L;
                                } else {
                                    if (!ActivityManager.isProcStateBackground(uidRec.setProcState) || uidRec.setWhitelist) {
                                        long nowElapsed6 = nowElapsed5;
                                        uidRec.lastBackgroundTime = nowElapsed6;
                                        if (this.mHandler.hasMessages(58)) {
                                            uidChange2 = 0;
                                            nowElapsed = nowElapsed6;
                                        } else {
                                            uidChange2 = 0;
                                            nowElapsed = nowElapsed6;
                                            this.mHandler.sendEmptyMessageDelayed(58, this.mConstants.BACKGROUND_SETTLE_TIME);
                                        }
                                    } else {
                                        uidChange2 = 0;
                                        nowElapsed = nowElapsed5;
                                    }
                                    if (!uidRec.idle || uidRec.setIdle) {
                                        uidChange = uidChange2;
                                    } else {
                                        uidChange = 2;
                                        if (becameIdle == null) {
                                            becameIdle = new ArrayList<>();
                                        }
                                        becameIdle.add(uidRec);
                                    }
                                }
                                boolean wasCached = uidRec.setProcState > 10;
                                boolean isCached = uidRec.curProcState > 10;
                                if (wasCached != isCached || uidRec.setProcState == 19) {
                                    uidChange |= isCached ? 8 : 16;
                                }
                                uidRec.setProcState = uidRec.curProcState;
                                uidRec.setWhitelist = uidRec.curWhitelist;
                                uidRec.setIdle = uidRec.idle;
                                enqueueUidChangeLocked(uidRec, -1, uidChange);
                                noteUidProcessState(uidRec.uid, uidRec.curProcState);
                                if (uidRec.foregroundServices) {
                                    this.mServices.foregroundServiceProcStateChangedLocked(uidRec);
                                }
                            }
                            i16--;
                            nowElapsed5 = nowElapsed;
                        }
                        if (this.mLocalPowerManager != null) {
                            this.mLocalPowerManager.finishUidChanges();
                        }
                        if (becameIdle != null) {
                            for (int i17 = becameIdle.size() - 1; i17 >= 0; i17--) {
                                this.mServices.stopInBackgroundLocked(becameIdle.get(i17).uid);
                            }
                        }
                        if (this.mProcessStats.shouldWriteNowLocked(now3)) {
                            this.mHandler.post(new Runnable() { // from class: com.android.server.am.ActivityManagerService.29
                                @Override // java.lang.Runnable
                                public void run() {
                                    int oldMask = StrictMode.allowThreadDiskReadsMask();
                                    try {
                                        synchronized (ActivityManagerService.this) {
                                            ActivityManagerService.boostPriorityForLockedSection();
                                            ActivityManagerService.this.mProcessStats.writeStateAsyncLocked();
                                        }
                                        ActivityManagerService.resetPriorityAfterLockedSection();
                                    } finally {
                                        StrictMode.setThreadPolicyMask(oldMask);
                                    }
                                }
                            });
                        }
                        if (ActivityManagerDebugConfig.DEBUG_OOM_ADJ) {
                            long duration = SystemClock.uptimeMillis() - now3;
                            Slog.d("ActivityManager", "Did OOM ADJ in " + duration + "ms");
                            return;
                        }
                        return;
                    }
                    ProcessRecord app7 = this.mLruProcesses.get(i11);
                    if (app7.killedByAm || app7.thread == null) {
                        cycleCount2 = cycleCount;
                        nextCachedAdj = nextCachedAdj6;
                        app = app7;
                        numEmpty3 = numEmpty4;
                        z = z4;
                        numCached = numCached2;
                        cachedProcessLimit2 = cachedProcessLimit5;
                        emptyProcessLimit = emptyProcessLimit5;
                    } else {
                        app = app7;
                        int numEmpty5 = numEmpty4;
                        cycleCount2 = cycleCount;
                        nextCachedAdj = nextCachedAdj6;
                        z = z4;
                        numCached = numCached2;
                        applyOomAdjLocked(app7, true, now3, nowElapsed5);
                        switch (app.curProcState) {
                            case 15:
                            case 16:
                                emptyProcessLimit = emptyProcessLimit5;
                                numEmpty3 = numEmpty5;
                                this.mNumCachedHiddenProcs++;
                                int numCached3 = numCached + 1;
                                cachedProcessLimit2 = cachedProcessLimit5;
                                if (numCached3 > cachedProcessLimit2) {
                                    app.kill("cached #" + numCached3, true);
                                }
                                numCached = numCached3;
                                break;
                            case 17:
                            default:
                                cachedProcessLimit2 = cachedProcessLimit5;
                                emptyProcessLimit = emptyProcessLimit5;
                                numEmpty3 = numEmpty5;
                                this.mNumNonCachedProcs++;
                                break;
                            case 18:
                                numEmpty3 = numEmpty5;
                                if (numEmpty3 <= this.mConstants.CUR_TRIM_EMPTY_PROCESSES || app.lastActivityTime >= oldTime) {
                                    int numEmpty6 = numEmpty3 + 1;
                                    emptyProcessLimit = emptyProcessLimit5;
                                    if (numEmpty6 > emptyProcessLimit) {
                                        app.kill("empty #" + numEmpty6, true);
                                    }
                                    numEmpty3 = numEmpty6;
                                    cachedProcessLimit2 = cachedProcessLimit5;
                                    break;
                                } else {
                                    app.kill("empty for " + (((oldTime + 1800000) - app.lastActivityTime) / 1000) + "s", true);
                                    cachedProcessLimit2 = cachedProcessLimit5;
                                    emptyProcessLimit = emptyProcessLimit5;
                                    break;
                                }
                                break;
                        }
                        if (app.isolated && app.services.size() <= 0 && app.isolatedEntryPoint == null) {
                            app.kill("isolated not needed", true);
                        } else {
                            UidRecord uidRec2 = app.uidRecord;
                            if (uidRec2 != null) {
                                uidRec2.ephemeral = app.info.isInstantApp();
                                if (uidRec2.curProcState > app.curProcState) {
                                    uidRec2.curProcState = app.curProcState;
                                }
                                if (app.foregroundServices) {
                                    uidRec2.foregroundServices = true;
                                }
                            }
                        }
                        if (app.curProcState >= 13 && !app.killedByAm) {
                            numTrimming++;
                        }
                    }
                    numCached2 = numCached;
                    numEmpty4 = numEmpty3;
                    ProcessManagerPolicy.updateProcessPolicyIfNeed(this.mContext, app, this);
                    i10 = i11 - 1;
                    z4 = z;
                    emptyProcessLimit5 = emptyProcessLimit;
                    cachedProcessLimit5 = cachedProcessLimit2;
                    cycleCount = cycleCount2;
                    nextCachedAdj6 = nextCachedAdj;
                }
            }
        }
    }

    public void makePackageIdle(String packageName, int userId) {
        int appId;
        if (checkCallingPermission("android.permission.FORCE_STOP_PACKAGES") != 0) {
            String msg = "Permission Denial: makePackageIdle() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.FORCE_STOP_PACKAGES";
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        int callingPid = Binder.getCallingPid();
        int userId2 = this.mUserController.handleIncomingUser(callingPid, Binder.getCallingUid(), userId, true, 2, "makePackageIdle", null);
        long callingId = Binder.clearCallingIdentity();
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                IPackageManager pm = AppGlobals.getPackageManager();
                int i = -1;
                int pkgUid = -1;
                try {
                    pkgUid = pm.getPackageUid(packageName, 268443648, 0);
                } catch (RemoteException e) {
                }
                if (pkgUid == -1) {
                    throw new IllegalArgumentException("Unknown package name " + packageName);
                }
                if (this.mLocalPowerManager != null) {
                    this.mLocalPowerManager.startUidChanges();
                }
                int appId2 = UserHandle.getAppId(pkgUid);
                int N = this.mActiveUids.size();
                int i2 = N - 1;
                while (i2 >= 0) {
                    UidRecord uidRec = this.mActiveUids.valueAt(i2);
                    long bgTime = uidRec.lastBackgroundTime;
                    if (bgTime <= 0 || uidRec.idle || UserHandle.getAppId(uidRec.uid) != appId2) {
                        appId = appId2;
                    } else {
                        if (userId2 != i && userId2 != UserHandle.getUserId(uidRec.uid)) {
                            appId = appId2;
                        }
                        EventLogTags.writeAmUidIdle(uidRec.uid);
                        uidRec.idle = true;
                        uidRec.setIdle = true;
                        StringBuilder sb = new StringBuilder();
                        appId = appId2;
                        sb.append("Idling uid ");
                        sb.append(UserHandle.formatUid(uidRec.uid));
                        sb.append(" from package ");
                        sb.append(packageName);
                        sb.append(" user ");
                        sb.append(userId2);
                        Slog.w("ActivityManager", sb.toString());
                        doStopUidLocked(uidRec.uid, uidRec);
                    }
                    i2--;
                    appId2 = appId;
                    i = -1;
                }
                if (this.mLocalPowerManager != null) {
                    this.mLocalPowerManager.finishUidChanges();
                }
                Binder.restoreCallingIdentity(callingId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    final void idleUids() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                int N = this.mActiveUids.size();
                if (N <= 0) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                long nowElapsed = SystemClock.elapsedRealtime();
                long maxBgTime = nowElapsed - this.mConstants.BACKGROUND_SETTLE_TIME;
                long nextTime = 0;
                if (this.mLocalPowerManager != null) {
                    this.mLocalPowerManager.startUidChanges();
                }
                for (int i = N - 1; i >= 0; i--) {
                    UidRecord uidRec = this.mActiveUids.valueAt(i);
                    long bgTime = uidRec.lastBackgroundTime;
                    if (bgTime > 0 && !uidRec.idle) {
                        if (bgTime <= maxBgTime) {
                            EventLogTags.writeAmUidIdle(uidRec.uid);
                            uidRec.idle = true;
                            uidRec.setIdle = true;
                            doStopUidLocked(uidRec.uid, uidRec);
                        } else if (nextTime == 0 || nextTime > bgTime) {
                            nextTime = bgTime;
                        }
                    }
                }
                if (this.mLocalPowerManager != null) {
                    this.mLocalPowerManager.finishUidChanges();
                }
                if (nextTime > 0) {
                    this.mHandler.removeMessages(58);
                    this.mHandler.sendEmptyMessageDelayed(58, (this.mConstants.BACKGROUND_SETTLE_TIME + nextTime) - nowElapsed);
                }
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    @GuardedBy("this")
    @VisibleForTesting
    void incrementProcStateSeqAndNotifyAppsLocked() {
        int blockState;
        if (this.mWaitForNetworkTimeoutMs <= 0) {
            return;
        }
        ArrayList<Integer> blockingUids = null;
        for (int i = this.mActiveUids.size() - 1; i >= 0; i--) {
            UidRecord uidRec = this.mActiveUids.valueAt(i);
            if (this.mInjector.isNetworkRestrictedForUid(uidRec.uid) && UserHandle.isApp(uidRec.uid) && uidRec.hasInternetPermission && uidRec.setProcState != uidRec.curProcState && (blockState = getBlockStateForUid(uidRec)) != 0) {
                synchronized (uidRec.networkStateLock) {
                    long j = this.mProcStateSeqCounter + 1;
                    this.mProcStateSeqCounter = j;
                    uidRec.curProcStateSeq = j;
                    if (blockState == 1) {
                        if (blockingUids == null) {
                            blockingUids = new ArrayList<>();
                        }
                        blockingUids.add(Integer.valueOf(uidRec.uid));
                    } else {
                        if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                            Slog.d(TAG_NETWORK, "uid going to background, notifying all blocking threads for uid: " + uidRec);
                        }
                        if (uidRec.waitingForNetwork) {
                            uidRec.networkStateLock.notifyAll();
                        }
                    }
                }
            }
        }
        if (blockingUids == null) {
            return;
        }
        for (int i2 = this.mLruProcesses.size() - 1; i2 >= 0; i2--) {
            ProcessRecord app = this.mLruProcesses.get(i2);
            if (blockingUids.contains(Integer.valueOf(app.uid)) && !app.killedByAm && app.thread != null) {
                UidRecord uidRec2 = this.mActiveUids.get(app.uid);
                try {
                    if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                        Slog.d(TAG_NETWORK, "Informing app thread that it needs to block: " + uidRec2);
                    }
                    app.thread.setNetworkBlockSeq(uidRec2.curProcStateSeq);
                } catch (RemoteException e) {
                }
            }
        }
    }

    @VisibleForTesting
    int getBlockStateForUid(UidRecord uidRec) {
        boolean isAllowed = NetworkPolicyManager.isProcStateAllowedWhileIdleOrPowerSaveMode(uidRec.curProcState) || NetworkPolicyManager.isProcStateAllowedWhileOnRestrictBackground(uidRec.curProcState);
        boolean wasAllowed = NetworkPolicyManager.isProcStateAllowedWhileIdleOrPowerSaveMode(uidRec.setProcState) || NetworkPolicyManager.isProcStateAllowedWhileOnRestrictBackground(uidRec.setProcState);
        if (wasAllowed || !isAllowed) {
            return (!wasAllowed || isAllowed) ? 0 : 2;
        }
        return 1;
    }

    final void runInBackgroundDisabled(int uid) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord uidRec = this.mActiveUids.get(uid);
                if (uidRec != null) {
                    if (uidRec.idle) {
                        doStopUidLocked(uidRec.uid, uidRec);
                    }
                } else {
                    doStopUidLocked(uid, null);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    void doStopUidForIdleUidsLocked() {
        int size = this.mActiveUids.size();
        for (int i = 0; i < size; i++) {
            int uid = this.mActiveUids.keyAt(i);
            if (!UserHandle.isCore(uid)) {
                UidRecord uidRec = this.mActiveUids.valueAt(i);
                if (uidRec.idle) {
                    doStopUidLocked(uidRec.uid, uidRec);
                }
            }
        }
    }

    final void doStopUidLocked(int uid, UidRecord uidRec) {
        this.mServices.stopInBackgroundLocked(uid);
        enqueueUidChangeLocked(uidRec, uid, 2);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public void tempWhitelistForPendingIntentLocked(int callerPid, int callerUid, int targetUid, long duration, String tag) {
        if (ActivityManagerDebugConfig.DEBUG_WHITELISTS) {
            Slog.d("ActivityManager", "tempWhitelistForPendingIntentLocked(" + callerPid + ", " + callerUid + ", " + targetUid + ", " + duration + ")");
        }
        synchronized (this.mPidsSelfLocked) {
            ProcessRecord pr = this.mPidsSelfLocked.get(callerPid);
            if (pr == null) {
                Slog.w("ActivityManager", "tempWhitelistForPendingIntentLocked() no ProcessRecord for pid " + callerPid);
            } else if (!pr.whitelistManager && checkPermission("android.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST", callerPid, callerUid) != 0) {
                if (ActivityManagerDebugConfig.DEBUG_WHITELISTS) {
                    Slog.d("ActivityManager", "tempWhitelistForPendingIntentLocked() for target " + targetUid + ": pid " + callerPid + " is not allowed");
                }
            } else {
                tempWhitelistUidLocked(targetUid, duration, tag);
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @GuardedBy("this")
    public void tempWhitelistUidLocked(int targetUid, long duration, String tag) {
        this.mPendingTempWhitelist.put(targetUid, new PendingTempWhitelist(targetUid, duration, tag));
        setUidTempWhitelistStateLocked(targetUid, true);
        this.mUiHandler.obtainMessage(68).sendToTarget();
    }

    void pushTempWhitelist() {
        int N;
        PendingTempWhitelist[] list;
        int i;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                N = this.mPendingTempWhitelist.size();
                list = new PendingTempWhitelist[N];
                for (int i2 = 0; i2 < N; i2++) {
                    list[i2] = this.mPendingTempWhitelist.valueAt(i2);
                }
            } finally {
            }
        }
        resetPriorityAfterLockedSection();
        for (int i3 = 0; i3 < N; i3++) {
            PendingTempWhitelist ptw = list[i3];
            this.mLocalDeviceIdleController.addPowerSaveTempWhitelistAppDirect(ptw.targetUid, ptw.duration, true, ptw.tag);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                for (i = 0; i < N; i++) {
                    PendingTempWhitelist ptw2 = list[i];
                    int index = this.mPendingTempWhitelist.indexOfKey(ptw2.targetUid);
                    if (index >= 0 && this.mPendingTempWhitelist.valueAt(index) == ptw2) {
                        this.mPendingTempWhitelist.removeAt(index);
                    }
                }
            } finally {
            }
        }
        resetPriorityAfterLockedSection();
    }

    @GuardedBy("this")
    final void setAppIdTempWhitelistStateLocked(int appId, boolean onWhitelist) {
        boolean changed = false;
        for (int i = this.mActiveUids.size() - 1; i >= 0; i--) {
            UidRecord uidRec = this.mActiveUids.valueAt(i);
            if (UserHandle.getAppId(uidRec.uid) == appId && uidRec.curWhitelist != onWhitelist) {
                uidRec.curWhitelist = onWhitelist;
                changed = true;
            }
        }
        if (changed) {
            updateOomAdjLocked();
        }
    }

    @GuardedBy("this")
    final void setUidTempWhitelistStateLocked(int uid, boolean onWhitelist) {
        UidRecord uidRec = this.mActiveUids.get(uid);
        if (uidRec != null && uidRec.curWhitelist != onWhitelist) {
            uidRec.curWhitelist = onWhitelist;
            updateOomAdjLocked();
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public final void trimApplications() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                trimApplicationsLocked();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    final void trimApplicationsLocked() {
        for (int i = this.mRemovedProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = this.mRemovedProcesses.get(i);
            if (app.activities.size() == 0 && app.recentTasks.size() == 0 && app.curReceivers.isEmpty() && app.services.size() == 0) {
                StringBuilder sb = new StringBuilder();
                sb.append("Exiting empty application process ");
                sb.append(app.toShortString());
                sb.append(" (");
                sb.append(app.thread != null ? app.thread.asBinder() : null);
                sb.append(")\n");
                Slog.i("ActivityManager", sb.toString());
                if (app.pid > 0 && app.pid != MY_PID) {
                    app.kill("empty", false);
                } else if (app.thread != null) {
                    try {
                        app.thread.scheduleExit();
                    } catch (Exception e) {
                    }
                }
                cleanUpApplicationRecordLocked(app, false, true, -1, false);
                this.mRemovedProcesses.remove(i);
                if (app.persistent) {
                    addAppLocked(app.info, null, false, null);
                }
            }
        }
        updateOomAdjLocked();
    }

    public void signalPersistentProcesses(int sig) throws RemoteException {
        if (sig != 10) {
            throw new SecurityException("Only SIGNAL_USR1 is allowed");
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (checkCallingPermission("android.permission.SIGNAL_PERSISTENT_PROCESSES") != 0) {
                    throw new SecurityException("Requires permission android.permission.SIGNAL_PERSISTENT_PROCESSES");
                }
                for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
                    ProcessRecord r = this.mLruProcesses.get(i);
                    if (r.thread != null && r.persistent) {
                        Process.sendSignal(r.pid, sig);
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    private void stopProfilerLocked(ProcessRecord proc, int profileType) {
        if (proc == null || proc == this.mProfileProc) {
            proc = this.mProfileProc;
            profileType = this.mProfileType;
            clearProfilerLocked();
        }
        if (proc == null) {
            return;
        }
        try {
            proc.thread.profilerControl(false, (ProfilerInfo) null, profileType);
        } catch (RemoteException e) {
            throw new IllegalStateException("Process disappeared");
        }
    }

    private void clearProfilerLocked() {
        if (this.mProfilerInfo != null && this.mProfilerInfo.profileFd != null) {
            try {
                this.mProfilerInfo.profileFd.close();
            } catch (IOException e) {
            }
        }
        this.mProfileApp = null;
        this.mProfileProc = null;
        this.mProfilerInfo = null;
    }

    /* JADX WARN: Code restructure failed: missing block: B:23:0x004b, code lost:
        stopProfilerLocked(null, 0);
        setProfileApp(r0.info, r0.processName, r8);
        r4.mProfileProc = r0;
        r4.mProfileType = r9;
        r1 = r8.profileFd;
     */
    /* JADX WARN: Code restructure failed: missing block: B:25:0x0061, code lost:
        r1 = r1.dup();
     */
    /* JADX WARN: Code restructure failed: missing block: B:27:0x0064, code lost:
        r1 = null;
     */
    /* JADX WARN: Removed duplicated region for block: B:35:0x0080  */
    /* JADX WARN: Removed duplicated region for block: B:48:0x0099 A[DONT_GENERATE] */
    /*
        Code decompiled incorrectly, please refer to instructions dump.
        To view partially-correct add '--show-bad-code' argument
    */
    public boolean profileControl(java.lang.String r5, int r6, boolean r7, android.app.ProfilerInfo r8, int r9) throws android.os.RemoteException {
        /*
            Method dump skipped, instructions count: 204
            To view this dump add '--comments-level debug' option
        */
        throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.profileControl(java.lang.String, int, boolean, android.app.ProfilerInfo, int):boolean");
    }

    private ProcessRecord findProcessLocked(String process, int userId, String callName) {
        int userId2 = this.mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, 2, callName, null);
        ProcessRecord proc = null;
        try {
            int pid = Integer.parseInt(process);
            synchronized (this.mPidsSelfLocked) {
                proc = this.mPidsSelfLocked.get(pid);
            }
        } catch (NumberFormatException e) {
        }
        if (proc == null) {
            ArrayMap<String, SparseArray<ProcessRecord>> all = this.mProcessNames.getMap();
            SparseArray<ProcessRecord> procs = all.get(process);
            if (procs != null && procs.size() > 0) {
                ProcessRecord proc2 = procs.valueAt(0);
                ProcessRecord proc3 = proc2;
                if (userId2 != -1 && proc3.userId != userId2) {
                    for (int i = 1; i < procs.size(); i++) {
                        ProcessRecord thisProc = procs.valueAt(i);
                        if (thisProc.userId == userId2) {
                            return thisProc;
                        }
                    }
                    return proc3;
                }
                return proc3;
            }
            return proc;
        }
        return proc;
    }

    public boolean dumpHeap(String process, int userId, boolean managed, boolean mallocInfo, boolean runGc, String path, ParcelFileDescriptor fd) throws RemoteException {
        try {
            try {
                synchronized (this) {
                    try {
                        boostPriorityForLockedSection();
                        if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                            throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                        }
                        if (fd == null) {
                            throw new IllegalArgumentException("null fd");
                        }
                        ProcessRecord proc = findProcessLocked(process, userId, "dumpHeap");
                        if (proc == null || proc.thread == null) {
                            throw new IllegalArgumentException("Unknown process: " + process);
                        }
                        boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
                        if (!isDebuggable && (proc.info.flags & 2) == 0) {
                            throw new SecurityException("Process not debuggable: " + proc);
                        }
                        proc.thread.dumpHeap(managed, mallocInfo, runGc, path, fd);
                        fd = null;
                    } finally {
                    }
                }
                resetPriorityAfterLockedSection();
                return true;
            } catch (RemoteException e) {
                throw new IllegalStateException("Process disappeared");
            }
        } finally {
            if (fd != null) {
                try {
                    fd.close();
                } catch (IOException e2) {
                }
            }
        }
    }

    public void setDumpHeapDebugLimit(String processName, int uid, long maxMemSize, String reportPackage) {
        if (processName != null) {
            enforceCallingPermission("android.permission.SET_DEBUG_APP", "setDumpHeapDebugLimit()");
        } else {
            synchronized (this.mPidsSelfLocked) {
                ProcessRecord proc = this.mPidsSelfLocked.get(Binder.getCallingPid());
                if (proc == null) {
                    throw new SecurityException("No process found for calling pid " + Binder.getCallingPid());
                }
                if (!Build.IS_DEBUGGABLE && (proc.info.flags & 2) == 0) {
                    throw new SecurityException("Not running a debuggable build");
                }
                processName = proc.processName;
                uid = proc.uid;
                if (reportPackage != null && !proc.pkgList.containsKey(reportPackage)) {
                    throw new SecurityException("Package " + reportPackage + " is not running in " + proc);
                }
            }
        }
        String processName2 = processName;
        int uid2 = uid;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (maxMemSize > 0) {
                    this.mMemWatchProcesses.put(processName2, uid2, new Pair(Long.valueOf(maxMemSize), reportPackage));
                } else if (uid2 != 0) {
                    this.mMemWatchProcesses.remove(processName2, uid2);
                } else {
                    this.mMemWatchProcesses.getMap().remove(processName2);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void dumpHeapFinished(String path) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (Binder.getCallingPid() != this.mMemWatchDumpPid) {
                    Slog.w("ActivityManager", "dumpHeapFinished: Calling pid " + Binder.getCallingPid() + " does not match last pid " + this.mMemWatchDumpPid);
                    resetPriorityAfterLockedSection();
                    return;
                }
                if (this.mMemWatchDumpFile != null && this.mMemWatchDumpFile.equals(path)) {
                    if (ActivityManagerDebugConfig.DEBUG_PSS) {
                        Slog.d("ActivityManager", "Dump heap finished for " + path);
                    }
                    this.mHandler.sendEmptyMessage(50);
                    Runtime.getRuntime().gc();
                    resetPriorityAfterLockedSection();
                    return;
                }
                Slog.w("ActivityManager", "dumpHeapFinished: Calling path " + path + " does not match last path " + this.mMemWatchDumpFile);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    @Override // com.android.server.Watchdog.Monitor
    public void monitor() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public void onCoreSettingsChange(Bundle settings) {
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord processRecord = this.mLruProcesses.get(i);
            try {
                if (processRecord.thread != null) {
                    processRecord.thread.setCoreSettings(settings);
                }
            } catch (RemoteException e) {
            }
        }
    }

    public boolean startUserInBackground(int userId) {
        return startUserInBackgroundWithListener(userId, null);
    }

    public boolean startUserInBackgroundWithListener(int userId, IProgressListener unlockListener) {
        return this.mUserController.startUser(userId, false, unlockListener);
    }

    public boolean unlockUser(int userId, byte[] token, byte[] secret, IProgressListener listener) {
        return this.mUserController.unlockUser(userId, token, secret, listener);
    }

    public boolean switchUser(int targetUserId) {
        return this.mUserController.switchUser(targetUserId);
    }

    public int stopUser(int userId, boolean force, IStopUserCallback callback) {
        return this.mUserController.stopUser(userId, force, callback);
    }

    public UserInfo getCurrentUser() {
        return this.mUserController.getCurrentUser();
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public String getStartedUserState(int userId) {
        UserState userState = this.mUserController.getStartedUserState(userId);
        return UserState.stateToString(userState.state);
    }

    public boolean isUserRunning(int userId, int flags) {
        if (!this.mUserController.isSameProfileGroup(userId, UserHandle.getCallingUserId()) && checkCallingPermission("android.permission.INTERACT_ACROSS_USERS") != 0) {
            String msg = "Permission Denial: isUserRunning() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.INTERACT_ACROSS_USERS";
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        return this.mUserController.isUserRunning(userId, flags);
    }

    public int[] getRunningUserIds() {
        if (checkCallingPermission("android.permission.INTERACT_ACROSS_USERS") != 0) {
            String msg = "Permission Denial: isUserRunning() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires android.permission.INTERACT_ACROSS_USERS";
            Slog.w("ActivityManager", msg);
            throw new SecurityException(msg);
        }
        return this.mUserController.getStartedUserArray();
    }

    public void registerUserSwitchObserver(IUserSwitchObserver observer, String name) {
        this.mUserController.registerUserSwitchObserver(observer, name);
    }

    public void unregisterUserSwitchObserver(IUserSwitchObserver observer) {
        this.mUserController.unregisterUserSwitchObserver(observer);
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public ApplicationInfo getAppInfoForUser(ApplicationInfo info, int userId) {
        if (info == null) {
            return null;
        }
        ApplicationInfo newInfo = new ApplicationInfo(info);
        newInfo.initForUser(userId);
        return newInfo;
    }

    public boolean isUserStopped(int userId) {
        return this.mUserController.getStartedUserState(userId) == null;
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    public ActivityInfo getActivityInfoForUser(ActivityInfo aInfo, int userId) {
        if (aInfo == null || (userId < 1 && aInfo.applicationInfo.uid < 100000)) {
            return aInfo;
        }
        ActivityInfo info = new ActivityInfo(aInfo);
        info.applicationInfo = getAppInfoForUser(info.applicationInfo, userId);
        return info;
    }

    private boolean processSanityChecksLocked(ProcessRecord process) {
        if (process == null || process.thread == null) {
            return false;
        }
        boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
        if (!isDebuggable && (process.info.flags & 2) == 0) {
            return false;
        }
        return true;
    }

    public boolean startBinderTracking() throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                this.mBinderTransactionTrackingEnabled = true;
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                }
                for (int i = 0; i < this.mLruProcesses.size(); i++) {
                    ProcessRecord process = this.mLruProcesses.get(i);
                    if (processSanityChecksLocked(process)) {
                        try {
                            process.thread.startBinderTracking();
                        } catch (RemoteException e) {
                            Log.v("ActivityManager", "Process disappared");
                        }
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return true;
    }

    public boolean stopBinderTrackingAndDump(ParcelFileDescriptor fd) throws RemoteException {
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                this.mBinderTransactionTrackingEnabled = false;
                if (checkCallingPermission("android.permission.SET_ACTIVITY_WATCHER") != 0) {
                    throw new SecurityException("Requires permission android.permission.SET_ACTIVITY_WATCHER");
                }
                if (fd == null) {
                    throw new IllegalArgumentException("null fd");
                }
                FastPrintWriter fastPrintWriter = new FastPrintWriter(new FileOutputStream(fd.getFileDescriptor()));
                fastPrintWriter.println("Binder transaction traces for all processes.\n");
                Iterator<ProcessRecord> it = this.mLruProcesses.iterator();
                while (it.hasNext()) {
                    ProcessRecord process = it.next();
                    if (processSanityChecksLocked(process)) {
                        fastPrintWriter.println("Traces for process: " + process.processName);
                        fastPrintWriter.flush();
                        try {
                            TransferPipe tp = new TransferPipe();
                            try {
                                process.thread.stopBinderTrackingAndDump(tp.getWriteFd());
                                tp.go(fd.getFileDescriptor());
                                tp.kill();
                            } catch (Throwable th) {
                                tp.kill();
                                throw th;
                                break;
                            }
                        } catch (RemoteException e) {
                            fastPrintWriter.println("Got a RemoteException while dumping IPC traces from " + process + ".  Exception: " + e);
                            fastPrintWriter.flush();
                        } catch (IOException e2) {
                            fastPrintWriter.println("Failure while dumping IPC traces from " + process + ".  Exception: " + e2);
                            fastPrintWriter.flush();
                        }
                    }
                }
                fd = null;
            }
            resetPriorityAfterLockedSection();
            return true;
        } finally {
            if (fd != null) {
                try {
                    fd.close();
                } catch (IOException e3) {
                }
            }
        }
    }

    /* JADX INFO: Access modifiers changed from: package-private */
    @VisibleForTesting
    /* loaded from: classes.dex */
    public final class LocalService extends ActivityManagerInternal {
        LocalService() {
        }

        public void grantUriPermissionFromIntent(int callingUid, String targetPkg, Intent intent, int targetUserId) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.grantUriPermissionFromIntentLocked(callingUid, targetPkg, intent, null, targetUserId);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public String checkContentProviderAccess(String authority, int userId) {
            return ActivityManagerService.this.checkContentProviderAccess(authority, userId);
        }

        public void onWakefulnessChanged(int wakefulness) {
            ActivityManagerService.this.onWakefulnessChanged(wakefulness);
        }

        public boolean startIsolatedProcess(String entryPoint, String[] entryPointArgs, String processName, String abiOverride, int uid, Runnable crashHandler) {
            return ActivityManagerService.this.startIsolatedProcess(entryPoint, entryPointArgs, processName, abiOverride, uid, crashHandler);
        }

        public ActivityManagerInternal.SleepToken acquireSleepToken(String tag, int displayId) {
            Preconditions.checkNotNull(tag);
            return ActivityManagerService.this.acquireSleepToken(tag, displayId);
        }

        public ComponentName getHomeActivityForUser(int userId) {
            ComponentName componentName;
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityRecord homeActivity = ActivityManagerService.this.mStackSupervisor.getHomeActivityForUser(userId);
                    componentName = homeActivity == null ? null : homeActivity.realActivity;
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
            return componentName;
        }

        public void onUserRemoved(int userId) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.onUserStoppedLocked(userId);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
            ActivityManagerService.this.mBatteryStatsService.onUserRemoved(userId);
            ActivityManagerService.this.mUserController.onUserRemoved(userId);
        }

        public void onLocalVoiceInteractionStarted(IBinder activity, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.onLocalVoiceInteractionStartedLocked(activity, voiceSession, voiceInteractor);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void notifyAppTransitionStarting(SparseIntArray reasons, long timestamp) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.getActivityMetricsLogger().notifyTransitionStarting(reasons, timestamp);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void notifyAppTransitionFinished() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.notifyAppTransitionDone();
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void notifyAppTransitionCancelled() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.notifyAppTransitionDone();
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public List<IBinder> getTopVisibleActivities() {
            List<IBinder> topVisibleActivities;
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    topVisibleActivities = ActivityManagerService.this.mStackSupervisor.getTopVisibleActivities();
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
            return topVisibleActivities;
        }

        public void notifyDockedStackMinimizedChanged(boolean minimized) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mStackSupervisor.setDockedStackMinimized(minimized);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void killForegroundAppsForUser(int userHandle) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ArrayList<ProcessRecord> procs = new ArrayList<>();
                    int NP = ActivityManagerService.this.mProcessNames.getMap().size();
                    for (int ip = 0; ip < NP; ip++) {
                        SparseArray<ProcessRecord> apps = (SparseArray) ActivityManagerService.this.mProcessNames.getMap().valueAt(ip);
                        int NA = apps.size();
                        for (int ia = 0; ia < NA; ia++) {
                            ProcessRecord app = apps.valueAt(ia);
                            if (!app.persistent) {
                                if (app.removed) {
                                    procs.add(app);
                                } else if (app.userId == userHandle && app.foregroundActivities) {
                                    app.removed = true;
                                    procs.add(app);
                                }
                            }
                        }
                    }
                    int N = procs.size();
                    for (int i = 0; i < N; i++) {
                        ActivityManagerService.this.removeProcessLocked(procs.get(i), false, true, "kill all fg");
                    }
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void setPendingIntentWhitelistDuration(IIntentSender target, IBinder whitelistToken, long duration) {
            if (!(target instanceof PendingIntentRecord)) {
                Slog.w("ActivityManager", "markAsSentFromNotification(): not a PendingIntentRecord: " + target);
                return;
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ((PendingIntentRecord) target).setWhitelistDurationLocked(whitelistToken, duration);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void setDeviceIdleWhitelist(int[] allAppids, int[] exceptIdleAppids) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mDeviceIdleWhitelist = allAppids;
                    ActivityManagerService.this.mDeviceIdleExceptIdleWhitelist = exceptIdleAppids;
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void updateDeviceIdleTempWhitelist(int[] appids, int changingAppId, boolean adding) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mDeviceIdleTempWhitelist = appids;
                    ActivityManagerService.this.setAppIdTempWhitelistStateLocked(changingAppId, adding);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void updatePersistentConfigurationForUser(Configuration values, int userId) {
            Preconditions.checkNotNull(values, "Configuration must not be null");
            Preconditions.checkArgumentNonnegative(userId, "userId " + userId + " not supported");
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.updateConfigurationLocked(values, null, false, true, userId, false);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        /* JADX WARN: Removed duplicated region for block: B:36:0x0059 A[EXC_TOP_SPLITTER, SYNTHETIC] */
        /*
            Code decompiled incorrectly, please refer to instructions dump.
            To view partially-correct add '--show-bad-code' argument
        */
        public int startActivitiesAsPackage(java.lang.String r20, int r21, android.content.Intent[] r22, android.os.Bundle r23) {
            /*
                r19 = this;
                r1 = r19
                r12 = r22
                java.lang.String r0 = "intents"
                com.android.internal.util.Preconditions.checkNotNull(r12, r0)
                int r0 = r12.length
                java.lang.String[] r13 = new java.lang.String[r0]
                r2 = 0
                long r3 = android.os.Binder.clearCallingIdentity()
                r14 = r3
                r0 = 0
            L13:
                int r3 = r12.length     // Catch: java.lang.Throwable -> L42 android.os.RemoteException -> L4b
                if (r0 >= r3) goto L29
                r3 = r12[r0]     // Catch: java.lang.Throwable -> L42 android.os.RemoteException -> L4b
                com.android.server.am.ActivityManagerService r4 = com.android.server.am.ActivityManagerService.this     // Catch: java.lang.Throwable -> L42 android.os.RemoteException -> L4b
                android.content.Context r4 = r4.mContext     // Catch: java.lang.Throwable -> L42 android.os.RemoteException -> L4b
                android.content.ContentResolver r4 = r4.getContentResolver()     // Catch: java.lang.Throwable -> L42 android.os.RemoteException -> L4b
                java.lang.String r3 = r3.resolveTypeIfNeeded(r4)     // Catch: java.lang.Throwable -> L42 android.os.RemoteException -> L4b
                r13[r0] = r3     // Catch: java.lang.Throwable -> L42 android.os.RemoteException -> L4b
                int r0 = r0 + 1
                goto L13
            L29:
                android.content.pm.IPackageManager r0 = android.app.AppGlobals.getPackageManager()     // Catch: java.lang.Throwable -> L42 android.os.RemoteException -> L4b
                r3 = 268435456(0x10000000, float:2.524355E-29)
                r11 = r20
                r10 = r21
                int r0 = r0.getPackageUid(r11, r3, r10)     // Catch: java.lang.Throwable -> L3e android.os.RemoteException -> L40
                android.os.Binder.restoreCallingIdentity(r14)
                r16 = r0
                goto L56
            L3e:
                r0 = move-exception
                goto L47
            L40:
                r0 = move-exception
                goto L50
            L42:
                r0 = move-exception
                r11 = r20
                r10 = r21
            L47:
                android.os.Binder.restoreCallingIdentity(r14)
                throw r0
            L4b:
                r0 = move-exception
                r11 = r20
                r10 = r21
            L50:
                android.os.Binder.restoreCallingIdentity(r14)
                r16 = r2
            L56:
                com.android.server.am.ActivityManagerService r9 = com.android.server.am.ActivityManagerService.this
                monitor-enter(r9)
                com.android.server.am.ActivityManagerService.boostPriorityForLockedSection()     // Catch: java.lang.Throwable -> L7e
                com.android.server.am.ActivityManagerService r0 = com.android.server.am.ActivityManagerService.this     // Catch: java.lang.Throwable -> L7e
                com.android.server.am.ActivityStartController r2 = com.android.server.am.ActivityManagerService.access$2100(r0)     // Catch: java.lang.Throwable -> L7e
                r7 = 0
                com.android.server.am.SafeActivityOptions r8 = com.android.server.am.SafeActivityOptions.fromBundle(r23)     // Catch: java.lang.Throwable -> L7e
                r0 = 0
                r17 = 0
                r3 = r16
                r4 = r11
                r5 = r12
                r6 = r13
                r18 = r9
                r9 = r10
                r10 = r0
                r11 = r17
                int r0 = r2.startActivitiesInPackage(r3, r4, r5, r6, r7, r8, r9, r10, r11)     // Catch: java.lang.Throwable -> L86
                monitor-exit(r18)     // Catch: java.lang.Throwable -> L86
                com.android.server.am.ActivityManagerService.resetPriorityAfterLockedSection()
                return r0
            L7e:
                r0 = move-exception
                r18 = r9
            L81:
                monitor-exit(r18)     // Catch: java.lang.Throwable -> L86
                com.android.server.am.ActivityManagerService.resetPriorityAfterLockedSection()
                throw r0
            L86:
                r0 = move-exception
                goto L81
            */
            throw new UnsupportedOperationException("Method not decompiled: com.android.server.am.ActivityManagerService.LocalService.startActivitiesAsPackage(java.lang.String, int, android.content.Intent[], android.os.Bundle):int");
        }

        public int startActivityAsUser(IApplicationThread caller, String callerPacakge, Intent intent, Bundle options, int userId) {
            return ActivityManagerService.this.startActivityAsUser(caller, callerPacakge, intent, intent.resolveTypeIfNeeded(ActivityManagerService.this.mContext.getContentResolver()), null, null, 0, 268435456, null, options, userId, false);
        }

        public int getUidProcessState(int uid) {
            return ActivityManagerService.this.getUidState(uid);
        }

        public void notifyKeyguardFlagsChanged(Runnable callback) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    boolean wasTransitionSet = ActivityManagerService.this.mWindowManager.getPendingAppTransition() != 0;
                    if (!wasTransitionSet) {
                        ActivityManagerService.this.mWindowManager.prepareAppTransition(0, false);
                    }
                    ActivityManagerService.this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                    if (!wasTransitionSet) {
                        ActivityManagerService.this.mWindowManager.executeAppTransition();
                    }
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
            if (callback != null) {
                callback.run();
            }
        }

        public boolean isSystemReady() {
            return ActivityManagerService.this.mSystemReady;
        }

        public void notifyKeyguardTrustedChanged() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    if (ActivityManagerService.this.mKeyguardController.isKeyguardShowing(0)) {
                        ActivityManagerService.this.mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, false);
                    }
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void setHasOverlayUi(int pid, boolean hasOverlayUi) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    synchronized (ActivityManagerService.this.mPidsSelfLocked) {
                        ProcessRecord pr = ActivityManagerService.this.mPidsSelfLocked.get(pid);
                        if (pr == null) {
                            Slog.w("ActivityManager", "setHasOverlayUi called on unknown pid: " + pid);
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        } else if (pr.hasOverlayUi == hasOverlayUi) {
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        } else {
                            pr.hasOverlayUi = hasOverlayUi;
                            ActivityManagerService.this.updateOomAdjLocked(pr, true);
                            ActivityManagerService.resetPriorityAfterLockedSection();
                        }
                    }
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
        }

        public void setRunningRemoteAnimation(int pid, boolean runningRemoteAnimation) {
            ActivityManagerService.this.setRunningRemoteAnimation(pid, runningRemoteAnimation);
        }

        public void notifyNetworkPolicyRulesUpdated(int uid, long procStateSeq) {
            if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                Slog.d(ActivityManagerService.TAG_NETWORK, "Got update from NPMS for uid: " + uid + " seq: " + procStateSeq);
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    UidRecord record = ActivityManagerService.this.mActiveUids.get(uid);
                    if (record == null) {
                        if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                            Slog.d(ActivityManagerService.TAG_NETWORK, "No active uidRecord for uid: " + uid + " procStateSeq: " + procStateSeq);
                        }
                        ActivityManagerService.resetPriorityAfterLockedSection();
                        return;
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    synchronized (record.networkStateLock) {
                        if (record.lastNetworkUpdatedProcStateSeq >= procStateSeq) {
                            if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                                Slog.d(ActivityManagerService.TAG_NETWORK, "procStateSeq: " + procStateSeq + " has already been handled for uid: " + uid);
                            }
                            return;
                        }
                        record.lastNetworkUpdatedProcStateSeq = procStateSeq;
                        if (record.curProcStateSeq > procStateSeq) {
                            if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                                Slog.d(ActivityManagerService.TAG_NETWORK, "No need to handle older seq no., Uid: " + uid + ", curProcstateSeq: " + record.curProcStateSeq + ", procStateSeq: " + procStateSeq);
                            }
                            return;
                        }
                        if (record.waitingForNetwork) {
                            if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                                Slog.d(ActivityManagerService.TAG_NETWORK, "Notifying all blocking threads for uid: " + uid + ", procStateSeq: " + procStateSeq);
                            }
                            record.networkStateLock.notifyAll();
                        }
                    }
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
        }

        public void notifyActiveVoiceInteractionServiceChanged(ComponentName component) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mActiveVoiceInteractionServiceComponent = component;
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void setVr2dDisplayId(int vr2dDisplayId) {
            if (ActivityManagerDebugConfig.DEBUG_STACK) {
                Slog.d("ActivityManager", "setVr2dDisplayId called for: " + vr2dDisplayId);
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mVr2dDisplayId = vr2dDisplayId;
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void saveANRState(String reason) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    StringWriter sw = new StringWriter();
                    PrintWriter pw = new FastPrintWriter(sw, false, 1024);
                    pw.println("  ANR time: " + DateFormat.getDateTimeInstance().format(new Date()));
                    if (reason != null) {
                        pw.println("  Reason: " + reason);
                    }
                    pw.println();
                    ActivityManagerService.this.mActivityStartController.dump(pw, "  ", null);
                    pw.println();
                    pw.println("-------------------------------------------------------------------------------");
                    ActivityManagerService.this.dumpActivitiesLocked(null, pw, null, 0, true, false, null, BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS);
                    pw.println();
                    pw.close();
                    ActivityManagerService.this.mLastANRState = sw.toString();
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void clearSavedANRState() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityManagerService.this.mLastANRState = null;
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void setFocusedActivity(IBinder token) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    ActivityRecord r = ActivityRecord.forTokenLocked(token);
                    if (r == null) {
                        throw new IllegalArgumentException("setFocusedActivity: No activity record matching token=" + token);
                    } else if (ActivityManagerService.this.mStackSupervisor.moveFocusableActivityStackToFrontLocked(r, "setFocusedActivity")) {
                        ActivityManagerService.this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                    }
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }

        public void setAllowAppSwitches(String type, int uid, int userId) {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    if (ActivityManagerService.this.mUserController.isUserRunning(userId, 1)) {
                        ArrayMap<String, Integer> types = ActivityManagerService.this.mAllowAppSwitchUids.get(userId);
                        if (types == null) {
                            if (uid < 0) {
                                ActivityManagerService.resetPriorityAfterLockedSection();
                                return;
                            } else {
                                types = new ArrayMap<>();
                                ActivityManagerService.this.mAllowAppSwitchUids.put(userId, types);
                            }
                        }
                        if (uid < 0) {
                            types.remove(type);
                        } else {
                            types.put(type, Integer.valueOf(uid));
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
        }

        public boolean isRuntimeRestarted() {
            return ActivityManagerService.this.mSystemServiceManager.isRuntimeRestarted();
        }

        public boolean hasRunningActivity(int uid, String packageName) {
            if (packageName == null) {
                return false;
            }
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    for (int i = 0; i < ActivityManagerService.this.mLruProcesses.size(); i++) {
                        ProcessRecord processRecord = ActivityManagerService.this.mLruProcesses.get(i);
                        if (processRecord.uid == uid) {
                            for (int j = 0; j < processRecord.activities.size(); j++) {
                                ActivityRecord activityRecord = processRecord.activities.get(j);
                                if (packageName.equals(activityRecord.packageName)) {
                                    ActivityManagerService.resetPriorityAfterLockedSection();
                                    return true;
                                }
                            }
                            continue;
                        }
                    }
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    return false;
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
        }

        public void registerScreenObserver(ActivityManagerInternal.ScreenObserver observer) {
            ActivityManagerService.this.mScreenObservers.add(observer);
        }

        public boolean canStartMoreUsers() {
            return ActivityManagerService.this.mUserController.canStartMoreUsers();
        }

        public void setSwitchingFromSystemUserMessage(String switchingFromSystemUserMessage) {
            ActivityManagerService.this.mUserController.setSwitchingFromSystemUserMessage(switchingFromSystemUserMessage);
        }

        public void setSwitchingToSystemUserMessage(String switchingToSystemUserMessage) {
            ActivityManagerService.this.mUserController.setSwitchingToSystemUserMessage(switchingToSystemUserMessage);
        }

        public int getMaxRunningUsers() {
            return ActivityManagerService.this.mUserController.mMaxRunningUsers;
        }

        public boolean isCallerRecents(int callingUid) {
            return ActivityManagerService.this.getRecentTasks().isCallerRecents(callingUid);
        }

        public boolean isRecentsComponentHomeActivity(int userId) {
            return ActivityManagerService.this.getRecentTasks().isRecentsComponentHomeActivity(userId);
        }

        public void cancelRecentsAnimation(boolean restoreHomeStackPosition) {
            ActivityManagerService.this.cancelRecentsAnimation(restoreHomeStackPosition);
        }

        public boolean isUidActive(int uid) {
            boolean isUidActiveLocked;
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    isUidActiveLocked = ActivityManagerService.this.isUidActiveLocked(uid);
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
            return isUidActiveLocked;
        }

        public List<ProcessMemoryState> getMemoryStateForProcesses() {
            SparseArray<ProcessRecord> sparseArray;
            int size;
            int i;
            List<ProcessMemoryState> processMemoryStates;
            LocalService localService = this;
            List<ProcessMemoryState> processMemoryStates2 = new ArrayList<>();
            SparseArray<ProcessRecord> sparseArray2 = ActivityManagerService.this.mPidsSelfLocked;
            synchronized (sparseArray2) {
                int i2 = 0;
                try {
                    try {
                        int size2 = ActivityManagerService.this.mPidsSelfLocked.size();
                        while (i2 < size2) {
                            ProcessRecord r = ActivityManagerService.this.mPidsSelfLocked.valueAt(i2);
                            int pid = r.pid;
                            int uid = r.uid;
                            MemoryStatUtil.MemoryStat memoryStat = MemoryStatUtil.readMemoryStatFromFilesystem(uid, pid);
                            if (memoryStat == null) {
                                i = i2;
                                processMemoryStates = processMemoryStates2;
                                sparseArray = sparseArray2;
                                size = size2;
                            } else {
                                size = size2;
                                i = i2;
                                List<ProcessMemoryState> list = processMemoryStates2;
                                sparseArray = sparseArray2;
                                try {
                                    ProcessMemoryState processMemoryState = new ProcessMemoryState(uid, r.processName, r.maxAdj, memoryStat.pgfault, memoryStat.pgmajfault, memoryStat.rssInBytes, memoryStat.cacheInBytes, memoryStat.swapInBytes);
                                    processMemoryStates = list;
                                    processMemoryStates.add(processMemoryState);
                                } catch (Throwable th) {
                                    th = th;
                                    throw th;
                                }
                            }
                            i2 = i + 1;
                            processMemoryStates2 = processMemoryStates;
                            size2 = size;
                            sparseArray2 = sparseArray;
                            localService = this;
                        }
                        List<ProcessMemoryState> processMemoryStates3 = processMemoryStates2;
                        return processMemoryStates3;
                    } catch (Throwable th2) {
                        th = th2;
                    }
                } catch (Throwable th3) {
                    th = th3;
                    sparseArray = sparseArray2;
                }
            }
        }

        public void enforceCallerIsRecentsOrHasPermission(String permission, String func) {
            ActivityManagerService.this.enforceCallerIsRecentsOrHasPermission(permission, func);
        }

        public Intent getHomeIntent() {
            Intent homeIntent;
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    homeIntent = ActivityManagerService.this.getHomeIntent();
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
            return homeIntent;
        }

        public void notifyDefaultDisplaySizeChanged() {
            synchronized (ActivityManagerService.this) {
                try {
                    ActivityManagerService.boostPriorityForLockedSection();
                    if (ActivityManagerService.this.mSystemServiceManager.isBootCompleted() && ActivityManagerService.this.mHomeProcess != null) {
                        Slog.i("ActivityManager", "Killing home process because of display size change");
                        ActivityManagerService.this.removeProcessLocked(ActivityManagerService.this.mHomeProcess, false, true, "kill home screen size");
                    }
                } catch (Throwable th) {
                    ActivityManagerService.resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            ActivityManagerService.resetPriorityAfterLockedSection();
        }
    }

    public void waitForNetworkStateUpdate(long procStateSeq) {
        int callingUid = Binder.getCallingUid();
        if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
            Slog.d(TAG_NETWORK, "Called from " + callingUid + " to wait for seq: " + procStateSeq);
        }
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                UidRecord record = this.mActiveUids.get(callingUid);
                if (record == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                resetPriorityAfterLockedSection();
                synchronized (record.networkStateLock) {
                    if (record.lastDispatchedProcStateSeq < procStateSeq) {
                        if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                            Slog.d(TAG_NETWORK, "Uid state change for seq no. " + procStateSeq + " is not dispatched to NPMS yet, so don't wait. Uid: " + callingUid + " lastProcStateSeqDispatchedToObservers: " + record.lastDispatchedProcStateSeq);
                        }
                    } else if (record.curProcStateSeq > procStateSeq) {
                        if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                            Slog.d(TAG_NETWORK, "Ignore the wait requests for older seq numbers. Uid: " + callingUid + ", curProcStateSeq: " + record.curProcStateSeq + ", procStateSeq: " + procStateSeq);
                        }
                    } else if (record.lastNetworkUpdatedProcStateSeq >= procStateSeq) {
                        if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                            Slog.d(TAG_NETWORK, "Network rules have been already updated for seq no. " + procStateSeq + ", so no need to wait. Uid: " + callingUid + ", lastProcStateSeqWithUpdatedNetworkState: " + record.lastNetworkUpdatedProcStateSeq);
                        }
                    } else {
                        try {
                            if (ActivityManagerDebugConfig.DEBUG_NETWORK) {
                                Slog.d(TAG_NETWORK, "Starting to wait for the network rules update. Uid: " + callingUid + " procStateSeq: " + procStateSeq);
                            }
                            long startTime = SystemClock.uptimeMillis();
                            record.waitingForNetwork = true;
                            record.networkStateLock.wait(this.mWaitForNetworkTimeoutMs);
                            record.waitingForNetwork = false;
                            long totalTime = SystemClock.uptimeMillis() - startTime;
                            if (totalTime >= this.mWaitForNetworkTimeoutMs || ActivityManagerDebugConfig.DEBUG_NETWORK) {
                                Slog.w(TAG_NETWORK, "Total time waited for network rules to get updated: " + totalTime + ". Uid: " + callingUid + " procStateSeq: " + procStateSeq + " UidRec: " + record + " validateUidRec: " + this.mValidateUids.get(callingUid));
                            }
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void waitForBroadcastIdle(PrintWriter pw) {
        BroadcastQueue[] broadcastQueueArr;
        enforceCallingPermission("android.permission.DUMP", "waitForBroadcastIdle()");
        while (true) {
            boolean idle = true;
            synchronized (this) {
                try {
                    boostPriorityForLockedSection();
                    for (BroadcastQueue queue : this.mBroadcastQueues) {
                        if (!queue.isIdle()) {
                            String msg = "Waiting for queue " + queue + " to become idle...";
                            pw.println(msg);
                            pw.flush();
                            Slog.v("ActivityManager", msg);
                            idle = false;
                        }
                    }
                } catch (Throwable th) {
                    resetPriorityAfterLockedSection();
                    throw th;
                }
            }
            resetPriorityAfterLockedSection();
            if (idle) {
                pw.println("All broadcast queues are idle!");
                pw.flush();
                Slog.v("ActivityManager", "All broadcast queues are idle!");
                return;
            }
            SystemClock.sleep(1000L);
        }
    }

    public int getLastResumedActivityUserId() {
        enforceCallingPermission("android.permission.INTERACT_ACROSS_USERS_FULL", "getLastResumedActivityUserId()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                if (this.mLastResumedActivity == null) {
                    int currentUserId = this.mUserController.getCurrentUserId();
                    resetPriorityAfterLockedSection();
                    return currentUserId;
                }
                int i = this.mLastResumedActivity.userId;
                resetPriorityAfterLockedSection();
                return i;
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void killPackageDependents(String packageName, int userId) {
        enforceCallingPermission("android.permission.KILL_UID", "killPackageDependents()");
        if (packageName == null) {
            throw new NullPointerException("Cannot kill the dependents of a package without its name.");
        }
        long callingId = Binder.clearCallingIdentity();
        IPackageManager pm = AppGlobals.getPackageManager();
        int pkgUid = -1;
        try {
            pkgUid = pm.getPackageUid(packageName, 268435456, userId);
        } catch (RemoteException e) {
        }
        int pkgUid2 = pkgUid;
        if (userId != -1 && pkgUid2 == -1) {
            throw new IllegalArgumentException("Cannot kill dependents of non-existing package " + packageName);
        }
        try {
            try {
                try {
                    synchronized (this) {
                        try {
                            boostPriorityForLockedSection();
                            killPackageProcessesLocked(packageName, UserHandle.getAppId(pkgUid2), userId, 0, false, true, true, false, "dep: " + packageName);
                            resetPriorityAfterLockedSection();
                            Binder.restoreCallingIdentity(callingId);
                        } catch (Throwable th) {
                            th = th;
                            resetPriorityAfterLockedSection();
                            throw th;
                        }
                    }
                } catch (Throwable th2) {
                    th = th2;
                    Binder.restoreCallingIdentity(callingId);
                    throw th;
                }
            } catch (Throwable th3) {
                th = th3;
            }
        } catch (Throwable th4) {
            th = th4;
            Binder.restoreCallingIdentity(callingId);
            throw th;
        }
    }

    public void dismissKeyguard(IBinder token, IKeyguardDismissCallback callback, CharSequence message) throws RemoteException {
        if (message != null) {
            enforceCallingPermission("android.permission.SHOW_KEYGUARD_MESSAGE", "dismissKeyguard()");
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            this.mKeyguardController.dismissKeyguard(token, callback, message);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public int restartUserInBackground(int userId) {
        return this.mUserController.restartUser(userId, false);
    }

    public void scheduleApplicationInfoChanged(List<String> packageNames, int userId) {
        enforceCallingPermission("android.permission.CHANGE_CONFIGURATION", "scheduleApplicationInfoChanged()");
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                updateApplicationInfoLocked(packageNames, userId);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    void updateApplicationInfoLocked(List<String> packagesToUpdate, int userId) {
        boolean updateFrameworkRes = packagesToUpdate.contains(PackageManagerService.PLATFORM_PACKAGE_NAME);
        for (int i = this.mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = this.mLruProcesses.get(i);
            if (app.thread != null && (userId == -1 || app.userId == userId)) {
                int packageCount = app.pkgList.size();
                for (int j = 0; j < packageCount; j++) {
                    String packageName = app.pkgList.keyAt(j);
                    if (updateFrameworkRes || packagesToUpdate.contains(packageName)) {
                        try {
                            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(packageName, 1024, app.userId);
                            if (ai != null) {
                                app.thread.scheduleApplicationInfoChanged(ai);
                            }
                        } catch (RemoteException e) {
                            Slog.w("ActivityManager", String.format("Failed to update %s ApplicationInfo for %s", packageName, app));
                        }
                    }
                }
            }
        }
        if (updateFrameworkRes) {
            Executor executor = ActivityThread.currentActivityThread().getExecutor();
            final DisplayManagerInternal display = (DisplayManagerInternal) LocalServices.getService(DisplayManagerInternal.class);
            if (display != null) {
                Objects.requireNonNull(display);
                executor.execute(new Runnable() { // from class: com.android.server.am.-$$Lambda$ActivityManagerService$gATL8uvTPRd405IfefK1RL9bNqA
                    @Override // java.lang.Runnable
                    public final void run() {
                        display.onOverlayChanged();
                    }
                });
            }
            if (this.mWindowManager != null) {
                final WindowManagerService windowManagerService = this.mWindowManager;
                Objects.requireNonNull(windowManagerService);
                executor.execute(new Runnable() { // from class: com.android.server.am.-$$Lambda$5hokEl5hcign5FXeGZdl53qh2zg
                    @Override // java.lang.Runnable
                    public final void run() {
                        WindowManagerService.this.onOverlayChanged();
                    }
                });
            }
        }
    }

    public void attachAgent(String process, String path) {
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                ProcessRecord proc = findProcessLocked(process, 0, "attachAgent");
                if (proc == null || proc.thread == null) {
                    throw new IllegalArgumentException("Unknown process: " + process);
                }
                boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
                if (!isDebuggable && (proc.info.flags & 2) == 0) {
                    throw new SecurityException("Process not debuggable: " + proc);
                }
                proc.thread.attachAgent(path);
            }
            resetPriorityAfterLockedSection();
        } catch (RemoteException e) {
            throw new IllegalStateException("Process disappeared");
        }
    }

    @VisibleForTesting
    /* loaded from: classes.dex */
    public static class Injector {
        private NetworkManagementInternal mNmi;

        public Context getContext() {
            return null;
        }

        public AppOpsService getAppOpsService(File file, Handler handler) {
            return new AppOpsService(file, handler);
        }

        public Handler getUiHandler(ActivityManagerService service) {
            Objects.requireNonNull(service);
            return new UiHandler();
        }

        public boolean isNetworkRestrictedForUid(int uid) {
            if (ensureHasNetworkManagementInternal()) {
                return this.mNmi.isNetworkRestrictedForUid(uid);
            }
            return false;
        }

        private boolean ensureHasNetworkManagementInternal() {
            if (this.mNmi == null) {
                this.mNmi = (NetworkManagementInternal) LocalServices.getService(NetworkManagementInternal.class);
            }
            return this.mNmi != null;
        }
    }

    public void setShowWhenLocked(IBinder token, boolean showWhenLocked) throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                long origId = Binder.clearCallingIdentity();
                r.setShowWhenLocked(showWhenLocked);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void setTurnScreenOn(IBinder token, boolean turnScreenOn) throws RemoteException {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                long origId = Binder.clearCallingIdentity();
                r.setTurnScreenOn(turnScreenOn);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void registerRemoteAnimations(IBinder token, RemoteAnimationDefinition definition) throws RemoteException {
        enforceCallingPermission("android.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS", "registerRemoteAnimations");
        definition.setCallingPid(Binder.getCallingPid());
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    resetPriorityAfterLockedSection();
                    return;
                }
                long origId = Binder.clearCallingIdentity();
                r.registerRemoteAnimations(definition);
                Binder.restoreCallingIdentity(origId);
                resetPriorityAfterLockedSection();
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
    }

    public void registerRemoteAnimationForNextActivityStart(String packageName, RemoteAnimationAdapter adapter) throws RemoteException {
        enforceCallingPermission("android.permission.CONTROL_REMOTE_APP_TRANSITION_ANIMATIONS", "registerRemoteAnimationForNextActivityStart");
        adapter.setCallingPid(Binder.getCallingPid());
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                this.mActivityStartController.registerRemoteAnimationForNextActivityStart(packageName, adapter);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void alwaysShowUnsupportedCompileSdkWarning(ComponentName activity) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                this.mAppWarnings.alwaysShowUnsupportedCompileSdkWarning(activity);
                Binder.restoreCallingIdentity(origId);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void setFocusedAppNoChecked(int taskId) {
        long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                boostPriorityForLockedSection();
                TaskRecord task = this.mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task != null) {
                    ActivityRecord r = task.topRunningActivityLocked();
                    if (this.mStackSupervisor.moveFocusableActivityStackToFrontLocked(r, "setFocusedTask")) {
                        this.mStackSupervisor.resumeFocusedStackTopActivityLocked();
                    }
                    resetPriorityAfterLockedSection();
                    return;
                }
                resetPriorityAfterLockedSection();
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    public void finishMiniProgram() {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                try {
                    finishMiniProgramLocked();
                    Binder.restoreCallingIdentity(origId);
                } catch (Exception e) {
                    Log.d("ActivityManager", "finishMiniProgram e" + e);
                    Binder.restoreCallingIdentity(origId);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void handleActivityChanged(Bundle bundle) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                try {
                    xpActivityManagerService.get(this.mContext).handleActivityChanged(bundle);
                    Binder.restoreCallingIdentity(origId);
                } catch (Exception e) {
                    Log.d("ActivityManager", "handleActivityChanged e" + e);
                    Binder.restoreCallingIdentity(origId);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    private void finishMiniProgramLocked() {
        try {
            ArrayList<ActivityRecord> list = getVisibleMiniProgramRecord();
            int size = list != null ? list.size() : 0;
            if (size <= 0) {
                return;
            }
            Iterator<ActivityRecord> it = list.iterator();
            while (it.hasNext()) {
                ActivityRecord r = it.next();
                ActivityStack.ActivityState state = r != null ? r.getState() : null;
                if (state != null && state != ActivityStack.ActivityState.DESTROYED && state != ActivityStack.ActivityState.DESTROYING) {
                    finishActivityAffinity(r.appToken.asBinder());
                }
            }
        } catch (Exception e) {
            Log.d("ActivityManager", "finishMiniProgramLocked e=" + e);
        }
    }

    private void handleActivityResumedLocked(ActivityRecord r) {
        if (r != null) {
            xpActivityManagerService.xpActivityRecord xr = new xpActivityManagerService.xpActivityRecord(r.realActivity);
            xr.intent = r.intent;
            if (this.mNotifyRecentActivity) {
                notifyPackageNotificationChanged(r);
            }
            xpActivityManagerService.get(this.mContext).onActivityResumed(xr);
        }
    }

    private ArrayList<ActivityRecord> getVisibleMiniProgramRecord() {
        ArrayList<ActivityRecord> visible = new ArrayList<>();
        ArrayList<ActivityRecord> history = getHistoryMiniProgramRecord();
        if (history != null && !history.isEmpty()) {
            Iterator<ActivityRecord> it = history.iterator();
            while (it.hasNext()) {
                ActivityRecord r = it.next();
                ActivityStack.ActivityState state = r != null ? r.getState() : null;
                if (state != null && state != ActivityStack.ActivityState.DESTROYED && state != ActivityStack.ActivityState.DESTROYING) {
                    visible.add(r);
                }
            }
        }
        return visible;
    }

    private ArrayList<ActivityRecord> getHistoryMiniProgramRecord() {
        ArrayList<ActivityRecord> activities = new ArrayList<>();
        try {
            int size = this.mStackSupervisor != null ? this.mStackSupervisor.getChildCount() : 0;
            for (int i = 0; i < size; i++) {
                ActivityDisplay ad = this.mStackSupervisor.getChildAt(i);
                ArrayList<ActivityStack> stacks = ad != null ? ad.getStacks(5) : null;
                if (stacks != null && !stacks.isEmpty()) {
                    Iterator<ActivityStack> it = stacks.iterator();
                    while (it.hasNext()) {
                        ActivityStack stack = it.next();
                        ArrayList<ActivityRecord> list = stack != null ? stack.getHistoryActivitiesLocked() : null;
                        if (list != null && !list.isEmpty()) {
                            Iterator<ActivityRecord> it2 = list.iterator();
                            while (it2.hasNext()) {
                                ActivityRecord r = it2.next();
                                if (r != null && ActivityInfoManager.isFreeformActivity(xpActivityInfo.create(r.intent))) {
                                    activities.add(r);
                                }
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
        }
        return activities;
    }

    private void notifyPackageNotificationChanged(ActivityRecord r) {
        try {
            if (this.mLastActivityRecord != null && r != null) {
                String lastPackageName = this.mLastActivityRecord.realActivity.getPackageName();
                String packageName = r.realActivity.getPackageName();
                if (!TextUtils.isEmpty(lastPackageName) && !lastPackageName.equals(packageName)) {
                    this.mHandler.sendMessage(this.mHandler.obtainMessage(71, r));
                } else {
                    this.mLastActivityRecord = r;
                }
                return;
            }
            this.mLastActivityRecord = r;
        } catch (Exception e) {
            Slog.i("ActivityManager", "setResumedActivityUncheckLocked e=" + e);
        }
    }

    /* JADX INFO: Access modifiers changed from: private */
    public String createPackageNotificationExtra(ComponentName lastComponent, ComponentName currentComponent) {
        String lastPackageName = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
        String lastActivityName = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
        String currentPackageName = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
        String currentActivityName = BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
        if (lastComponent != null) {
            try {
                lastPackageName = lastComponent.getPackageName();
                lastActivityName = lastComponent.getClassName();
            } catch (Exception e) {
                return BackupManagerConstants.DEFAULT_BACKUP_FINISHED_NOTIFICATION_RECEIVERS;
            }
        }
        if (currentComponent != null) {
            currentPackageName = currentComponent.getPackageName();
            currentActivityName = currentComponent.getClassName();
        }
        JSONObject object = new JSONObject();
        object.put("lastPackageName", lastPackageName);
        object.put("lastActivityName", lastActivityName);
        object.put("currentPackageName", currentPackageName);
        object.put("currentActivityName", currentActivityName);
        String extraString = object.toString();
        return extraString;
    }

    public boolean isTopActivityFullscreen() {
        return xpActivityManagerService.get(this.mContext).isTopActivityFullscreen();
    }

    public void forceGrantFolderPermission(String path) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                try {
                    xpActivityManagerService.get(this.mContext).grantFolderPermission(path);
                    Binder.restoreCallingIdentity(origId);
                } catch (Exception e) {
                    Log.d("ActivityManager", "forceGrantFolderPermission e=" + e);
                    Binder.restoreCallingIdentity(origId);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public String getOption(String key, String defaultValue) {
        return FeatureFactory.get(key, defaultValue);
    }

    public double[] getUsageInfo() {
        long origId = Binder.clearCallingIdentity();
        try {
            try {
                if (this.mProcessCpuTracker != null) {
                    synchronized (this.mProcessCpuTracker) {
                        this.mProcessCpuTracker.update();
                    }
                    double cpu = this.mProcessCpuTracker.getTotalCpuPercent();
                    double[] info = {cpu};
                    return info;
                }
            } catch (Exception e) {
                Log.d("ActivityManager", "getUsageInfo e=" + e);
            }
            return null;
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }

    public void setHomeState(ComponentName component, int state) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                xpActivityManagerService.get(this.mContext).setHomeState(component, state);
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public List<xpDialogInfo> getDialogRecorder(boolean topOnly) {
        List<xpDialogInfo> dialogRecorder;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                try {
                    dialogRecorder = xpActivityManagerService.get(this.mContext).getDialogRecorder(topOnly);
                    Binder.restoreCallingIdentity(origId);
                } catch (Exception e) {
                    Log.d("ActivityManager", "getDialogRecorder e=" + e);
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return null;
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return dialogRecorder;
    }

    public void setDialogRecorder(xpDialogInfo info) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                try {
                    xpActivityManagerService.get(this.mContext).setDialogRecorder(info);
                    Binder.restoreCallingIdentity(origId);
                } catch (Exception e) {
                    Log.d("ActivityManager", "setDialogRecorder e=" + e);
                    Binder.restoreCallingIdentity(origId);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public void dismissDialog(int type) {
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                try {
                    xpActivityManagerService.get(this.mContext).dismissDialog(type);
                    Binder.restoreCallingIdentity(origId);
                } catch (Exception e) {
                    Log.d("ActivityManager", "dismissDialog e=" + e);
                    Binder.restoreCallingIdentity(origId);
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
    }

    public List<String> getSpeechObserver() {
        List<String> speechObserver;
        synchronized (this) {
            try {
                boostPriorityForLockedSection();
                long origId = Binder.clearCallingIdentity();
                try {
                    speechObserver = xpActivityManagerService.get(this.mContext).getSpeechObserver();
                    Binder.restoreCallingIdentity(origId);
                } catch (Exception e) {
                    Log.d("ActivityManager", "getSpeechObserver e=" + e);
                    Binder.restoreCallingIdentity(origId);
                    resetPriorityAfterLockedSection();
                    return null;
                }
            } catch (Throwable th) {
                resetPriorityAfterLockedSection();
                throw th;
            }
        }
        resetPriorityAfterLockedSection();
        return speechObserver;
    }
}
